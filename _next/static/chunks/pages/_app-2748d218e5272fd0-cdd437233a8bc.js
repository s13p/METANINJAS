(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [888], {
        1314: function(e, t, n) {
            "use strict";
            n.d(t, {
                He: function() {
                    return u
                },
                Ld: function() {
                    return w
                },
                eC: function() {
                    return d
                },
                f3: function() {
                    return l
                },
                iG: function() {
                    return h
                },
                rS: function() {
                    return p
                },
                sb: function() {
                    return v
                },
                ys: function() {
                    return o
                }
            });
            var r = n(1132),
                i = n(7294);
            let a = Symbol.for("Animated:node"),
                s = e => !!e && e[a] === e,
                o = e => e && e[a],
                l = (e, t) => (0, r.dE)(e, a, t),
                u = e => e && e[a] && e[a].getPayload();
            class c {
                constructor() {
                    this.payload = void 0, l(this, this)
                }
                getPayload() {
                    return this.payload || []
                }
            }
            class h extends c {
                constructor(e) {
                    super(), this.done = !0, this.elapsedTime = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.v0 = void 0, this.durationProgress = 0, this._value = e, r.is.num(this._value) && (this.lastPosition = this._value)
                }
                static create(e) {
                    return new h(e)
                }
                getPayload() {
                    return [this]
                }
                getValue() {
                    return this._value
                }
                setValue(e, t) {
                    return r.is.num(e) && (this.lastPosition = e, t && (e = Math.round(e / t) * t, this.done && (this.lastPosition = e))), this._value !== e && (this._value = e, !0)
                }
                reset() {
                    let {
                        done: e
                    } = this;
                    this.done = !1, r.is.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null)
                }
            }
            class d extends h {
                constructor(e) {
                    super(0), this._string = null, this._toString = void 0, this._toString = (0, r.mD)({
                        output: [e, e]
                    })
                }
                static create(e) {
                    return new d(e)
                }
                getValue() {
                    let e = this._string;
                    return null == e ? this._string = this._toString(this._value) : e
                }
                setValue(e) {
                    if (r.is.str(e)) {
                        if (e == this._string) return !1;
                        this._string = e, this._value = 1
                    } else {
                        if (!super.setValue(e)) return !1;
                        this._string = null
                    }
                    return !0
                }
                reset(e) {
                    e && (this._toString = (0, r.mD)({
                        output: [this.getValue(), e]
                    })), this._value = 0, super.reset()
                }
            }
            let f = {
                dependencies: null
            };
            class p extends c {
                constructor(e) {
                    super(), this.source = e, this.setValue(e)
                }
                getValue(e) {
                    let t = {};
                    return (0, r.rU)(this.source, (n, i) => {
                        s(n) ? t[i] = n.getValue(e) : (0, r.j$)(n) ? t[i] = (0, r.je)(n) : e || (t[i] = n)
                    }), t
                }
                setValue(e) {
                    this.source = e, this.payload = this._makePayload(e)
                }
                reset() {
                    this.payload && (0, r.S6)(this.payload, e => e.reset())
                }
                _makePayload(e) {
                    if (e) {
                        let t = new Set;
                        return (0, r.rU)(e, this._addToPayload, t), Array.from(t)
                    }
                }
                _addToPayload(e) {
                    f.dependencies && (0, r.j$)(e) && f.dependencies.add(e);
                    let t = u(e);
                    t && (0, r.S6)(t, e => this.add(e))
                }
            }
            class m extends p {
                constructor(e) {
                    super(e)
                }
                static create(e) {
                    return new m(e)
                }
                getValue() {
                    return this.source.map(e => e.getValue())
                }
                setValue(e) {
                    let t = this.getPayload();
                    return e.length == t.length ? t.map((t, n) => t.setValue(e[n])).some(Boolean) : (super.setValue(e.map(g)), !0)
                }
            }

            function g(e) {
                let t = (0, r.Df)(e) ? d : h;
                return t.create(e)
            }

            function v(e) {
                let t = o(e);
                return t ? t.constructor : r.is.arr(e) ? m : (0, r.Df)(e) ? d : h
            }

            function _() {
                return (_ = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }).apply(this, arguments)
            }
            let y = (e, t) => {
                let n = !r.is.fun(e) || e.prototype && e.prototype.isReactComponent;
                return (0, i.forwardRef)((a, s) => {
                    let o = (0, i.useRef)(null),
                        l = n && (0, i.useCallback)(e => {
                            var t;
                            o.current = ((t = s) && (r.is.fun(t) ? t(e) : t.current = e), e)
                        }, [s]),
                        [u, c] = function(e, t) {
                            let n = new Set;
                            return f.dependencies = n, e.style && (e = _({}, e, {
                                style: t.createAnimatedStyle(e.style)
                            })), e = new p(e), f.dependencies = null, [e, n]
                        }(a, t),
                        h = (0, r.NW)(),
                        d = () => {
                            let e = o.current;
                            if (n && !e) return;
                            let r = !!e && t.applyAnimatedValues(e, u.getValue(!0));
                            !1 === r && h()
                        },
                        m = new x(d, c),
                        g = (0, i.useRef)();
                    (0, r.LI)(() => (g.current = m, (0, r.S6)(c, e => (0, r.UI)(e, m)), () => {
                        g.current && ((0, r.S6)(g.current.deps, e => (0, r.iL)(e, g.current)), r.Wn.cancel(g.current.update))
                    })), (0, i.useEffect)(d, []), (0, r.tf)(() => () => {
                        let e = g.current;
                        (0, r.S6)(e.deps, t => (0, r.iL)(t, e))
                    });
                    let v = t.getComponentProps(u.getValue());
                    return i.createElement(e, _({}, v, {
                        ref: l
                    }))
                })
            };
            class x {
                constructor(e, t) {
                    this.update = e, this.deps = t
                }
                eventObserved(e) {
                    "change" == e.type && r.Wn.write(this.update)
                }
            }
            let b = Symbol.for("AnimatedComponent"),
                w = (e, {
                    applyAnimatedValues: t = () => !1,
                    createAnimatedStyle: n = e => new p(e),
                    getComponentProps: i = e => e
                } = {}) => {
                    let a = {
                            applyAnimatedValues: t,
                            createAnimatedStyle: n,
                            getComponentProps: i
                        },
                        s = e => {
                            let t = S(e) || "Anonymous";
                            return (e = r.is.str(e) ? s[e] || (s[e] = y(e, a)) : e[b] || (e[b] = y(e, a))).displayName = `Animated(${t})`, e
                        };
                    return (0, r.rU)(e, (t, n) => {
                        r.is.arr(e) && (n = S(t)), s[n] = s(t)
                    }), {
                        animated: s
                    }
                },
                S = e => r.is.str(e) ? e : e && r.is.str(e.displayName) ? e.displayName : r.is.fun(e) && e.name || null
        },
        4928: function(e, t, n) {
            "use strict";
            let r;
            n.d(t, {
                Globals: function() {
                    return s.OH
                },
                config: function() {
                    return M
                },
                to: function() {
                    return eS
                },
                useSpring: function() {
                    return eg
                },
                useTransition: function() {
                    return ev
                }
            });
            var i, a, s = n(1132),
                o = n(7294),
                l = n(1314);

            function u() {
                return (u = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }).apply(this, arguments)
            }

            function c(e, ...t) {
                return s.is.fun(e) ? e(...t) : e
            }
            let h = (e, t) => !0 === e || !!(t && e && (s.is.fun(e) ? e(t) : (0, s.qo)(e).includes(t))),
                d = (e, t) => s.is.obj(e) ? t && e[t] : e,
                f = (e, t) => !0 === e.default ? e[t] : e.default ? e.default[t] : void 0,
                p = e => e,
                m = (e, t = p) => {
                    let n = g;
                    e.default && !0 !== e.default && (n = Object.keys(e = e.default));
                    let r = {};
                    for (let i of n) {
                        let a = t(e[i], i);
                        s.is.und(a) || (r[i] = a)
                    }
                    return r
                },
                g = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"],
                v = {
                    config: 1,
                    from: 1,
                    to: 1,
                    ref: 1,
                    loop: 1,
                    reset: 1,
                    pause: 1,
                    cancel: 1,
                    reverse: 1,
                    immediate: 1,
                    default: 1,
                    delay: 1,
                    onProps: 1,
                    onStart: 1,
                    onChange: 1,
                    onPause: 1,
                    onResume: 1,
                    onRest: 1,
                    onResolve: 1,
                    items: 1,
                    trail: 1,
                    sort: 1,
                    expires: 1,
                    initial: 1,
                    enter: 1,
                    update: 1,
                    leave: 1,
                    children: 1,
                    onDestroyed: 1,
                    keys: 1,
                    callId: 1,
                    parentId: 1
                };

            function _(e) {
                let t = function(e) {
                    let t = {},
                        n = 0;
                    if ((0, s.rU)(e, (e, r) => {
                            !v[r] && (t[r] = e, n++)
                        }), n) return t
                }(e);
                if (t) {
                    let n = {
                        to: t
                    };
                    return (0, s.rU)(e, (e, r) => r in t || (n[r] = e)), n
                }
                return u({}, e)
            }

            function y(e) {
                return e = (0, s.je)(e), s.is.arr(e) ? e.map(y) : (0, s.Df)(e) ? s.OH.createStringInterpolator({
                    range: [0, 1],
                    output: [e, e]
                })(1) : e
            }

            function x(e) {
                for (let t in e) return !0;
                return !1
            }

            function b(e) {
                return s.is.fun(e) || s.is.arr(e) && s.is.obj(e[0])
            }

            function w(e, t) {
                var n;
                null == (n = e.ref) || n.delete(e), null == t || t.delete(e)
            }

            function S(e, t) {
                if (t && e.ref !== t) {
                    var n;
                    null == (n = e.ref) || n.delete(e), t.add(e), e.ref = t
                }
            }
            let M = {
                    default: {
                        tension: 170,
                        friction: 26
                    },
                    gentle: {
                        tension: 120,
                        friction: 14
                    },
                    wobbly: {
                        tension: 180,
                        friction: 12
                    },
                    stiff: {
                        tension: 210,
                        friction: 20
                    },
                    slow: {
                        tension: 280,
                        friction: 60
                    },
                    molasses: {
                        tension: 280,
                        friction: 120
                    }
                },
                T = u({}, M.default, {
                    mass: 1,
                    damping: 1,
                    easing: s.Z5.linear,
                    clamp: !1
                });
            class A {
                constructor() {
                    this.tension = void 0, this.friction = void 0, this.frequency = void 0, this.damping = void 0, this.mass = void 0, this.velocity = 0, this.restVelocity = void 0, this.precision = void 0, this.progress = void 0, this.duration = void 0, this.easing = void 0, this.clamp = void 0, this.bounce = void 0, this.decay = void 0, this.round = void 0, Object.assign(this, T)
                }
            }

            function E(e, t) {
                if (s.is.und(t.decay)) {
                    let n = !s.is.und(t.tension) || !s.is.und(t.friction);
                    !n && s.is.und(t.frequency) && s.is.und(t.damping) && s.is.und(t.mass) || (e.duration = void 0, e.decay = void 0), n && (e.frequency = void 0)
                } else e.duration = void 0
            }
            let C = [];
            class I {
                constructor() {
                    this.changed = !1, this.values = C, this.toValues = null, this.fromValues = C, this.to = void 0, this.from = void 0, this.config = new A, this.immediate = !1
                }
            }

            function P(e, {
                key: t,
                props: n,
                defaultProps: r,
                state: i,
                actions: a
            }) {
                return new Promise((o, l) => {
                    var d;
                    let f, p;
                    let m = h(null != (d = n.cancel) ? d : null == r ? void 0 : r.cancel, t);
                    if (m) y();
                    else {
                        s.is.und(n.pause) || (i.paused = h(n.pause, t));
                        let g = null == r ? void 0 : r.pause;
                        !0 !== g && (g = i.paused || h(g, t)), f = c(n.delay || 0, t), g ? (i.resumeQueue.add(_), a.pause()) : (a.resume(), _())
                    }

                    function v() {
                        i.resumeQueue.add(_), i.timeouts.delete(p), p.cancel(), f = p.time - s.Wn.now()
                    }

                    function _() {
                        f > 0 && !s.OH.skipAnimation ? (i.delayed = !0, p = s.Wn.setTimeout(y, f), i.pauseQueue.add(v), i.timeouts.add(p)) : y()
                    }

                    function y() {
                        i.delayed && (i.delayed = !1), i.pauseQueue.delete(v), i.timeouts.delete(p), e <= (i.cancelId || 0) && (m = !0);
                        try {
                            a.start(u({}, n, {
                                callId: e,
                                cancel: m
                            }), o)
                        } catch (t) {
                            l(t)
                        }
                    }
                })
            }
            let R = (e, t) => 1 == t.length ? t[0] : t.some(e => e.cancelled) ? k(e.get()) : t.every(e => e.noop) ? L(e.get()) : D(e.get(), t.every(e => e.finished)),
                L = e => ({
                    value: e,
                    noop: !0,
                    finished: !0,
                    cancelled: !1
                }),
                D = (e, t, n = !1) => ({
                    value: e,
                    finished: t,
                    cancelled: n
                }),
                k = e => ({
                    value: e,
                    cancelled: !0,
                    finished: !1
                });

            function U(e, t, n, r) {
                let {
                    callId: i,
                    parentId: a,
                    onRest: o
                } = t, {
                    asyncTo: l,
                    promise: c
                } = n;
                return a || e !== l || t.reset ? n.promise = (async () => {
                    let h, d, f;
                    n.asyncId = i, n.asyncTo = e;
                    let p = m(t, (e, t) => "onRest" === t ? void 0 : e),
                        g = new Promise((e, t) => (h = e, d = t)),
                        v = e => {
                            let t = i <= (n.cancelId || 0) && k(r) || i !== n.asyncId && D(r, !1);
                            if (t) throw e.result = t, d(e), e
                        },
                        _ = (e, t) => {
                            let a = new F,
                                o = new N;
                            return (async () => {
                                if (s.OH.skipAnimation) throw O(n), o.result = D(r, !1), d(o), o;
                                v(a);
                                let l = s.is.obj(e) ? u({}, e) : u({}, t, {
                                    to: e
                                });
                                l.parentId = i, (0, s.rU)(p, (e, t) => {
                                    s.is.und(l[t]) && (l[t] = e)
                                });
                                let c = await r.start(l);
                                return v(a), n.paused && await new Promise(e => {
                                    n.resumeQueue.add(e)
                                }), c
                            })()
                        };
                    if (s.OH.skipAnimation) return O(n), D(r, !1);
                    try {
                        await Promise.all([(s.is.arr(e) ? (async e => {
                            for (let t of e) await _(t)
                        })(e) : Promise.resolve(e(_, r.stop.bind(r)))).then(h), g]), f = D(r.get(), !0, !1)
                    } catch (y) {
                        if (y instanceof F) f = y.result;
                        else if (y instanceof N) f = y.result;
                        else throw y
                    } finally {
                        i == n.asyncId && (n.asyncId = a, n.asyncTo = a ? l : void 0, n.promise = a ? c : void 0)
                    }
                    return s.is.fun(o) && s.Wn.batchedUpdates(() => {
                        o(f, r, r.item)
                    }), f
                })() : c
            }

            function O(e, t) {
                (0, s.yl)(e.timeouts, e => e.cancel()), e.pauseQueue.clear(), e.resumeQueue.clear(), e.asyncId = e.asyncTo = e.promise = void 0, t && (e.cancelId = t)
            }
            class F extends Error {
                constructor() {
                    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."), this.result = void 0
                }
            }
            class N extends Error {
                constructor() {
                    super("SkipAnimationSignal"), this.result = void 0
                }
            }
            let B = e => e instanceof G,
                z = 1;
            class G extends s.B0 {
                constructor(...e) {
                    super(...e), this.id = z++, this.key = void 0, this._priority = 0
                }
                get priority() {
                    return this._priority
                }
                set priority(e) {
                    this._priority != e && (this._priority = e, this._onPriorityChange(e))
                }
                get() {
                    let e = (0, l.ys)(this);
                    return e && e.getValue()
                }
                to(...e) {
                    return s.OH.to(this, e)
                }
                interpolate(...e) {
                    return (0, s.LW)(), s.OH.to(this, e)
                }
                toJSON() {
                    return this.get()
                }
                observerAdded(e) {
                    1 == e && this._attach()
                }
                observerRemoved(e) {
                    0 == e && this._detach()
                }
                _attach() {}
                _detach() {}
                _onChange(e, t = !1) {
                    (0, s.k0)(this, {
                        type: "change",
                        parent: this,
                        value: e,
                        idle: t
                    })
                }
                _onPriorityChange(e) {
                    this.idle || s.fT.sort(this), (0, s.k0)(this, {
                        type: "priority",
                        parent: this,
                        priority: e
                    })
                }
            }
            let V = Symbol.for("SpringPhase"),
                W = e => (1 & e[V]) > 0,
                H = e => (2 & e[V]) > 0,
                j = e => (4 & e[V]) > 0,
                q = (e, t) => t ? e[V] |= 3 : e[V] &= -3,
                X = (e, t) => t ? e[V] |= 4 : e[V] &= -5;
            class Z extends G {
                constructor(e, t) {
                    if (super(), this.key = void 0, this.animation = new I, this.queue = void 0, this.defaultProps = {}, this._state = {
                            paused: !1,
                            delayed: !1,
                            pauseQueue: new Set,
                            resumeQueue: new Set,
                            timeouts: new Set
                        }, this._pendingCalls = new Set, this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !s.is.und(e) || !s.is.und(t)) {
                        let n = s.is.obj(e) ? u({}, e) : u({}, t, {
                            from: e
                        });
                        s.is.und(n.default) && (n.default = !0), this.start(n)
                    }
                }
                get idle() {
                    return !(H(this) || this._state.asyncTo) || j(this)
                }
                get goal() {
                    return (0, s.je)(this.animation.to)
                }
                get velocity() {
                    let e = (0, l.ys)(this);
                    return e instanceof l.iG ? e.lastVelocity || 0 : e.getPayload().map(e => e.lastVelocity || 0)
                }
                get hasAnimated() {
                    return W(this)
                }
                get isAnimating() {
                    return H(this)
                }
                get isPaused() {
                    return j(this)
                }
                get isDelayed() {
                    return this._state.delayed
                }
                advance(e) {
                    let t = !0,
                        n = !1,
                        r = this.animation,
                        {
                            config: i,
                            toValues: a
                        } = r,
                        o = (0, l.He)(r.to);
                    !o && (0, s.j$)(r.to) && (a = (0, s.qo)((0, s.je)(r.to))), r.values.forEach((u, c) => {
                        if (u.done) return;
                        let h = u.constructor == l.eC ? 1 : o ? o[c].lastPosition : a[c],
                            d = r.immediate,
                            f = h;
                        if (!d) {
                            let p;
                            if (f = u.lastPosition, i.tension <= 0) {
                                u.done = !0;
                                return
                            }
                            let m = u.elapsedTime += e,
                                g = r.fromValues[c],
                                v = null != u.v0 ? u.v0 : u.v0 = s.is.arr(i.velocity) ? i.velocity[c] : i.velocity,
                                _ = i.precision || (g == h ? .005 : Math.min(1, .001 * Math.abs(h - g)));
                            if (s.is.und(i.duration)) {
                                if (i.decay) {
                                    let y = !0 === i.decay ? .998 : i.decay,
                                        x = Math.exp(-(1 - y) * m);
                                    f = g + v / (1 - y) * (1 - x), d = Math.abs(u.lastPosition - f) <= _, p = v * x
                                } else {
                                    p = null == u.lastVelocity ? v : u.lastVelocity;
                                    let b = i.restVelocity || _ / 10,
                                        w = i.clamp ? 0 : i.bounce,
                                        S = !s.is.und(w),
                                        M = g == h ? u.v0 > 0 : g < h,
                                        T = Math.ceil(e / 1);
                                    for (let A = 0; A < T && !(!(Math.abs(p) > b) && (d = Math.abs(h - f) <= _)); ++A) {
                                        S && (f == h || f > h == M) && (p = -p * w, f = h);
                                        let E = -(1e-6 * i.tension) * (f - h),
                                            C = -(.001 * i.friction) * p,
                                            I = (E + C) / i.mass;
                                        p += 1 * I, f += 1 * p
                                    }
                                }
                            } else {
                                let P = 1;
                                i.duration > 0 && (this._memoizedDuration !== i.duration && (this._memoizedDuration = i.duration, u.durationProgress > 0 && (u.elapsedTime = i.duration * u.durationProgress, m = u.elapsedTime += e)), P = (P = (i.progress || 0) + m / this._memoizedDuration) > 1 ? 1 : P < 0 ? 0 : P, u.durationProgress = P), p = ((f = g + i.easing(P) * (h - g)) - u.lastPosition) / e, d = 1 == P
                            }
                            u.lastVelocity = p, Number.isNaN(f) && (console.warn("Got NaN while animating:", this), d = !0)
                        }
                        o && !o[c].done && (d = !1), d ? u.done = !0 : t = !1, u.setValue(f, i.round) && (n = !0)
                    });
                    let u = (0, l.ys)(this),
                        c = u.getValue();
                    if (t) {
                        let h = (0, s.je)(r.to);
                        (c !== h || n) && !i.decay ? (u.setValue(h), this._onChange(h)) : n && i.decay && this._onChange(c), this._stop()
                    } else n && this._onChange(c)
                }
                set(e) {
                    return s.Wn.batchedUpdates(() => {
                        this._stop(), this._focus(e), this._set(e)
                    }), this
                }
                pause() {
                    this._update({
                        pause: !0
                    })
                }
                resume() {
                    this._update({
                        pause: !1
                    })
                }
                finish() {
                    if (H(this)) {
                        let {
                            to: e,
                            config: t
                        } = this.animation;
                        s.Wn.batchedUpdates(() => {
                            this._onStart(), t.decay || this._set(e, !1), this._stop()
                        })
                    }
                    return this
                }
                update(e) {
                    let t = this.queue || (this.queue = []);
                    return t.push(e), this
                }
                start(e, t) {
                    let n;
                    return s.is.und(e) ? (n = this.queue || [], this.queue = []) : n = [s.is.obj(e) ? e : u({}, t, {
                        to: e
                    })], Promise.all(n.map(e => {
                        let t = this._update(e);
                        return t
                    })).then(e => R(this, e))
                }
                stop(e) {
                    let {
                        to: t
                    } = this.animation;
                    return this._focus(this.get()), O(this._state, e && this._lastCallId), s.Wn.batchedUpdates(() => this._stop(t, e)), this
                }
                reset() {
                    this._update({
                        reset: !0
                    })
                }
                eventObserved(e) {
                    "change" == e.type ? this._start() : "priority" == e.type && (this.priority = e.priority + 1)
                }
                _prepareNode(e) {
                    let t = this.key || "",
                        {
                            to: n,
                            from: r
                        } = e;
                    (null == (n = s.is.obj(n) ? n[t] : n) || b(n)) && (n = void 0), null == (r = s.is.obj(r) ? r[t] : r) && (r = void 0);
                    let i = {
                        to: n,
                        from: r
                    };
                    return W(this) || (e.reverse && ([n, r] = [r, n]), r = (0, s.je)(r), s.is.und(r) ? (0, l.ys)(this) || this._set(n) : this._set(r)), i
                }
                _update(e, t) {
                    let n = u({}, e),
                        {
                            key: r,
                            defaultProps: i
                        } = this;
                    n.default && Object.assign(i, m(n, (e, t) => /^on/.test(t) ? d(e, r) : e)), ee(this, n, "onProps"), et(this, "onProps", n, this);
                    let a = this._prepareNode(n);
                    if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
                    let o = this._state;
                    return P(++this._lastCallId, {
                        key: r,
                        props: n,
                        defaultProps: i,
                        state: o,
                        actions: {
                            pause: () => {
                                j(this) || (X(this, !0), (0, s.bl)(o.pauseQueue), et(this, "onPause", D(this, Y(this, this.animation.to)), this))
                            },
                            resume: () => {
                                j(this) && (X(this, !1), H(this) && this._resume(), (0, s.bl)(o.resumeQueue), et(this, "onResume", D(this, Y(this, this.animation.to)), this))
                            },
                            start: this._merge.bind(this, a)
                        }
                    }).then(e => {
                        if (n.loop && e.finished && !(t && e.noop)) {
                            let r = $(n);
                            if (r) return this._update(r, !0)
                        }
                        return e
                    })
                }
                _merge(e, t, n) {
                    if (t.cancel) return this.stop(!0), n(k(this));
                    let r = !s.is.und(e.to),
                        i = !s.is.und(e.from);
                    if (r || i) {
                        if (!(t.callId > this._lastToId)) return n(k(this));
                        this._lastToId = t.callId
                    }
                    let {
                        key: a,
                        defaultProps: o,
                        animation: d
                    } = this, {
                        to: f,
                        from: p
                    } = d, {
                        to: m = f,
                        from: g = p
                    } = e;
                    i && !r && (!t.default || s.is.und(m)) && (m = g), t.reverse && ([m, g] = [g, m]);
                    let v = !(0, s.Xy)(g, p);
                    v && (d.from = g), g = (0, s.je)(g);
                    let _ = !(0, s.Xy)(m, f);
                    _ && this._focus(m);
                    let x = b(t.to),
                        {
                            config: w
                        } = d,
                        {
                            decay: S,
                            velocity: M
                        } = w;
                    (r || i) && (w.velocity = 0), t.config && !x && function(e, t, n) {
                        for (let r in n && (E(n = u({}, n), t), t = u({}, n, t)), E(e, t), Object.assign(e, t), T) null == e[r] && (e[r] = T[r]);
                        let {
                            mass: i,
                            frequency: a,
                            damping: o
                        } = e;
                        s.is.und(a) || (a < .01 && (a = .01), o < 0 && (o = 0), e.tension = Math.pow(2 * Math.PI / a, 2) * i, e.friction = 4 * Math.PI * o * i / a)
                    }(w, c(t.config, a), t.config !== o.config ? c(o.config, a) : void 0);
                    let A = (0, l.ys)(this);
                    if (!A || s.is.und(m)) return n(D(this, !0));
                    let C = s.is.und(t.reset) ? i && !t.default : !s.is.und(g) && h(t.reset, a),
                        I = C ? g : this.get(),
                        P = y(m),
                        R = s.is.num(P) || s.is.arr(P) || (0, s.Df)(P),
                        O = !x && (!R || h(o.immediate || t.immediate, a));
                    if (_) {
                        let F = (0, l.sb)(m);
                        if (F !== A.constructor) {
                            if (O) A = this._set(P);
                            else throw Error(`Cannot animate between ${A.constructor.name} and ${F.name}, as the "to" prop suggests`)
                        }
                    }
                    let N = A.constructor,
                        B = (0, s.j$)(m),
                        z = !1;
                    if (!B) {
                        let G = C || !W(this) && v;
                        (_ || G) && (B = !(z = (0, s.Xy)(y(I), P))), ((0, s.Xy)(d.immediate, O) || O) && (0, s.Xy)(w.decay, S) && (0, s.Xy)(w.velocity, M) || (B = !0)
                    }
                    if (z && H(this) && (d.changed && !C ? B = !0 : B || this._stop(f)), !x && ((B || (0, s.j$)(f)) && (d.values = A.getPayload(), d.toValues = (0, s.j$)(m) ? null : N == l.eC ? [1] : (0, s.qo)(P)), d.immediate == O || (d.immediate = O, O || C || this._set(f)), B)) {
                        let {
                            onRest: V
                        } = d;
                        (0, s.S6)(Q, e => ee(this, t, e));
                        let j = D(this, Y(this, f));
                        (0, s.bl)(this._pendingCalls, j), this._pendingCalls.add(n), d.changed && s.Wn.batchedUpdates(() => {
                            d.changed = !C, null == V || V(j, this), C ? c(o.onRest, j) : null == d.onStart || d.onStart(j, this)
                        })
                    }
                    C && this._set(I), x ? n(U(t.to, t, this._state, this)) : B ? this._start() : H(this) && !_ ? this._pendingCalls.add(n) : n(L(I))
                }
                _focus(e) {
                    let t = this.animation;
                    e !== t.to && ((0, s.Ll)(this) && this._detach(), t.to = e, (0, s.Ll)(this) && this._attach())
                }
                _attach() {
                    let e = 0,
                        {
                            to: t
                        } = this.animation;
                    (0, s.j$)(t) && ((0, s.UI)(t, this), B(t) && (e = t.priority + 1)), this.priority = e
                }
                _detach() {
                    let {
                        to: e
                    } = this.animation;
                    (0, s.j$)(e) && (0, s.iL)(e, this)
                }
                _set(e, t = !0) {
                    let n = (0, s.je)(e);
                    if (!s.is.und(n)) {
                        let r = (0, l.ys)(this);
                        if (!r || !(0, s.Xy)(n, r.getValue())) {
                            let i = (0, l.sb)(n);
                            r && r.constructor == i ? r.setValue(n) : (0, l.f3)(this, i.create(n)), r && s.Wn.batchedUpdates(() => {
                                this._onChange(n, t)
                            })
                        }
                    }
                    return (0, l.ys)(this)
                }
                _onStart() {
                    let e = this.animation;
                    e.changed || (e.changed = !0, et(this, "onStart", D(this, Y(this, e.to)), this))
                }
                _onChange(e, t) {
                    t || (this._onStart(), c(this.animation.onChange, e, this)), c(this.defaultProps.onChange, e, this), super._onChange(e, t)
                }
                _start() {
                    let e = this.animation;
                    (0, l.ys)(this).reset((0, s.je)(e.to)), e.immediate || (e.fromValues = e.values.map(e => e.lastPosition)), H(this) || (q(this, !0), j(this) || this._resume())
                }
                _resume() {
                    s.OH.skipAnimation ? this.finish() : s.fT.start(this)
                }
                _stop(e, t) {
                    if (H(this)) {
                        q(this, !1);
                        let n = this.animation;
                        (0, s.S6)(n.values, e => {
                            e.done = !0
                        }), n.toValues && (n.onChange = n.onPause = n.onResume = void 0), (0, s.k0)(this, {
                            type: "idle",
                            parent: this
                        });
                        let r = t ? k(this.get()) : D(this.get(), Y(this, null != e ? e : n.to));
                        (0, s.bl)(this._pendingCalls, r), n.changed && (n.changed = !1, et(this, "onRest", r, this))
                    }
                }
            }

            function Y(e, t) {
                let n = y(t),
                    r = y(e.get());
                return (0, s.Xy)(r, n)
            }

            function $(e, t = e.loop, n = e.to) {
                let r = c(t);
                if (r) {
                    let i = !0 !== r && _(r),
                        a = (i || e).reverse,
                        s = !i || i.reset;
                    return J(u({}, e, {
                        loop: t,
                        default: !1,
                        pause: void 0,
                        to: !a || b(n) ? n : void 0,
                        from: s ? e.from : void 0,
                        reset: s
                    }, i))
                }
            }

            function J(e) {
                let {
                    to: t,
                    from: n
                } = e = _(e), r = new Set;
                return s.is.obj(t) && K(t, r), s.is.obj(n) && K(n, r), e.keys = r.size ? Array.from(r) : null, e
            }

            function K(e, t) {
                (0, s.rU)(e, (e, n) => null != e && t.add(n))
            }
            let Q = ["onStart", "onRest", "onChange", "onPause", "onResume"];

            function ee(e, t, n) {
                e.animation[n] = t[n] !== f(t, n) ? d(t[n], e.key) : void 0
            }

            function et(e, t, ...n) {
                var r, i, a, s;
                null == (r = (i = e.animation)[t]) || r.call(i, ...n), null == (a = (s = e.defaultProps)[t]) || a.call(s, ...n)
            }
            let en = ["onStart", "onChange", "onRest"],
                er = 1;
            class ei {
                constructor(e, t) {
                    this.id = er++, this.springs = {}, this.queue = [], this.ref = void 0, this._flush = void 0, this._initialProps = void 0, this._lastAsyncId = 0, this._active = new Set, this._changed = new Set, this._started = !1, this._item = void 0, this._state = {
                        paused: !1,
                        pauseQueue: new Set,
                        resumeQueue: new Set,
                        timeouts: new Set
                    }, this._events = {
                        onStart: new Map,
                        onChange: new Map,
                        onRest: new Map
                    }, this._onFrame = this._onFrame.bind(this), t && (this._flush = t), e && this.start(u({
                        default: !0
                    }, e))
                }
                get idle() {
                    return !this._state.asyncTo && Object.values(this.springs).every(e => e.idle && !e.isDelayed && !e.isPaused)
                }
                get item() {
                    return this._item
                }
                set item(e) {
                    this._item = e
                }
                get() {
                    let e = {};
                    return this.each((t, n) => e[n] = t.get()), e
                }
                set(e) {
                    for (let t in e) {
                        let n = e[t];
                        s.is.und(n) || this.springs[t].set(n)
                    }
                }
                update(e) {
                    return e && this.queue.push(J(e)), this
                }
                start(e) {
                    let {
                        queue: t
                    } = this;
                    return (e ? t = (0, s.qo)(e).map(J) : this.queue = [], this._flush) ? this._flush(this, t) : (eh(this, t), ea(this, t))
                }
                stop(e, t) {
                    if (!!e !== e && (t = e), t) {
                        let n = this.springs;
                        (0, s.S6)((0, s.qo)(t), t => n[t].stop(!!e))
                    } else O(this._state, this._lastAsyncId), this.each(t => t.stop(!!e));
                    return this
                }
                pause(e) {
                    if (s.is.und(e)) this.start({
                        pause: !0
                    });
                    else {
                        let t = this.springs;
                        (0, s.S6)((0, s.qo)(e), e => t[e].pause())
                    }
                    return this
                }
                resume(e) {
                    if (s.is.und(e)) this.start({
                        pause: !1
                    });
                    else {
                        let t = this.springs;
                        (0, s.S6)((0, s.qo)(e), e => t[e].resume())
                    }
                    return this
                }
                each(e) {
                    (0, s.rU)(this.springs, e)
                }
                _onFrame() {
                    let {
                        onStart: e,
                        onChange: t,
                        onRest: n
                    } = this._events, r = this._active.size > 0, i = this._changed.size > 0;
                    (r && !this._started || i && !this._started) && (this._started = !0, (0, s.yl)(e, ([e, t]) => {
                        t.value = this.get(), e(t, this, this._item)
                    }));
                    let a = !r && this._started,
                        o = i || a && n.size ? this.get() : null;
                    i && t.size && (0, s.yl)(t, ([e, t]) => {
                        t.value = o, e(t, this, this._item)
                    }), a && (this._started = !1, (0, s.yl)(n, ([e, t]) => {
                        t.value = o, e(t, this, this._item)
                    }))
                }
                eventObserved(e) {
                    if ("change" == e.type) this._changed.add(e.parent), e.idle || this._active.add(e.parent);
                    else {
                        if ("idle" != e.type) return;
                        this._active.delete(e.parent)
                    }
                    s.Wn.onFrame(this._onFrame)
                }
            }

            function ea(e, t) {
                return Promise.all(t.map(t => es(e, t))).then(t => R(e, t))
            }
            async function es(e, t, n) {
                let {
                    keys: r,
                    to: i,
                    from: a,
                    loop: o,
                    onRest: l,
                    onResolve: u
                } = t, c = s.is.obj(t.default) && t.default;
                o && (t.loop = !1), !1 === i && (t.to = null), !1 === a && (t.from = null);
                let h = s.is.arr(i) || s.is.fun(i) ? i : void 0;
                h ? (t.to = void 0, t.onRest = void 0, c && (c.onRest = void 0)) : (0, s.S6)(en, n => {
                    let r = t[n];
                    if (s.is.fun(r)) {
                        let i = e._events[n];
                        t[n] = ({
                            finished: e,
                            cancelled: t
                        }) => {
                            let n = i.get(r);
                            n ? (e || (n.finished = !1), t && (n.cancelled = !0)) : i.set(r, {
                                value: null,
                                finished: e || !1,
                                cancelled: t || !1
                            })
                        }, c && (c[n] = t[n])
                    }
                });
                let d = e._state;
                !d.paused === t.pause ? (d.paused = t.pause, (0, s.bl)(t.pause ? d.pauseQueue : d.resumeQueue)) : d.paused && (t.pause = !0);
                let p = (r || Object.keys(e.springs)).map(n => e.springs[n].start(t)),
                    m = !0 === t.cancel || !0 === f(t, "cancel");
                (h || m && d.asyncId) && p.push(P(++e._lastAsyncId, {
                    props: t,
                    state: d,
                    actions: {
                        pause: s.ZT,
                        resume: s.ZT,
                        start(t, n) {
                            m ? (O(d, e._lastAsyncId), n(k(e))) : (t.onRest = l, n(U(h, t, d, e)))
                        }
                    }
                })), d.paused && await new Promise(e => {
                    d.resumeQueue.add(e)
                });
                let g = R(e, await Promise.all(p));
                if (o && g.finished && !(n && g.noop)) {
                    let v = $(t, o, i);
                    if (v) return eh(e, [v]), es(e, v, !0)
                }
                return u && s.Wn.batchedUpdates(() => u(g, e, e.item)), g
            }

            function eo(e, t) {
                let n = u({}, e.springs);
                return t && (0, s.S6)((0, s.qo)(t), e => {
                    s.is.und(e.keys) && (e = J(e)), s.is.obj(e.to) || (e = u({}, e, {
                        to: void 0
                    })), ec(n, e, e => eu(e))
                }), el(e, n), n
            }

            function el(e, t) {
                (0, s.rU)(t, (t, n) => {
                    e.springs[n] || (e.springs[n] = t, (0, s.UI)(t, e))
                })
            }

            function eu(e, t) {
                let n = new Z;
                return n.key = e, t && (0, s.UI)(n, t), n
            }

            function ec(e, t, n) {
                t.keys && (0, s.S6)(t.keys, r => {
                    let i = e[r] || (e[r] = n(r));
                    i._prepareNode(t)
                })
            }

            function eh(e, t) {
                (0, s.S6)(t, t => {
                    ec(e.springs, t, t => eu(t, e))
                })
            }
            let ed = ["children"],
                ef = e => {
                    let {
                        children: t
                    } = e, n = function(e, t) {
                        if (null == e) return {};
                        var n, r, i = {},
                            a = Object.keys(e);
                        for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                        return i
                    }(e, ed), r = (0, o.useContext)(ep), i = n.pause || !!r.pause, a = n.immediate || !!r.immediate;
                    n = (0, s.Pr)(() => ({
                        pause: i,
                        immediate: a
                    }), [i, a]);
                    let {
                        Provider: l
                    } = ep;
                    return o.createElement(l, {
                        value: n
                    }, t)
                },
                ep = (Object.assign(i = ef, o.createContext({})), i.Provider._context = i, i.Consumer._context = i, i);
            ef.Provider = ep.Provider, ef.Consumer = ep.Consumer;
            let em = () => {
                let e = [],
                    t = function(t) {
                        (0, s.ZR)();
                        let r = [];
                        return (0, s.S6)(e, (e, i) => {
                            if (s.is.und(t)) r.push(e.start());
                            else {
                                let a = n(t, e, i);
                                a && r.push(e.start(a))
                            }
                        }), r
                    };
                t.current = e, t.add = function(t) {
                    e.includes(t) || e.push(t)
                }, t.delete = function(t) {
                    let n = e.indexOf(t);
                    ~n && e.splice(n, 1)
                }, t.pause = function() {
                    return (0, s.S6)(e, e => e.pause(...arguments)), this
                }, t.resume = function() {
                    return (0, s.S6)(e, e => e.resume(...arguments)), this
                }, t.set = function(t) {
                    (0, s.S6)(e, e => e.set(t))
                }, t.start = function(t) {
                    let n = [];
                    return (0, s.S6)(e, (e, r) => {
                        if (s.is.und(t)) n.push(e.start());
                        else {
                            let i = this._getProps(t, e, r);
                            i && n.push(e.start(i))
                        }
                    }), n
                }, t.stop = function() {
                    return (0, s.S6)(e, e => e.stop(...arguments)), this
                }, t.update = function(t) {
                    return (0, s.S6)(e, (e, n) => e.update(this._getProps(t, e, n))), this
                };
                let n = function(e, t, n) {
                    return s.is.fun(e) ? e(n, t) : e
                };
                return t._getProps = n, t
            };

            function eg(e, t) {
                let n = s.is.fun(e),
                    [
                        [r], i
                    ] = function(e, t, n) {
                        let r = s.is.fun(t) && t;
                        r && !n && (n = []);
                        let i = (0, o.useMemo)(() => r || 3 == arguments.length ? em() : void 0, []),
                            a = (0, o.useRef)(0),
                            l = (0, s.NW)(),
                            c = (0, o.useMemo)(() => ({
                                ctrls: [],
                                queue: [],
                                flush(e, t) {
                                    let n = eo(e, t),
                                        r = a.current > 0 && !c.queue.length && !Object.keys(n).some(t => !e.springs[t]);
                                    return r ? ea(e, t) : new Promise(r => {
                                        el(e, n), c.queue.push(() => {
                                            r(ea(e, t))
                                        }), l()
                                    })
                                }
                            }), []),
                            h = (0, o.useRef)([...c.ctrls]),
                            d = [],
                            f = (0, s.zH)(e) || 0;

                        function p(e, n) {
                            for (let i = e; i < n; i++) {
                                let a = h.current[i] || (h.current[i] = new ei(null, c.flush)),
                                    o = r ? r(i, a) : t[i];
                                o && (d[i] = function(e) {
                                    let t = J(e);
                                    return s.is.und(t.default) && (t.default = m(t)), t
                                }(o))
                            }
                        }(0, o.useMemo)(() => {
                            (0, s.S6)(h.current.slice(e, f), e => {
                                w(e, i), e.stop(!0)
                            }), h.current.length = e, p(f, e)
                        }, [e]), (0, o.useMemo)(() => {
                            p(0, Math.min(f, e))
                        }, n);
                        let g = h.current.map((e, t) => eo(e, d[t])),
                            v = (0, o.useContext)(ef),
                            _ = (0, s.zH)(v),
                            y = v !== _ && x(v);
                        (0, s.LI)(() => {
                            a.current++, c.ctrls = h.current;
                            let {
                                queue: e
                            } = c;
                            e.length && (c.queue = [], (0, s.S6)(e, e => e())), (0, s.S6)(h.current, (e, t) => {
                                null == i || i.add(e), y && e.start({
                                    default: v
                                });
                                let n = d[t];
                                n && (S(e, n.ref), e.ref ? e.queue.push(n) : e.start(n))
                            })
                        }), (0, s.tf)(() => () => {
                            (0, s.S6)(c.ctrls, e => e.stop(!0))
                        });
                        let b = g.map(e => u({}, e));
                        return i ? [b, i] : b
                    }(1, n ? e : [e], n ? t || [] : t);
                return n || 2 == arguments.length ? [r, i] : r
            }

            function ev(e, t, n) {
                let i = s.is.fun(t) && t,
                    {
                        reset: a,
                        sort: l,
                        trail: h = 0,
                        expires: d = !0,
                        exitBeforeEnter: f = !1,
                        onDestroyed: p,
                        ref: g,
                        config: v
                    } = i ? i() : t,
                    y = (0, o.useMemo)(() => i || 3 == arguments.length ? em() : void 0, []),
                    b = (0, s.qo)(e),
                    M = [],
                    T = (0, o.useRef)(null),
                    A = a ? null : T.current;
                (0, s.LI)(() => {
                    T.current = M
                }), (0, s.tf)(() => ((0, s.S6)(M, e => {
                    null == y || y.add(e.ctrl), e.ctrl.ref = y
                }), () => {
                    (0, s.S6)(T.current, e => {
                        e.expired && clearTimeout(e.expirationId), w(e.ctrl, y), e.ctrl.stop(!0)
                    })
                }));
                let E = function(e, {
                        key: t,
                        keys: n = t
                    }, i) {
                        if (null === n) {
                            let a = new Set;
                            return e.map(e => {
                                let t = i && i.find(t => t.item === e && t.phase !== r.LEAVE && !a.has(t));
                                return t ? (a.add(t), t.key) : e_++
                            })
                        }
                        return s.is.und(n) ? e : s.is.fun(n) ? e.map(n) : (0, s.qo)(n)
                    }(b, i ? i() : t, A),
                    C = a && T.current || [];
                (0, s.LI)(() => (0, s.S6)(C, ({
                    ctrl: e,
                    item: t,
                    key: n
                }) => {
                    w(e, y), c(p, t, n)
                }));
                let I = [];
                if (A && (0, s.S6)(A, (e, t) => {
                        e.expired ? (clearTimeout(e.expirationId), C.push(e)) : ~(t = I[t] = E.indexOf(e.key)) && (M[t] = e)
                    }), (0, s.S6)(b, (e, t) => {
                        M[t] || (M[t] = {
                            key: E[t],
                            item: e,
                            phase: r.MOUNT,
                            ctrl: new ei
                        }, M[t].ctrl.item = e)
                    }), I.length) {
                    let P = -1,
                        {
                            leave: R
                        } = i ? i() : t;
                    (0, s.S6)(I, (e, t) => {
                        let n = A[t];
                        ~e ? (P = M.indexOf(n), M[P] = u({}, n, {
                            item: b[e]
                        })) : R && M.splice(++P, 0, n)
                    })
                }
                s.is.fun(l) && M.sort((e, t) => l(e.item, t.item));
                let L = -h,
                    D = (0, s.NW)(),
                    k = m(t),
                    U = new Map,
                    O = (0, o.useRef)(new Map),
                    F = (0, o.useRef)(!1);
                (0, s.S6)(M, (e, n) => {
                    let a, o;
                    let l = e.key,
                        p = e.phase,
                        m = i ? i() : t,
                        y = c(m.delay || 0, l);
                    if (p == r.MOUNT) a = m.enter, o = r.ENTER;
                    else {
                        let x = 0 > E.indexOf(l);
                        if (p != r.LEAVE) {
                            if (x) a = m.leave, o = r.LEAVE;
                            else {
                                if (!(a = m.update)) return;
                                o = r.UPDATE
                            }
                        } else {
                            if (x) return;
                            a = m.enter, o = r.ENTER
                        }
                    }
                    if (a = c(a, e.item, n), !(a = s.is.obj(a) ? _(a) : {
                            to: a
                        }).config) {
                        let b = v || k.config;
                        a.config = c(b, e.item, n, o)
                    }
                    L += h;
                    let w = u({}, k, {
                        delay: y + L,
                        ref: g,
                        immediate: m.immediate,
                        reset: !1
                    }, a);
                    if (o == r.ENTER && s.is.und(w.from)) {
                        let S = i ? i() : t,
                            M = s.is.und(S.initial) || A ? S.from : S.initial;
                        w.from = c(M, e.item, n)
                    }
                    let {
                        onResolve: C
                    } = w;
                    w.onResolve = e => {
                        c(C, e);
                        let t = T.current,
                            n = t.find(e => e.key === l);
                        if (n) {
                            if (e.cancelled && n.phase != r.UPDATE) return;
                            if (n.ctrl.idle) {
                                let i = t.every(e => e.ctrl.idle);
                                if (n.phase == r.LEAVE) {
                                    let a = c(d, n.item);
                                    if (!1 !== a) {
                                        let s = !0 === a ? 0 : a;
                                        if (n.expired = !0, !i && s > 0) {
                                            s <= 2147483647 && (n.expirationId = setTimeout(D, s));
                                            return
                                        }
                                    }
                                }
                                i && t.some(e => e.expired) && (O.current.delete(n), f && (F.current = !0), D())
                            }
                        }
                    };
                    let I = eo(e.ctrl, w);
                    o === r.LEAVE && f ? O.current.set(e, {
                        phase: o,
                        springs: I,
                        payload: w
                    }) : U.set(e, {
                        phase: o,
                        springs: I,
                        payload: w
                    })
                });
                let N = (0, o.useContext)(ef),
                    B = (0, s.zH)(N),
                    z = N !== B && x(N);
                (0, s.LI)(() => {
                    z && (0, s.S6)(M, e => {
                        e.ctrl.start({
                            default: N
                        })
                    })
                }, [N]), (0, s.S6)(U, (e, t) => {
                    if (O.current.size) {
                        let n = M.findIndex(e => e.key === t.key);
                        M.splice(n, 1)
                    }
                }), (0, s.LI)(() => {
                    (0, s.S6)(O.current.size ? O.current : U, ({
                        phase: e,
                        payload: t
                    }, n) => {
                        let {
                            ctrl: i
                        } = n;
                        n.phase = e, null == y || y.add(i), z && e == r.ENTER && i.start({
                            default: N
                        }), t && (S(i, t.ref), (i.ref || y) && !F.current ? i.update(t) : (i.start(t), F.current && (F.current = !1)))
                    })
                }, a ? void 0 : n);
                let G = e => o.createElement(o.Fragment, null, M.map((t, n) => {
                    let {
                        springs: r
                    } = U.get(t) || t.ctrl, i = e(u({}, r), t.item, t, n);
                    return i && i.type ? o.createElement(i.type, u({}, i.props, {
                        key: s.is.str(t.key) || s.is.num(t.key) ? t.key : t.ctrl.id,
                        ref: i.ref
                    })) : i
                }));
                return y ? [G, y] : G
            }(a = r || (r = {})).MOUNT = "mount", a.ENTER = "enter", a.UPDATE = "update", a.LEAVE = "leave";
            let e_ = 1;
            class ey extends G {
                constructor(e, t) {
                    super(), this.key = void 0, this.idle = !0, this.calc = void 0, this._active = new Set, this.source = e, this.calc = (0, s.mD)(...t);
                    let n = this._get(),
                        r = (0, l.sb)(n);
                    (0, l.f3)(this, r.create(n))
                }
                advance(e) {
                    let t = this._get(),
                        n = this.get();
                    (0, s.Xy)(t, n) || ((0, l.ys)(this).setValue(t), this._onChange(t, this.idle)), !this.idle && eb(this._active) && ew(this)
                }
                _get() {
                    let e = s.is.arr(this.source) ? this.source.map(s.je) : (0, s.qo)((0, s.je)(this.source));
                    return this.calc(...e)
                }
                _start() {
                    this.idle && !eb(this._active) && (this.idle = !1, (0, s.S6)((0, l.He)(this), e => {
                        e.done = !1
                    }), s.OH.skipAnimation ? (s.Wn.batchedUpdates(() => this.advance()), ew(this)) : s.fT.start(this))
                }
                _attach() {
                    let e = 1;
                    (0, s.S6)((0, s.qo)(this.source), t => {
                        (0, s.j$)(t) && (0, s.UI)(t, this), B(t) && (t.idle || this._active.add(t), e = Math.max(e, t.priority + 1))
                    }), this.priority = e, this._start()
                }
                _detach() {
                    (0, s.S6)((0, s.qo)(this.source), e => {
                        (0, s.j$)(e) && (0, s.iL)(e, this)
                    }), this._active.clear(), ew(this)
                }
                eventObserved(e) {
                    "change" == e.type ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : "idle" == e.type ? this._active.delete(e.parent) : "priority" == e.type && (this.priority = (0, s.qo)(this.source).reduce((e, t) => Math.max(e, (B(t) ? t.priority : 0) + 1), 0))
                }
            }

            function ex(e) {
                return !1 !== e.idle
            }

            function eb(e) {
                return !e.size || Array.from(e).every(ex)
            }

            function ew(e) {
                e.idle || (e.idle = !0, (0, s.S6)((0, l.He)(e), e => {
                    e.done = !0
                }), (0, s.k0)(e, {
                    type: "idle",
                    parent: e
                }))
            }
            let eS = (e, ...t) => new ey(e, t);
            s.OH.assign({
                createStringInterpolator: s.qS,
                to: (e, t) => new ey(e, t)
            }), s.fT.advance
        },
        1132: function(e, t, n) {
            "use strict";
            let r, i, a;
            n.d(t, {
                B0: function() {
                    return eC
                },
                OH: function() {
                    return B
                },
                UI: function() {
                    return eP
                },
                k0: function() {
                    return eE
                },
                O9: function() {
                    return $
                },
                mD: function() {
                    return em
                },
                qS: function() {
                    return eG
                },
                dE: function() {
                    return A
                },
                ZR: function() {
                    return eX
                },
                LW: function() {
                    return ej
                },
                S6: function() {
                    return I
                },
                rU: function() {
                    return P
                },
                Z5: function() {
                    return ex
                },
                yl: function() {
                    return L
                },
                bl: function() {
                    return D
                },
                fT: function() {
                    return H
                },
                Ll: function() {
                    return eA
                },
                je: function() {
                    return eT
                },
                j$: function() {
                    return eM
                },
                is: function() {
                    return E
                },
                Df: function() {
                    return eZ
                },
                Xy: function() {
                    return C
                },
                ZT: function() {
                    return T
                },
                Wn: function() {
                    return o
                },
                iL: function() {
                    return eR
                },
                qo: function() {
                    return R
                },
                NW: function() {
                    return eJ
                },
                LI: function() {
                    return eY
                },
                Pr: function() {
                    return eK
                },
                tf: function() {
                    return eQ
                },
                zH: function() {
                    return e1
                }
            });
            let s = w(),
                o = e => _(e, s),
                l = w();
            o.write = e => _(e, l);
            let u = w();
            o.onStart = e => _(e, u);
            let c = w();
            o.onFrame = e => _(e, c);
            let h = w();
            o.onFinish = e => _(e, h);
            let d = [];
            o.setTimeout = (e, t) => {
                let n = o.now() + t,
                    r = () => {
                        let e = d.findIndex(e => e.cancel == r);
                        ~e && d.splice(e, 1), g -= ~e ? 1 : 0
                    },
                    i = {
                        time: n,
                        handler: e,
                        cancel: r
                    };
                return d.splice(f(n), 0, i), g += 1, y(), i
            };
            let f = e => ~(~d.findIndex(t => t.time > e) || ~d.length);
            o.cancel = e => {
                u.delete(e), c.delete(e), h.delete(e), s.delete(e), l.delete(e)
            }, o.sync = e => {
                v = !0, o.batchedUpdates(e), v = !1
            }, o.throttle = e => {
                let t;

                function n() {
                    try {
                        e(...t)
                    } finally {
                        t = null
                    }
                }

                function r(...e) {
                    t = e, o.onStart(n)
                }
                return r.handler = e, r.cancel = () => {
                    u.delete(n), t = null
                }, r
            };
            let p = "undefined" != typeof window ? window.requestAnimationFrame : () => {};
            o.use = e => p = e, o.now = "undefined" != typeof performance ? () => performance.now() : Date.now, o.batchedUpdates = e => e(), o.catch = console.error, o.frameLoop = "always", o.advance = () => {
                "demand" !== o.frameLoop ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : b()
            };
            let m = -1,
                g = 0,
                v = !1;

            function _(e, t) {
                v ? (t.delete(e), e(0)) : (t.add(e), y())
            }

            function y() {
                m < 0 && (m = 0, "demand" !== o.frameLoop && p(x))
            }

            function x() {
                ~m && (p(x), o.batchedUpdates(b))
            }

            function b() {
                let e = m;
                m = o.now();
                let t = f(m);
                if (t && (S(d.splice(0, t), e => e.handler()), g -= t), !g) {
                    m = -1;
                    return
                }
                u.flush(), s.flush(e ? Math.min(64, m - e) : 16.667), c.flush(), l.flush(), h.flush()
            }

            function w() {
                let e = new Set,
                    t = e;
                return {
                    add(n) {
                        g += t != e || e.has(n) ? 0 : 1, e.add(n)
                    },
                    delete: n => (g -= t == e && e.has(n) ? 1 : 0, e.delete(n)),
                    flush(n) {
                        t.size && (e = new Set, g -= t.size, S(t, t => t(n) && e.add(t)), g += e.size, t = e)
                    }
                }
            }

            function S(e, t) {
                e.forEach(e => {
                    try {
                        t(e)
                    } catch (n) {
                        o.catch(n)
                    }
                })
            }
            var M = n(7294);

            function T() {}
            let A = (e, t, n) => Object.defineProperty(e, t, {
                    value: n,
                    writable: !0,
                    configurable: !0
                }),
                E = {
                    arr: Array.isArray,
                    obj: e => !!e && "Object" === e.constructor.name,
                    fun: e => "function" == typeof e,
                    str: e => "string" == typeof e,
                    num: e => "number" == typeof e,
                    und: e => void 0 === e
                };

            function C(e, t) {
                if (E.arr(e)) {
                    if (!E.arr(t) || e.length !== t.length) return !1;
                    for (let n = 0; n < e.length; n++)
                        if (e[n] !== t[n]) return !1;
                    return !0
                }
                return e === t
            }
            let I = (e, t) => e.forEach(t);

            function P(e, t, n) {
                if (E.arr(e)) {
                    for (let r = 0; r < e.length; r++) t.call(n, e[r], `${r}`);
                    return
                }
                for (let i in e) e.hasOwnProperty(i) && t.call(n, e[i], i)
            }
            let R = e => E.und(e) ? [] : E.arr(e) ? e : [e];

            function L(e, t) {
                if (e.size) {
                    let n = Array.from(e);
                    e.clear(), I(n, t)
                }
            }
            let D = (e, ...t) => L(e, e => e(...t)),
                k = () => "undefined" == typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
                U = null,
                O = !1,
                F = T,
                N = e => {
                    e.to && (i = e.to), e.now && (o.now = e.now), void 0 !== e.colors && (U = e.colors), null != e.skipAnimation && (O = e.skipAnimation), e.createStringInterpolator && (r = e.createStringInterpolator), e.requestAnimationFrame && o.use(e.requestAnimationFrame), e.batchedUpdates && (o.batchedUpdates = e.batchedUpdates), e.willAdvance && (F = e.willAdvance), e.frameLoop && (o.frameLoop = e.frameLoop)
                };
            var B = Object.freeze({
                __proto__: null,
                get createStringInterpolator() {
                    return r
                },
                get to() {
                    return i
                },
                get colors() {
                    return U
                },
                get skipAnimation() {
                    return O
                },
                get willAdvance() {
                    return F
                },
                assign: N
            });
            let z = new Set,
                G = [],
                V = [],
                W = 0,
                H = {
                    get idle() {
                        return !z.size && !G.length
                    },
                    start(e) {
                        W > e.priority ? (z.add(e), o.onStart(j)) : (q(e), o(Z))
                    },
                    advance: Z,
                    sort(e) {
                        if (W) o.onFrame(() => H.sort(e));
                        else {
                            let t = G.indexOf(e);
                            ~t && (G.splice(t, 1), X(e))
                        }
                    },
                    clear() {
                        G = [], z.clear()
                    }
                };

            function j() {
                z.forEach(q), z.clear(), o(Z)
            }

            function q(e) {
                G.includes(e) || X(e)
            }

            function X(e) {
                G.splice(function(e, t) {
                    let n = e.findIndex(t);
                    return n < 0 ? e.length : n
                }(G, t => t.priority > e.priority), 0, e)
            }

            function Z(e) {
                let t = V;
                for (let n = 0; n < G.length; n++) {
                    let r = G[n];
                    W = r.priority, r.idle || (F(r), r.advance(e), r.idle || t.push(r))
                }
                return W = 0, (V = G).length = 0, (G = t).length > 0
            }
            let Y = (e, t, n) => Math.min(Math.max(n, e), t),
                $ = {
                    transparent: 0,
                    aliceblue: 4042850303,
                    antiquewhite: 4209760255,
                    aqua: 16777215,
                    aquamarine: 2147472639,
                    azure: 4043309055,
                    beige: 4126530815,
                    bisque: 4293182719,
                    black: 255,
                    blanchedalmond: 4293643775,
                    blue: 65535,
                    blueviolet: 2318131967,
                    brown: 2771004159,
                    burlywood: 3736635391,
                    burntsienna: 3934150143,
                    cadetblue: 1604231423,
                    chartreuse: 2147418367,
                    chocolate: 3530104575,
                    coral: 4286533887,
                    cornflowerblue: 1687547391,
                    cornsilk: 4294499583,
                    crimson: 3692313855,
                    cyan: 16777215,
                    darkblue: 35839,
                    darkcyan: 9145343,
                    darkgoldenrod: 3095792639,
                    darkgray: 2846468607,
                    darkgreen: 6553855,
                    darkgrey: 2846468607,
                    darkkhaki: 3182914559,
                    darkmagenta: 2332068863,
                    darkolivegreen: 1433087999,
                    darkorange: 4287365375,
                    darkorchid: 2570243327,
                    darkred: 2332033279,
                    darksalmon: 3918953215,
                    darkseagreen: 2411499519,
                    darkslateblue: 1211993087,
                    darkslategray: 793726975,
                    darkslategrey: 793726975,
                    darkturquoise: 13554175,
                    darkviolet: 2483082239,
                    deeppink: 4279538687,
                    deepskyblue: 12582911,
                    dimgray: 1768516095,
                    dimgrey: 1768516095,
                    dodgerblue: 512819199,
                    firebrick: 2988581631,
                    floralwhite: 4294635775,
                    forestgreen: 579543807,
                    fuchsia: 4278255615,
                    gainsboro: 3705462015,
                    ghostwhite: 4177068031,
                    gold: 4292280575,
                    goldenrod: 3668254975,
                    gray: 2155905279,
                    green: 8388863,
                    greenyellow: 2919182335,
                    grey: 2155905279,
                    honeydew: 4043305215,
                    hotpink: 4285117695,
                    indianred: 3445382399,
                    indigo: 1258324735,
                    ivory: 4294963455,
                    khaki: 4041641215,
                    lavender: 3873897215,
                    lavenderblush: 4293981695,
                    lawngreen: 2096890111,
                    lemonchiffon: 4294626815,
                    lightblue: 2916673279,
                    lightcoral: 4034953471,
                    lightcyan: 3774873599,
                    lightgoldenrodyellow: 4210742015,
                    lightgray: 3553874943,
                    lightgreen: 2431553791,
                    lightgrey: 3553874943,
                    lightpink: 4290167295,
                    lightsalmon: 4288707327,
                    lightseagreen: 548580095,
                    lightskyblue: 2278488831,
                    lightslategray: 2005441023,
                    lightslategrey: 2005441023,
                    lightsteelblue: 2965692159,
                    lightyellow: 4294959359,
                    lime: 16711935,
                    limegreen: 852308735,
                    linen: 4210091775,
                    magenta: 4278255615,
                    maroon: 2147483903,
                    mediumaquamarine: 1724754687,
                    mediumblue: 52735,
                    mediumorchid: 3126187007,
                    mediumpurple: 2473647103,
                    mediumseagreen: 1018393087,
                    mediumslateblue: 2070474495,
                    mediumspringgreen: 16423679,
                    mediumturquoise: 1221709055,
                    mediumvioletred: 3340076543,
                    midnightblue: 421097727,
                    mintcream: 4127193855,
                    mistyrose: 4293190143,
                    moccasin: 4293178879,
                    navajowhite: 4292783615,
                    navy: 33023,
                    oldlace: 4260751103,
                    olive: 2155872511,
                    olivedrab: 1804477439,
                    orange: 4289003775,
                    orangered: 4282712319,
                    orchid: 3664828159,
                    palegoldenrod: 4008225535,
                    palegreen: 2566625535,
                    paleturquoise: 2951671551,
                    palevioletred: 3681588223,
                    papayawhip: 4293907967,
                    peachpuff: 4292524543,
                    peru: 3448061951,
                    pink: 4290825215,
                    plum: 3718307327,
                    powderblue: 2967529215,
                    purple: 2147516671,
                    rebeccapurple: 1714657791,
                    red: 4278190335,
                    rosybrown: 3163525119,
                    royalblue: 1097458175,
                    saddlebrown: 2336560127,
                    salmon: 4202722047,
                    sandybrown: 4104413439,
                    seagreen: 780883967,
                    seashell: 4294307583,
                    sienna: 2689740287,
                    silver: 3233857791,
                    skyblue: 2278484991,
                    slateblue: 1784335871,
                    slategray: 1887473919,
                    slategrey: 1887473919,
                    snow: 4294638335,
                    springgreen: 16744447,
                    steelblue: 1182971135,
                    tan: 3535047935,
                    teal: 8421631,
                    thistle: 3636451583,
                    tomato: 4284696575,
                    turquoise: 1088475391,
                    violet: 4001558271,
                    wheat: 4125012991,
                    white: 4294967295,
                    whitesmoke: 4126537215,
                    yellow: 4294902015,
                    yellowgreen: 2597139199
                },
                J = "[-+]?\\d*\\.?\\d+",
                K = J + "%";

            function Q(...e) {
                return "\\(\\s*(" + e.join(")\\s*,\\s*(") + ")\\s*\\)"
            }
            let ee = RegExp("rgb" + Q(J, J, J)),
                et = RegExp("rgba" + Q(J, J, J, J)),
                en = RegExp("hsl" + Q(J, K, K)),
                er = RegExp("hsla" + Q(J, K, K, J)),
                ei = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                ea = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                es = /^#([0-9a-fA-F]{6})$/,
                eo = /^#([0-9a-fA-F]{8})$/;

            function el(e, t, n) {
                return (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6) ? e + (t - e) * 6 * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
            }

            function eu(e, t, n) {
                let r = n < .5 ? n * (1 + t) : n + t - n * t,
                    i = 2 * n - r,
                    a = el(i, r, e + 1 / 3),
                    s = el(i, r, e),
                    o = el(i, r, e - 1 / 3);
                return Math.round(255 * a) << 24 | Math.round(255 * s) << 16 | Math.round(255 * o) << 8
            }

            function ec(e) {
                let t = parseInt(e, 10);
                return t < 0 ? 0 : t > 255 ? 255 : t
            }

            function eh(e) {
                let t = parseFloat(e);
                return (t % 360 + 360) % 360 / 360
            }

            function ed(e) {
                let t = parseFloat(e);
                return t < 0 ? 0 : t > 1 ? 255 : Math.round(255 * t)
            }

            function ef(e) {
                let t = parseFloat(e);
                return t < 0 ? 0 : t > 100 ? 1 : t / 100
            }

            function ep(e) {
                let t;
                let n = "number" == typeof e ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = es.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : U && void 0 !== U[e] ? U[e] : (t = ee.exec(e)) ? (ec(t[1]) << 24 | ec(t[2]) << 16 | ec(t[3]) << 8 | 255) >>> 0 : (t = et.exec(e)) ? (ec(t[1]) << 24 | ec(t[2]) << 16 | ec(t[3]) << 8 | ed(t[4])) >>> 0 : (t = ei.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + "ff", 16) >>> 0 : (t = eo.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = ea.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + t[4] + t[4], 16) >>> 0 : (t = en.exec(e)) ? (255 | eu(eh(t[1]), ef(t[2]), ef(t[3]))) >>> 0 : (t = er.exec(e)) ? (eu(eh(t[1]), ef(t[2]), ef(t[3])) | ed(t[4])) >>> 0 : null;
                return null === n ? e : `rgba(${(4278190080&(n=n||0))>>>24}, ${(16711680&n)>>>16}, ${(65280&n)>>>8}, ${(255&n)/255})`
            }
            let em = (e, t, n) => {
                    if (E.fun(e)) return e;
                    if (E.arr(e)) return em({
                        range: e,
                        output: t,
                        extrapolate: n
                    });
                    if (E.str(e.output[0])) return r(e);
                    let i = e.output,
                        a = e.range || [0, 1],
                        s = e.extrapolateLeft || e.extrapolate || "extend",
                        o = e.extrapolateRight || e.extrapolate || "extend",
                        l = e.easing || (e => e);
                    return t => {
                        let n = function(e, t) {
                            for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n);
                            return n - 1
                        }(t, a);
                        return function(e, t, n, r, i, a, s, o, l) {
                            let u = l ? l(e) : e;
                            if (u < t) {
                                if ("identity" === s) return u;
                                "clamp" === s && (u = t)
                            }
                            if (u > n) {
                                if ("identity" === o) return u;
                                "clamp" === o && (u = n)
                            }
                            return r === i ? r : t === n ? e <= t ? r : i : (t === -1 / 0 ? u = -u : n === 1 / 0 ? u -= t : u = (u - t) / (n - t), u = a(u), r === -1 / 0 ? u = -u : i === 1 / 0 ? u += r : u = u * (i - r) + r, u)
                        }(t, a[n], a[n + 1], i[n], i[n + 1], l, s, o, e.map)
                    }
                },
                eg = (e, t = "end") => n => {
                    n = "end" === t ? Math.min(n, .999) : Math.max(n, .001);
                    let r = n * e;
                    return Y(0, 1, ("end" === t ? Math.floor(r) : Math.ceil(r)) / e)
                },
                ev = 2 * Math.PI / 3,
                e_ = 2 * Math.PI / 4.5,
                ey = e => e < .36363636363636365 ? 7.5625 * e * e : e < .7272727272727273 ? 7.5625 * (e -= .5454545454545454) * e + .75 : e < .9090909090909091 ? 7.5625 * (e -= .8181818181818182) * e + .9375 : 7.5625 * (e -= .9545454545454546) * e + .984375,
                ex = {
                    linear: e => e,
                    easeInQuad: e => e * e,
                    easeOutQuad: e => 1 - (1 - e) * (1 - e),
                    easeInOutQuad: e => e < .5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2,
                    easeInCubic: e => e * e * e,
                    easeOutCubic: e => 1 - Math.pow(1 - e, 3),
                    easeInOutCubic: e => e < .5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2,
                    easeInQuart: e => e * e * e * e,
                    easeOutQuart: e => 1 - Math.pow(1 - e, 4),
                    easeInOutQuart: e => e < .5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2,
                    easeInQuint: e => e * e * e * e * e,
                    easeOutQuint: e => 1 - Math.pow(1 - e, 5),
                    easeInOutQuint: e => e < .5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2,
                    easeInSine: e => 1 - Math.cos(e * Math.PI / 2),
                    easeOutSine: e => Math.sin(e * Math.PI / 2),
                    easeInOutSine: e => -(Math.cos(Math.PI * e) - 1) / 2,
                    easeInExpo: e => 0 === e ? 0 : Math.pow(2, 10 * e - 10),
                    easeOutExpo: e => 1 === e ? 1 : 1 - Math.pow(2, -10 * e),
                    easeInOutExpo: e => 0 === e ? 0 : 1 === e ? 1 : e < .5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2,
                    easeInCirc: e => 1 - Math.sqrt(1 - Math.pow(e, 2)),
                    easeOutCirc: e => Math.sqrt(1 - Math.pow(e - 1, 2)),
                    easeInOutCirc: e => e < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2,
                    easeInBack: e => 2.70158 * e * e * e - 1.70158 * e * e,
                    easeOutBack: e => 1 + 2.70158 * Math.pow(e - 1, 3) + 1.70158 * Math.pow(e - 1, 2),
                    easeInOutBack: e => e < .5 ? Math.pow(2 * e, 2) * (7.189819 * e - 2.5949095) / 2 : (Math.pow(2 * e - 2, 2) * (3.5949095 * (2 * e - 2) + 2.5949095) + 2) / 2,
                    easeInElastic: e => 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((10 * e - 10.75) * ev),
                    easeOutElastic: e => 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin((10 * e - .75) * ev) + 1,
                    easeInOutElastic: e => 0 === e ? 0 : 1 === e ? 1 : e < .5 ? -(Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * e_)) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * e_) / 2 + 1,
                    easeInBounce: e => 1 - ey(1 - e),
                    easeOutBounce: ey,
                    easeInOutBounce: e => e < .5 ? (1 - ey(1 - 2 * e)) / 2 : (1 + ey(2 * e - 1)) / 2,
                    steps: eg
                };

            function eb() {
                return (eb = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }).apply(this, arguments)
            }
            let ew = Symbol.for("FluidValue.get"),
                eS = Symbol.for("FluidValue.observers"),
                eM = e => Boolean(e && e[ew]),
                eT = e => e && e[ew] ? e[ew]() : e,
                eA = e => e[eS] || null;

            function eE(e, t) {
                let n = e[eS];
                n && n.forEach(e => {
                    e.eventObserved ? e.eventObserved(t) : e(t)
                })
            }
            class eC {
                constructor(e) {
                    if (this[ew] = void 0, this[eS] = void 0, !e && !(e = this.get)) throw Error("Unknown getter");
                    eI(this, e)
                }
            }
            let eI = (e, t) => eL(e, ew, t);

            function eP(e, t) {
                if (e[ew]) {
                    let n = e[eS];
                    n || eL(e, eS, n = new Set), !n.has(t) && (n.add(t), e.observerAdded && e.observerAdded(n.size, t))
                }
                return t
            }

            function eR(e, t) {
                let n = e[eS];
                if (n && n.has(t)) {
                    let r = n.size - 1;
                    r ? n.delete(t) : e[eS] = null, e.observerRemoved && e.observerRemoved(r, t)
                }
            }
            let eL = (e, t, n) => Object.defineProperty(e, t, {
                    value: n,
                    writable: !0,
                    configurable: !0
                }),
                eD = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                ek = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,
                eU = RegExp(`(${eD.source})(%|[a-z]+)`, "i"),
                eO = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,
                eF = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
                eN = e => {
                    let [t, n] = eB(e);
                    if (!t || k()) return e;
                    let r = window.getComputedStyle(document.documentElement).getPropertyValue(t);
                    if (r) return r.trim();
                    if (n && n.startsWith("--")) {
                        let i = window.getComputedStyle(document.documentElement).getPropertyValue(n);
                        if (i) return i
                    } else if (n && eF.test(n)) return eN(n);
                    else if (n) return n;
                    return e
                },
                eB = e => {
                    let t = eF.exec(e);
                    if (!t) return [, ];
                    let [, n, r] = t;
                    return [n, r]
                },
                ez = (e, t, n, r, i) => `rgba(${Math.round(t)}, ${Math.round(n)}, ${Math.round(r)}, ${i})`,
                eG = e => {
                    a || (a = U ? RegExp(`(${Object.keys(U).join("|")})(?!\\w)`, "g") : /^\b$/);
                    let t = e.output.map(e => eT(e).replace(eF, eN).replace(ek, ep).replace(a, ep)),
                        n = t.map(e => e.match(eD).map(Number)),
                        r = n[0].map((e, t) => n.map(e => {
                            if (!(t in e)) throw Error('The arity of each "output" value must be equal');
                            return e[t]
                        })),
                        i = r.map(t => em(eb({}, e, {
                            output: t
                        })));
                    return e => {
                        var n;
                        let r = !eU.test(t[0]) && (null == (n = t.find(e => eU.test(e))) ? void 0 : n.replace(eD, "")),
                            a = 0;
                        return t[0].replace(eD, () => `${i[a++](e)}${r||""}`).replace(eO, ez)
                    }
                },
                eV = "react-spring: ",
                eW = e => {
                    let t = !1;
                    if ("function" != typeof e) throw TypeError(`${eV}once requires a function parameter`);
                    return (...n) => {
                        t || (e(...n), t = !0)
                    }
                },
                eH = eW(console.warn);

            function ej() {
                eH(`${eV}The "interpolate" function is deprecated in v9 (use "to" instead)`)
            }
            let eq = eW(console.warn);

            function eX() {
                eq(`${eV}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)
            }

            function eZ(e) {
                return E.str(e) && ("#" == e[0] || /\d/.test(e) || !k() && eF.test(e) || e in (U || {}))
            }
            new WeakMap, new WeakMap, new WeakMap, new WeakMap;
            let eY = k() ? M.useEffect : M.useLayoutEffect,
                e$ = () => {
                    let e = (0, M.useRef)(!1);
                    return eY(() => (e.current = !0, () => {
                        e.current = !1
                    }), []), e
                };

            function eJ() {
                let e = (0, M.useState)()[1],
                    t = e$();
                return () => {
                    t.current && e(Math.random())
                }
            }

            function eK(e, t) {
                let [n] = (0, M.useState)(() => ({
                    inputs: t,
                    result: e()
                })), r = (0, M.useRef)(), i = r.current, a = i;
                if (a) {
                    let s = Boolean(t && a.inputs && function(e, t) {
                        if (e.length !== t.length) return !1;
                        for (let n = 0; n < e.length; n++)
                            if (e[n] !== t[n]) return !1;
                        return !0
                    }(t, a.inputs));
                    s || (a = {
                        inputs: t,
                        result: e()
                    })
                } else a = n;
                return (0, M.useEffect)(() => {
                    r.current = a, i == n && (n.inputs = n.result = void 0)
                }, [a]), a.result
            }
            let eQ = e => (0, M.useEffect)(e, e0),
                e0 = [];

            function e1(e) {
                let t = (0, M.useRef)();
                return (0, M.useEffect)(() => {
                    t.current = e
                }), t.current
            }
        },
        1472: function(e, t, n) {
            "use strict";
            n.d(t, {
                a: function() {
                    return M
                },
                animated: function() {
                    return M
                },
                config: function() {
                    return r.config
                },
                to: function() {
                    return r.to
                },
                useSpring: function() {
                    return r.useSpring
                },
                useTransition: function() {
                    return r.useTransition
                }
            });
            var r = n(4928),
                i = n(3935),
                a = n(1132),
                s = n(1314);

            function o(e, t) {
                if (null == e) return {};
                var n, r, i = {},
                    a = Object.keys(e);
                for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                return i
            }
            let l = ["style", "children", "scrollTop", "scrollLeft", "viewBox"],
                u = /^--/,
                c = {},
                h = {
                    animationIterationCount: !0,
                    borderImageOutset: !0,
                    borderImageSlice: !0,
                    borderImageWidth: !0,
                    boxFlex: !0,
                    boxFlexGroup: !0,
                    boxOrdinalGroup: !0,
                    columnCount: !0,
                    columns: !0,
                    flex: !0,
                    flexGrow: !0,
                    flexPositive: !0,
                    flexShrink: !0,
                    flexNegative: !0,
                    flexOrder: !0,
                    gridRow: !0,
                    gridRowEnd: !0,
                    gridRowSpan: !0,
                    gridRowStart: !0,
                    gridColumn: !0,
                    gridColumnEnd: !0,
                    gridColumnSpan: !0,
                    gridColumnStart: !0,
                    fontWeight: !0,
                    lineClamp: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    tabSize: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0,
                    fillOpacity: !0,
                    floodOpacity: !0,
                    stopOpacity: !0,
                    strokeDasharray: !0,
                    strokeDashoffset: !0,
                    strokeMiterlimit: !0,
                    strokeOpacity: !0,
                    strokeWidth: !0
                },
                d = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1),
                f = ["Webkit", "Ms", "Moz", "O"];
            h = Object.keys(h).reduce((e, t) => (f.forEach(n => e[d(n, t)] = e[t]), e), h);
            let p = ["x", "y", "z"],
                m = /^(matrix|translate|scale|rotate|skew)/,
                g = /^(translate)/,
                v = /^(rotate|skew)/,
                _ = (e, t) => a.is.num(e) && 0 !== e ? e + t : e,
                y = (e, t) => a.is.arr(e) ? e.every(e => y(e, t)) : a.is.num(e) ? e === t : parseFloat(e) === t;
            class x extends s.rS {
                constructor(e) {
                    let {
                        x: t,
                        y: n,
                        z: r
                    } = e, i = o(e, p), s = [], l = [];
                    (t || n || r) && (s.push([t || 0, n || 0, r || 0]), l.push(e => [`translate3d(${e.map(e=>_(e,"px")).join(",")})`, y(e, 0)])), (0, a.rU)(i, (e, t) => {
                        if ("transform" === t) s.push([e || ""]), l.push(e => [e, "" === e]);
                        else if (m.test(t)) {
                            if (delete i[t], a.is.und(e)) return;
                            let n = g.test(t) ? "px" : v.test(t) ? "deg" : "";
                            s.push((0, a.qo)(e)), l.push("rotate3d" === t ? ([e, t, r, i]) => [`rotate3d(${e},${t},${r},${_(i,n)})`, y(i, 0)] : e => [`${t}(${e.map(e=>_(e,n)).join(",")})`, y(e, t.startsWith("scale") ? 1 : 0)])
                        }
                    }), s.length && (i.transform = new b(s, l)), super(i)
                }
            }
            class b extends a.B0 {
                constructor(e, t) {
                    super(), this._value = null, this.inputs = e, this.transforms = t
                }
                get() {
                    return this._value || (this._value = this._get())
                }
                _get() {
                    let e = "",
                        t = !0;
                    return (0, a.S6)(this.inputs, (n, r) => {
                        let i = (0, a.je)(n[0]),
                            [s, o] = this.transforms[r](a.is.arr(i) ? i : n.map(a.je));
                        e += " " + s, t = t && o
                    }), t ? "none" : e
                }
                observerAdded(e) {
                    1 == e && (0, a.S6)(this.inputs, e => (0, a.S6)(e, e => (0, a.j$)(e) && (0, a.UI)(e, this)))
                }
                observerRemoved(e) {
                    0 == e && (0, a.S6)(this.inputs, e => (0, a.S6)(e, e => (0, a.j$)(e) && (0, a.iL)(e, this)))
                }
                eventObserved(e) {
                    "change" == e.type && (this._value = null), (0, a.k0)(this, e)
                }
            }
            let w = ["scrollTop", "scrollLeft"];
            r.Globals.assign({
                batchedUpdates: i.unstable_batchedUpdates,
                createStringInterpolator: a.qS,
                colors: a.O9
            });
            let S = (0, s.Ld)(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"], {
                    applyAnimatedValues: function(e, t) {
                        if (!e.nodeType || !e.setAttribute) return !1;
                        let n = "filter" === e.nodeName || e.parentNode && "filter" === e.parentNode.nodeName,
                            {
                                style: r,
                                children: i,
                                scrollTop: a,
                                scrollLeft: s,
                                viewBox: d
                            } = t,
                            f = o(t, l),
                            p = Object.values(f),
                            m = Object.keys(f).map(t => n || e.hasAttribute(t) ? t : c[t] || (c[t] = t.replace(/([A-Z])/g, e => "-" + e.toLowerCase())));
                        for (let g in void 0 !== i && (e.textContent = i), r)
                            if (r.hasOwnProperty(g)) {
                                var v, _;
                                let y = (v = g, null == (_ = r[g]) || "boolean" == typeof _ || "" === _ ? "" : "number" != typeof _ || 0 === _ || u.test(v) || h.hasOwnProperty(v) && h[v] ? ("" + _).trim() : _ + "px");
                                u.test(g) ? e.style.setProperty(g, y) : e.style[g] = y
                            }
                        m.forEach((t, n) => {
                            e.setAttribute(t, p[n])
                        }), void 0 !== a && (e.scrollTop = a), void 0 !== s && (e.scrollLeft = s), void 0 !== d && e.setAttribute("viewBox", d)
                    },
                    createAnimatedStyle: e => new x(e),
                    getComponentProps: e => o(e, w)
                }),
                M = S.animated
        },
        9521: function(e, t, n) {
            "use strict";
            n.d(t, {
                S: function() {
                    return s
                }
            });
            var r = n(9477),
                i = n(4671);
            let a = 0,
                s = (0, i.Z)(e => (r.DefaultLoadingManager.onStart = (t, n, r) => {
                    e({
                        active: !0,
                        item: t,
                        loaded: n,
                        total: r,
                        progress: (n - a) / (r - a) * 100
                    })
                }, r.DefaultLoadingManager.onLoad = () => {
                    e({
                        active: !1
                    })
                }, r.DefaultLoadingManager.onError = t => e(e => ({
                    errors: [...e.errors, t]
                })), r.DefaultLoadingManager.onProgress = (t, n, r) => {
                    n === r && (a = r), e({
                        active: !0,
                        item: t,
                        loaded: n,
                        total: r,
                        progress: (n - a) / (r - a) * 100 || 100
                    })
                }, {
                    errors: [],
                    active: !1,
                    progress: 0,
                    item: "",
                    loaded: 0,
                    total: 0
                }))
        },
        7430: function(e, t, n) {
            "use strict";
            n.d(t, {
                Kn: function() {
                    return u
                },
                Vl: function() {
                    return s
                },
                bm: function() {
                    return o
                },
                zX: function() {
                    return l
                }
            });
            var r = n(7294),
                i = {
                    exports: {}
                };
            ! function(e) {
                var t = Object.prototype.hasOwnProperty,
                    n = "~";

                function r() {}

                function i(e, t, n) {
                    this.fn = e, this.context = t, this.once = n || !1
                }

                function a(e, t, r, a, s) {
                    if ("function" != typeof r) throw TypeError("The listener must be a function");
                    var o = new i(r, a || e, s),
                        l = n ? n + t : t;
                    return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e
                }

                function s(e, t) {
                    0 == --e._eventsCount ? e._events = new r : delete e._events[t]
                }

                function o() {
                    this._events = new r, this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), o.prototype.eventNames = function() {
                    var e, r, i = [];
                    if (0 === this._eventsCount) return i;
                    for (r in e = this._events) t.call(e, r) && i.push(n ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
                }, o.prototype.listeners = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var i = 0, a = r.length, s = Array(a); i < a; i++) s[i] = r[i].fn;
                    return s
                }, o.prototype.listenerCount = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    return r ? r.fn ? 1 : r.length : 0
                }, o.prototype.emit = function(e, t, r, i, a, s) {
                    var o = n ? n + e : e;
                    if (!this._events[o]) return !1;
                    var l, u, c = this._events[o],
                        h = arguments.length;
                    if (c.fn) {
                        switch (c.once && this.removeListener(e, c.fn, void 0, !0), h) {
                            case 1:
                                return c.fn.call(c.context), !0;
                            case 2:
                                return c.fn.call(c.context, t), !0;
                            case 3:
                                return c.fn.call(c.context, t, r), !0;
                            case 4:
                                return c.fn.call(c.context, t, r, i), !0;
                            case 5:
                                return c.fn.call(c.context, t, r, i, a), !0;
                            case 6:
                                return c.fn.call(c.context, t, r, i, a, s), !0
                        }
                        for (u = 1, l = Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
                        c.fn.apply(c.context, l)
                    } else {
                        var d, f = c.length;
                        for (u = 0; u < f; u++) switch (c[u].once && this.removeListener(e, c[u].fn, void 0, !0), h) {
                            case 1:
                                c[u].fn.call(c[u].context);
                                break;
                            case 2:
                                c[u].fn.call(c[u].context, t);
                                break;
                            case 3:
                                c[u].fn.call(c[u].context, t, r);
                                break;
                            case 4:
                                c[u].fn.call(c[u].context, t, r, i);
                                break;
                            default:
                                if (!l)
                                    for (d = 1, l = Array(h - 1); d < h; d++) l[d - 1] = arguments[d];
                                c[u].fn.apply(c[u].context, l)
                        }
                    }
                    return !0
                }, o.prototype.on = function(e, t, n) {
                    return a(this, e, t, n, !1)
                }, o.prototype.once = function(e, t, n) {
                    return a(this, e, t, n, !0)
                }, o.prototype.removeListener = function(e, t, r, i) {
                    var a = n ? n + e : e;
                    if (!this._events[a]) return this;
                    if (!t) return s(this, a), this;
                    var o = this._events[a];
                    if (o.fn) o.fn !== t || i && !o.once || r && o.context !== r || s(this, a);
                    else {
                        for (var l = 0, u = [], c = o.length; l < c; l++)(o[l].fn !== t || i && !o[l].once || r && o[l].context !== r) && u.push(o[l]);
                        u.length ? this._events[a] = 1 === u.length ? u[0] : u : s(this, a)
                    }
                    return this
                }, o.prototype.removeAllListeners = function(e) {
                    var t;
                    return e ? (t = n ? n + e : e, this._events[t] && s(this, t)) : (this._events = new r, this._eventsCount = 0), this
                }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, e.exports = o
            }(i);
            let a = new i.exports,
                s = (e, t, n = {}) => {
                    let {
                        once: r
                    } = n;
                    return r ? a.once(e, t) : a.on(e, t)
                },
                o = (e, t, n = {}) => {
                    let {
                        once: r,
                        context: i
                    } = n;
                    a.removeListener(e, t, i || null, !!r)
                },
                l = (e, t, n = {}) => {
                    let i = (0, r.useRef)(null),
                        {
                            once: s
                        } = n;
                    (0, r.useEffect)(() => {
                        i.current = t
                    }, [t]), (0, r.useEffect)(() => {
                        let t = null,
                            n = e => i.current(e);
                        return t = s ? a.once(e, n) : a.on(e, n), () => {
                            a.removeListener(e, n, t, !!s)
                        }
                    }, [e, s])
                },
                u = (e, t) => {
                    a.emit(e, t)
                }
        },
        8679: function(e, t, n) {
            "use strict";
            var r = n(9864),
                i = {
                    childContextTypes: !0,
                    contextType: !0,
                    contextTypes: !0,
                    defaultProps: !0,
                    displayName: !0,
                    getDefaultProps: !0,
                    getDerivedStateFromError: !0,
                    getDerivedStateFromProps: !0,
                    mixins: !0,
                    propTypes: !0,
                    type: !0
                },
                a = {
                    name: !0,
                    length: !0,
                    prototype: !0,
                    caller: !0,
                    callee: !0,
                    arguments: !0,
                    arity: !0
                },
                s = {
                    $$typeof: !0,
                    compare: !0,
                    defaultProps: !0,
                    displayName: !0,
                    propTypes: !0,
                    type: !0
                },
                o = {};

            function l(e) {
                return r.isMemo(e) ? s : o[e.$$typeof] || i
            }
            o[r.ForwardRef] = {
                $$typeof: !0,
                render: !0,
                defaultProps: !0,
                displayName: !0,
                propTypes: !0
            }, o[r.Memo] = s;
            var u = Object.defineProperty,
                c = Object.getOwnPropertyNames,
                h = Object.getOwnPropertySymbols,
                d = Object.getOwnPropertyDescriptor,
                f = Object.getPrototypeOf,
                p = Object.prototype;
            e.exports = function e(t, n, r) {
                if ("string" != typeof n) {
                    if (p) {
                        var i = f(n);
                        i && i !== p && e(t, i, r)
                    }
                    var s = c(n);
                    h && (s = s.concat(h(n)));
                    for (var o = l(t), m = l(n), g = 0; g < s.length; ++g) {
                        var v = s[g];
                        if (!a[v] && !(r && r[v]) && !(m && m[v]) && !(o && o[v])) {
                            var _ = d(n, v);
                            try {
                                u(t, v, _)
                            } catch (y) {}
                        }
                    }
                }
                return t
            }
        },
        1766: function(e, t, n) {
            var r, i, a, s, o, l, u, c, h, d, f, p, m, g, v;
            (i = function() {
                this.init()
            }).prototype = {
                init: function() {
                    var e = this || a;
                    return e._counter = 1e3, e._html5AudioPool = [], e.html5PoolSize = 10, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.autoUnlock = !0, e._setup(), e
                },
                volume: function(e) {
                    var t = this || a;
                    if (e = parseFloat(e), t.ctx || f(), void 0 !== e && e >= 0 && e <= 1) {
                        if (t._volume = e, t._muted) return t;
                        t.usingWebAudio && t.masterGain.gain.setValueAtTime(e, a.ctx.currentTime);
                        for (var n = 0; n < t._howls.length; n++)
                            if (!t._howls[n]._webAudio)
                                for (var r = t._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                    var s = t._howls[n]._soundById(r[i]);
                                    s && s._node && (s._node.volume = s._volume * e)
                                }
                        return t
                    }
                    return t._volume
                },
                mute: function(e) {
                    var t = this || a;
                    t.ctx || f(), t._muted = e, t.usingWebAudio && t.masterGain.gain.setValueAtTime(e ? 0 : t._volume, a.ctx.currentTime);
                    for (var n = 0; n < t._howls.length; n++)
                        if (!t._howls[n]._webAudio)
                            for (var r = t._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                var s = t._howls[n]._soundById(r[i]);
                                s && s._node && (s._node.muted = !!e || s._muted)
                            }
                    return t
                },
                stop: function() {
                    for (var e = this || a, t = 0; t < e._howls.length; t++) e._howls[t].stop();
                    return e
                },
                unload: function() {
                    for (var e = this || a, t = e._howls.length - 1; t >= 0; t--) e._howls[t].unload();
                    return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, f()), e
                },
                codecs: function(e) {
                    return (this || a)._codecs[e.replace(/^x-/, "")]
                },
                _setup: function() {
                    var e = this || a;
                    if (e.state = e.ctx && e.ctx.state || "suspended", e._autoSuspend(), !e.usingWebAudio) {
                        if ("undefined" != typeof Audio) try {
                            var t = new Audio;
                            void 0 === t.oncanplaythrough && (e._canPlayEvent = "canplay")
                        } catch (n) {
                            e.noAudio = !0
                        } else e.noAudio = !0
                    }
                    try {
                        var t = new Audio;
                        t.muted && (e.noAudio = !0)
                    } catch (r) {}
                    return e.noAudio || e._setupCodecs(), e
                },
                _setupCodecs: function() {
                    var e = this || a,
                        t = null;
                    try {
                        t = "undefined" != typeof Audio ? new Audio : null
                    } catch (n) {
                        return e
                    }
                    if (!t || "function" != typeof t.canPlayType) return e;
                    var r = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                        i = e._navigator ? e._navigator.userAgent : "",
                        s = i.match(/OPR\/([0-6].)/g),
                        o = s && 33 > parseInt(s[0].split("/")[1], 10),
                        l = -1 !== i.indexOf("Safari") && -1 === i.indexOf("Chrome"),
                        u = i.match(/Version\/(.*?) /),
                        c = l && u && 15 > parseInt(u[1], 10);
                    return e._codecs = {
                        mp3: !!(!o && (r || t.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                        mpeg: !!r,
                        opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                        ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        wav: !!(t.canPlayType('audio/wav; codecs="1"') || t.canPlayType("audio/wav")).replace(/^no$/, ""),
                        aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                        caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                        m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        m4b: !!(t.canPlayType("audio/x-m4b;") || t.canPlayType("audio/m4b;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        weba: !!(!c && t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        webm: !!(!c && t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                        flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "")
                    }, e
                },
                _unlockAudio: function() {
                    var e = this || a;
                    if (!e._audioUnlocked && e.ctx) {
                        e._audioUnlocked = !1, e.autoUnlock = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);
                        var t = function(n) {
                            for (; e._html5AudioPool.length < e.html5PoolSize;) try {
                                var r = new Audio;
                                r._unlocked = !0, e._releaseHtml5Audio(r)
                            } catch (i) {
                                e.noAudio = !0;
                                break
                            }
                            for (var a = 0; a < e._howls.length; a++)
                                if (!e._howls[a]._webAudio)
                                    for (var s = e._howls[a]._getSoundIds(), o = 0; o < s.length; o++) {
                                        var l = e._howls[a]._soundById(s[o]);
                                        l && l._node && !l._node._unlocked && (l._node._unlocked = !0, l._node.load())
                                    }
                            e._autoResume();
                            var u = e.ctx.createBufferSource();
                            u.buffer = e._scratchBuffer, u.connect(e.ctx.destination), void 0 === u.start ? u.noteOn(0) : u.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), u.onended = function() {
                                u.disconnect(0), e._audioUnlocked = !0, document.removeEventListener("touchstart", t, !0), document.removeEventListener("touchend", t, !0), document.removeEventListener("click", t, !0), document.removeEventListener("keydown", t, !0);
                                for (var n = 0; n < e._howls.length; n++) e._howls[n]._emit("unlock")
                            }
                        };
                        return document.addEventListener("touchstart", t, !0), document.addEventListener("touchend", t, !0), document.addEventListener("click", t, !0), document.addEventListener("keydown", t, !0), e
                    }
                },
                _obtainHtml5Audio: function() {
                    var e = this || a;
                    if (e._html5AudioPool.length) return e._html5AudioPool.pop();
                    var t = new Audio().play();
                    return t && "undefined" != typeof Promise && (t instanceof Promise || "function" == typeof t.then) && t.catch(function() {
                        console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                    }), new Audio
                },
                _releaseHtml5Audio: function(e) {
                    var t = this || a;
                    return e._unlocked && t._html5AudioPool.push(e), t
                },
                _autoSuspend: function() {
                    var e = this;
                    if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && a.usingWebAudio) {
                        for (var t = 0; t < e._howls.length; t++)
                            if (e._howls[t]._webAudio) {
                                for (var n = 0; n < e._howls[t]._sounds.length; n++)
                                    if (!e._howls[t]._sounds[n]._paused) return e
                            }
                        return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function() {
                            if (e.autoSuspend) {
                                e._suspendTimer = null, e.state = "suspending";
                                var t = function() {
                                    e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume())
                                };
                                e.ctx.suspend().then(t, t)
                            }
                        }, 3e4), e
                    }
                },
                _autoResume: function() {
                    var e = this;
                    if (e.ctx && void 0 !== e.ctx.resume && a.usingWebAudio) return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then(function() {
                        e.state = "running";
                        for (var t = 0; t < e._howls.length; t++) e._howls[t]._emit("resume")
                    }), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e
                }
            }, a = new i, (s = function(e) {
                if (!e.src || 0 === e.src.length) {
                    console.error("An array of source files must be passed with any new Howl.");
                    return
                }
                this.init(e)
            }).prototype = {
                init: function(e) {
                    var t = this;
                    return a.ctx || f(), t._autoplay = e.autoplay || !1, t._format = "string" != typeof e.format ? e.format : [e.format], t._html5 = e.html5 || !1, t._muted = e.mute || !1, t._loop = e.loop || !1, t._pool = e.pool || 5, t._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload, t._rate = e.rate || 1, t._sprite = e.sprite || {}, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._xhr = {
                        method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                        headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                        withCredentials: !!e.xhr && !!e.xhr.withCredentials && e.xhr.withCredentials
                    }, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._playLock = !1, t._onend = e.onend ? [{
                        fn: e.onend
                    }] : [], t._onfade = e.onfade ? [{
                        fn: e.onfade
                    }] : [], t._onload = e.onload ? [{
                        fn: e.onload
                    }] : [], t._onloaderror = e.onloaderror ? [{
                        fn: e.onloaderror
                    }] : [], t._onplayerror = e.onplayerror ? [{
                        fn: e.onplayerror
                    }] : [], t._onpause = e.onpause ? [{
                        fn: e.onpause
                    }] : [], t._onplay = e.onplay ? [{
                        fn: e.onplay
                    }] : [], t._onstop = e.onstop ? [{
                        fn: e.onstop
                    }] : [], t._onmute = e.onmute ? [{
                        fn: e.onmute
                    }] : [], t._onvolume = e.onvolume ? [{
                        fn: e.onvolume
                    }] : [], t._onrate = e.onrate ? [{
                        fn: e.onrate
                    }] : [], t._onseek = e.onseek ? [{
                        fn: e.onseek
                    }] : [], t._onunlock = e.onunlock ? [{
                        fn: e.onunlock
                    }] : [], t._onresume = [], t._webAudio = a.usingWebAudio && !t._html5, void 0 !== a.ctx && a.ctx && a.autoUnlock && a._unlockAudio(), a._howls.push(t), t._autoplay && t._queue.push({
                        event: "play",
                        action: function() {
                            t.play()
                        }
                    }), t._preload && "none" !== t._preload && t.load(), t
                },
                load: function() {
                    var e, t, n = this,
                        r = null;
                    if (a.noAudio) {
                        n._emit("loaderror", null, "No audio support.");
                        return
                    }
                    "string" == typeof n._src && (n._src = [n._src]);
                    for (var i = 0; i < n._src.length; i++) {
                        if (n._format && n._format[i]) e = n._format[i];
                        else {
                            if ("string" != typeof(t = n._src[i])) {
                                n._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                continue
                            }(e = /^data:audio\/([^;,]+);/i.exec(t)) || (e = /\.([^.]+)$/.exec(t.split("?", 1)[0])), e && (e = e[1].toLowerCase())
                        }
                        if (e || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), e && a.codecs(e)) {
                            r = n._src[i];
                            break
                        }
                    }
                    if (!r) {
                        n._emit("loaderror", null, "No codec support for selected audio sources.");
                        return
                    }
                    return n._src = r, n._state = "loading", "https:" === window.location.protocol && "http:" === r.slice(0, 5) && (n._html5 = !0, n._webAudio = !1), new o(n), n._webAudio && u(n), n
                },
                play: function(e, t) {
                    var n = this,
                        r = null;
                    if ("number" == typeof e) r = e, e = null;
                    else if ("string" == typeof e && "loaded" === n._state && !n._sprite[e]) return null;
                    else if (void 0 === e && (e = "__default", !n._playLock)) {
                        for (var i = 0, s = 0; s < n._sounds.length; s++) n._sounds[s]._paused && !n._sounds[s]._ended && (i++, r = n._sounds[s]._id);
                        1 === i ? e = null : r = null
                    }
                    var o = r ? n._soundById(r) : n._inactiveSound();
                    if (!o) return null;
                    if (r && !e && (e = o._sprite || "__default"), "loaded" !== n._state) {
                        o._sprite = e, o._ended = !1;
                        var l = o._id;
                        return n._queue.push({
                            event: "play",
                            action: function() {
                                n.play(l)
                            }
                        }), l
                    }
                    if (r && !o._paused) return t || n._loadQueue("play"), o._id;
                    n._webAudio && a._autoResume();
                    var u = Math.max(0, o._seek > 0 ? o._seek : n._sprite[e][0] / 1e3),
                        c = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - u),
                        h = 1e3 * c / Math.abs(o._rate),
                        d = n._sprite[e][0] / 1e3,
                        f = (n._sprite[e][0] + n._sprite[e][1]) / 1e3;
                    o._sprite = e, o._ended = !1;
                    var p = function() {
                        o._paused = !1, o._seek = u, o._start = d, o._stop = f, o._loop = !!(o._loop || n._sprite[e][2])
                    };
                    if (u >= f) {
                        n._ended(o);
                        return
                    }
                    var m = o._node;
                    if (n._webAudio) {
                        var g = function() {
                            n._playLock = !1, p(), n._refreshBuffer(o);
                            var e = o._muted || n._muted ? 0 : o._volume;
                            m.gain.setValueAtTime(e, a.ctx.currentTime), o._playStart = a.ctx.currentTime, void 0 === m.bufferSource.start ? o._loop ? m.bufferSource.noteGrainOn(0, u, 86400) : m.bufferSource.noteGrainOn(0, u, c) : o._loop ? m.bufferSource.start(0, u, 86400) : m.bufferSource.start(0, u, c), h !== 1 / 0 && (n._endTimers[o._id] = setTimeout(n._ended.bind(n, o), h)), t || setTimeout(function() {
                                n._emit("play", o._id), n._loadQueue()
                            }, 0)
                        };
                        "running" === a.state && "interrupted" !== a.ctx.state ? g() : (n._playLock = !0, n.once("resume", g), n._clearTimer(o._id))
                    } else {
                        var v = function() {
                            m.currentTime = u, m.muted = o._muted || n._muted || a._muted || m.muted, m.volume = o._volume * a.volume(), m.playbackRate = o._rate;
                            try {
                                var r = m.play();
                                if (r && "undefined" != typeof Promise && (r instanceof Promise || "function" == typeof r.then) ? (n._playLock = !0, p(), r.then(function() {
                                        n._playLock = !1, m._unlocked = !0, t ? n._loadQueue() : n._emit("play", o._id)
                                    }).catch(function() {
                                        n._playLock = !1, n._emit("playerror", o._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), o._ended = !0, o._paused = !0
                                    })) : t || (n._playLock = !1, p(), n._emit("play", o._id)), m.playbackRate = o._rate, m.paused) {
                                    n._emit("playerror", o._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                    return
                                }
                                "__default" !== e || o._loop ? n._endTimers[o._id] = setTimeout(n._ended.bind(n, o), h) : (n._endTimers[o._id] = function() {
                                    n._ended(o), m.removeEventListener("ended", n._endTimers[o._id], !1)
                                }, m.addEventListener("ended", n._endTimers[o._id], !1))
                            } catch (i) {
                                n._emit("playerror", o._id, i)
                            }
                        };
                        "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === m.src && (m.src = n._src, m.load());
                        var _ = window && window.ejecta || !m.readyState && a._navigator.isCocoonJS;
                        if (m.readyState >= 3 || _) v();
                        else {
                            n._playLock = !0, n._state = "loading";
                            var y = function() {
                                n._state = "loaded", v(), m.removeEventListener(a._canPlayEvent, y, !1)
                            };
                            m.addEventListener(a._canPlayEvent, y, !1), n._clearTimer(o._id)
                        }
                    }
                    return o._id
                },
                pause: function(e) {
                    var t = this;
                    if ("loaded" !== t._state || t._playLock) return t._queue.push({
                        event: "pause",
                        action: function() {
                            t.pause(e)
                        }
                    }), t;
                    for (var n = t._getSoundIds(e), r = 0; r < n.length; r++) {
                        t._clearTimer(n[r]);
                        var i = t._soundById(n[r]);
                        if (i && !i._paused && (i._seek = t.seek(n[r]), i._rateSeek = 0, i._paused = !0, t._stopFade(n[r]), i._node)) {
                            if (t._webAudio) {
                                if (!i._node.bufferSource) continue;
                                void 0 === i._node.bufferSource.stop ? i._node.bufferSource.noteOff(0) : i._node.bufferSource.stop(0), t._cleanBuffer(i._node)
                            } else isNaN(i._node.duration) && i._node.duration !== 1 / 0 || i._node.pause()
                        }
                        arguments[1] || t._emit("pause", i ? i._id : null)
                    }
                    return t
                },
                stop: function(e, t) {
                    var n = this;
                    if ("loaded" !== n._state || n._playLock) return n._queue.push({
                        event: "stop",
                        action: function() {
                            n.stop(e)
                        }
                    }), n;
                    for (var r = n._getSoundIds(e), i = 0; i < r.length; i++) {
                        n._clearTimer(r[i]);
                        var a = n._soundById(r[i]);
                        a && (a._seek = a._start || 0, a._rateSeek = 0, a._paused = !0, a._ended = !0, n._stopFade(r[i]), a._node && (n._webAudio ? a._node.bufferSource && (void 0 === a._node.bufferSource.stop ? a._node.bufferSource.noteOff(0) : a._node.bufferSource.stop(0), n._cleanBuffer(a._node)) : isNaN(a._node.duration) && a._node.duration !== 1 / 0 || (a._node.currentTime = a._start || 0, a._node.pause(), a._node.duration === 1 / 0 && n._clearSound(a._node))), t || n._emit("stop", a._id))
                    }
                    return n
                },
                mute: function(e, t) {
                    var n = this;
                    if ("loaded" !== n._state || n._playLock) return n._queue.push({
                        event: "mute",
                        action: function() {
                            n.mute(e, t)
                        }
                    }), n;
                    if (void 0 === t) {
                        if ("boolean" != typeof e) return n._muted;
                        n._muted = e
                    }
                    for (var r = n._getSoundIds(t), i = 0; i < r.length; i++) {
                        var s = n._soundById(r[i]);
                        s && (s._muted = e, s._interval && n._stopFade(s._id), n._webAudio && s._node ? s._node.gain.setValueAtTime(e ? 0 : s._volume, a.ctx.currentTime) : s._node && (s._node.muted = !!a._muted || e), n._emit("mute", s._id))
                    }
                    return n
                },
                volume: function() {
                    var e, t, n, r = this,
                        i = arguments;
                    if (0 === i.length) return r._volume;
                    if (1 === i.length || 2 === i.length && void 0 === i[1] ? r._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : e = parseFloat(i[0]) : i.length >= 2 && (e = parseFloat(i[0]), t = parseInt(i[1], 10)), void 0 === e || !(e >= 0) || !(e <= 1)) return (n = t ? r._soundById(t) : r._sounds[0]) ? n._volume : 0;
                    if ("loaded" !== r._state || r._playLock) return r._queue.push({
                        event: "volume",
                        action: function() {
                            r.volume.apply(r, i)
                        }
                    }), r;
                    void 0 === t && (r._volume = e), t = r._getSoundIds(t);
                    for (var s = 0; s < t.length; s++)(n = r._soundById(t[s])) && (n._volume = e, i[2] || r._stopFade(t[s]), r._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(e, a.ctx.currentTime) : n._node && !n._muted && (n._node.volume = e * a.volume()), r._emit("volume", n._id));
                    return r
                },
                fade: function(e, t, n, r) {
                    var i = this;
                    if ("loaded" !== i._state || i._playLock) return i._queue.push({
                        event: "fade",
                        action: function() {
                            i.fade(e, t, n, r)
                        }
                    }), i;
                    e = Math.min(Math.max(0, parseFloat(e)), 1), t = Math.min(Math.max(0, parseFloat(t)), 1), n = parseFloat(n), i.volume(e, r);
                    for (var s = i._getSoundIds(r), o = 0; o < s.length; o++) {
                        var l = i._soundById(s[o]);
                        if (l) {
                            if (r || i._stopFade(s[o]), i._webAudio && !l._muted) {
                                var u = a.ctx.currentTime,
                                    c = u + n / 1e3;
                                l._volume = e, l._node.gain.setValueAtTime(e, u), l._node.gain.linearRampToValueAtTime(t, c)
                            }
                            i._startFadeInterval(l, e, t, n, s[o], void 0 === r)
                        }
                    }
                    return i
                },
                _startFadeInterval: function(e, t, n, r, i, a) {
                    var s = this,
                        o = t,
                        l = n - t,
                        u = Math.abs(l / .01),
                        c = Date.now();
                    e._fadeTo = n, e._interval = setInterval(function() {
                        var i = (Date.now() - c) / r;
                        c = Date.now(), o += l * i, o = Math.round(100 * o) / 100, o = l < 0 ? Math.max(n, o) : Math.min(n, o), s._webAudio ? e._volume = o : s.volume(o, e._id, !0), a && (s._volume = o), (n < t && o <= n || n > t && o >= n) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, s.volume(n, e._id), s._emit("fade", e._id))
                    }, Math.max(4, u > 0 ? r / u : r))
                },
                _stopFade: function(e) {
                    var t = this._soundById(e);
                    return t && t._interval && (this._webAudio && t._node.gain.cancelScheduledValues(a.ctx.currentTime), clearInterval(t._interval), t._interval = null, this.volume(t._fadeTo, e), t._fadeTo = null, this._emit("fade", e)), this
                },
                loop: function() {
                    var e, t, n, r = this,
                        i = arguments;
                    if (0 === i.length) return r._loop;
                    if (1 === i.length) {
                        if ("boolean" != typeof i[0]) return !!(n = r._soundById(parseInt(i[0], 10))) && n._loop;
                        e = i[0], r._loop = e
                    } else 2 === i.length && (e = i[0], t = parseInt(i[1], 10));
                    for (var a = r._getSoundIds(t), s = 0; s < a.length; s++)(n = r._soundById(a[s])) && (n._loop = e, r._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = e, e && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop, r.playing(a[s]) && (r.pause(a[s], !0), r.play(a[s], !0)))));
                    return r
                },
                rate: function() {
                    var e, t, n, r = this,
                        i = arguments;
                    if (0 === i.length ? t = r._sounds[0]._id : 1 === i.length ? r._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : e = parseFloat(i[0]) : 2 === i.length && (e = parseFloat(i[0]), t = parseInt(i[1], 10)), "number" != typeof e) return (n = r._soundById(t)) ? n._rate : r._rate;
                    if ("loaded" !== r._state || r._playLock) return r._queue.push({
                        event: "rate",
                        action: function() {
                            r.rate.apply(r, i)
                        }
                    }), r;
                    void 0 === t && (r._rate = e), t = r._getSoundIds(t);
                    for (var s = 0; s < t.length; s++)
                        if (n = r._soundById(t[s])) {
                            r.playing(t[s]) && (n._rateSeek = r.seek(t[s]), n._playStart = r._webAudio ? a.ctx.currentTime : n._playStart), n._rate = e, r._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(e, a.ctx.currentTime) : n._node && (n._node.playbackRate = e);
                            var o = r.seek(t[s]),
                                l = 1e3 * ((r._sprite[n._sprite][0] + r._sprite[n._sprite][1]) / 1e3 - o) / Math.abs(n._rate);
                            (r._endTimers[t[s]] || !n._paused) && (r._clearTimer(t[s]), r._endTimers[t[s]] = setTimeout(r._ended.bind(r, n), l)), r._emit("rate", n._id)
                        }
                    return r
                },
                seek: function() {
                    var e, t, n = this,
                        r = arguments;
                    if (0 === r.length ? n._sounds.length && (t = n._sounds[0]._id) : 1 === r.length ? n._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : n._sounds.length && (t = n._sounds[0]._id, e = parseFloat(r[0])) : 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10)), void 0 === t) return 0;
                    if ("number" == typeof e && ("loaded" !== n._state || n._playLock)) return n._queue.push({
                        event: "seek",
                        action: function() {
                            n.seek.apply(n, r)
                        }
                    }), n;
                    var i = n._soundById(t);
                    if (i) {
                        if ("number" == typeof e && e >= 0) {
                            var s = n.playing(t);
                            s && n.pause(t, !0), i._seek = e, i._ended = !1, n._clearTimer(t), n._webAudio || !i._node || isNaN(i._node.duration) || (i._node.currentTime = e);
                            var o = function() {
                                s && n.play(t, !0), n._emit("seek", t)
                            };
                            if (s && !n._webAudio) {
                                var l = function() {
                                    n._playLock ? setTimeout(l, 0) : o()
                                };
                                setTimeout(l, 0)
                            } else o()
                        } else {
                            if (!n._webAudio) return i._node.currentTime;
                            var u = n.playing(t) ? a.ctx.currentTime - i._playStart : 0,
                                c = i._rateSeek ? i._rateSeek - i._seek : 0;
                            return i._seek + (c + u * Math.abs(i._rate))
                        }
                    }
                    return n
                },
                playing: function(e) {
                    if ("number" == typeof e) {
                        var t = this._soundById(e);
                        return !!t && !t._paused
                    }
                    for (var n = 0; n < this._sounds.length; n++)
                        if (!this._sounds[n]._paused) return !0;
                    return !1
                },
                duration: function(e) {
                    var t = this._duration,
                        n = this._soundById(e);
                    return n && (t = this._sprite[n._sprite][1] / 1e3), t
                },
                state: function() {
                    return this._state
                },
                unload: function() {
                    for (var e = this, t = e._sounds, n = 0; n < t.length; n++) t[n]._paused || e.stop(t[n]._id), e._webAudio || (e._clearSound(t[n]._node), t[n]._node.removeEventListener("error", t[n]._errorFn, !1), t[n]._node.removeEventListener(a._canPlayEvent, t[n]._loadFn, !1), t[n]._node.removeEventListener("ended", t[n]._endFn, !1), a._releaseHtml5Audio(t[n]._node)), delete t[n]._node, e._clearTimer(t[n]._id);
                    var r = a._howls.indexOf(e);
                    r >= 0 && a._howls.splice(r, 1);
                    var i = !0;
                    for (n = 0; n < a._howls.length; n++)
                        if (a._howls[n]._src === e._src || e._src.indexOf(a._howls[n]._src) >= 0) {
                            i = !1;
                            break
                        }
                    return l && i && delete l[e._src], a.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null
                },
                on: function(e, t, n, r) {
                    var i = this["_on" + e];
                    return "function" == typeof t && i.push(r ? {
                        id: n,
                        fn: t,
                        once: r
                    } : {
                        id: n,
                        fn: t
                    }), this
                },
                off: function(e, t, n) {
                    var r = this,
                        i = r["_on" + e],
                        a = 0;
                    if ("number" == typeof t && (n = t, t = null), t || n)
                        for (a = 0; a < i.length; a++) {
                            var s = n === i[a].id;
                            if (t === i[a].fn && s || !t && s) {
                                i.splice(a, 1);
                                break
                            }
                        } else if (e) r["_on" + e] = [];
                        else {
                            var o = Object.keys(r);
                            for (a = 0; a < o.length; a++) 0 === o[a].indexOf("_on") && Array.isArray(r[o[a]]) && (r[o[a]] = [])
                        }
                    return r
                },
                once: function(e, t, n) {
                    return this.on(e, t, n, 1), this
                },
                _emit: function(e, t, n) {
                    for (var r = this["_on" + e], i = r.length - 1; i >= 0; i--)(!r[i].id || r[i].id === t || "load" === e) && (setTimeout((function(e) {
                        e.call(this, t, n)
                    }).bind(this, r[i].fn), 0), r[i].once && this.off(e, r[i].fn, r[i].id));
                    return this._loadQueue(e), this
                },
                _loadQueue: function(e) {
                    if (this._queue.length > 0) {
                        var t = this._queue[0];
                        t.event === e && (this._queue.shift(), this._loadQueue()), e || t.action()
                    }
                    return this
                },
                _ended: function(e) {
                    var t = this,
                        n = e._sprite;
                    if (!t._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(t._ended.bind(t, e), 100), t;
                    var r = !!(e._loop || t._sprite[n][2]);
                    if (t._emit("end", e._id), !t._webAudio && r && t.stop(e._id, !0).play(e._id), t._webAudio && r) {
                        t._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = a.ctx.currentTime;
                        var i = (e._stop - e._start) * 1e3 / Math.abs(e._rate);
                        t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), i)
                    }
                    return t._webAudio && !r && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, t._clearTimer(e._id), t._cleanBuffer(e._node), a._autoSuspend()), t._webAudio || r || t.stop(e._id, !0), t
                },
                _clearTimer: function(e) {
                    if (this._endTimers[e]) {
                        if ("function" != typeof this._endTimers[e]) clearTimeout(this._endTimers[e]);
                        else {
                            var t = this._soundById(e);
                            t && t._node && t._node.removeEventListener("ended", this._endTimers[e], !1)
                        }
                        delete this._endTimers[e]
                    }
                    return this
                },
                _soundById: function(e) {
                    for (var t = 0; t < this._sounds.length; t++)
                        if (e === this._sounds[t]._id) return this._sounds[t];
                    return null
                },
                _inactiveSound: function() {
                    this._drain();
                    for (var e = 0; e < this._sounds.length; e++)
                        if (this._sounds[e]._ended) return this._sounds[e].reset();
                    return new o(this)
                },
                _drain: function() {
                    var e = this._pool,
                        t = 0,
                        n = 0;
                    if (!(this._sounds.length < e)) {
                        for (n = 0; n < this._sounds.length; n++) this._sounds[n]._ended && t++;
                        for (n = this._sounds.length - 1; n >= 0; n--) {
                            if (t <= e) return;
                            this._sounds[n]._ended && (this._webAudio && this._sounds[n]._node && this._sounds[n]._node.disconnect(0), this._sounds.splice(n, 1), t--)
                        }
                    }
                },
                _getSoundIds: function(e) {
                    if (void 0 !== e) return [e];
                    for (var t = [], n = 0; n < this._sounds.length; n++) t.push(this._sounds[n]._id);
                    return t
                },
                _refreshBuffer: function(e) {
                    return e._node.bufferSource = a.ctx.createBufferSource(), e._node.bufferSource.buffer = l[this._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, a.ctx.currentTime), this
                },
                _cleanBuffer: function(e) {
                    var t = a._navigator && a._navigator.vendor.indexOf("Apple") >= 0;
                    if (a._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null, e.bufferSource.disconnect(0), t)) try {
                        e.bufferSource.buffer = a._scratchBuffer
                    } catch (n) {}
                    return e.bufferSource = null, this
                },
                _clearSound: function(e) {
                    /MSIE |Trident\//.test(a._navigator && a._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                }
            }, (o = function(e) {
                this._parent = e, this.init()
            }).prototype = {
                init: function() {
                    var e = this,
                        t = e._parent;
                    return e._muted = t._muted, e._loop = t._loop, e._volume = t._volume, e._rate = t._rate, e._seek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++a._counter, t._sounds.push(e), e.create(), e
                },
                create: function() {
                    var e = this,
                        t = e._parent,
                        n = a._muted || e._muted || e._parent._muted ? 0 : e._volume;
                    return t._webAudio ? (e._node = void 0 === a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(), e._node.gain.setValueAtTime(n, a.ctx.currentTime), e._node.paused = !0, e._node.connect(a.masterGain)) : a.noAudio || (e._node = a._obtainHtml5Audio(), e._errorFn = e._errorListener.bind(e), e._node.addEventListener("error", e._errorFn, !1), e._loadFn = e._loadListener.bind(e), e._node.addEventListener(a._canPlayEvent, e._loadFn, !1), e._endFn = e._endListener.bind(e), e._node.addEventListener("ended", e._endFn, !1), e._node.src = t._src, e._node.preload = !0 === t._preload ? "auto" : t._preload, e._node.volume = n * a.volume(), e._node.load()), e
                },
                reset: function() {
                    var e = this,
                        t = e._parent;
                    return e._muted = t._muted, e._loop = t._loop, e._volume = t._volume, e._rate = t._rate, e._seek = 0, e._rateSeek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++a._counter, e
                },
                _errorListener: function() {
                    this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1)
                },
                _loadListener: function() {
                    var e = this._parent;
                    e._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = {
                        __default: [0, 1e3 * e._duration]
                    }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), this._node.removeEventListener(a._canPlayEvent, this._loadFn, !1)
                },
                _endListener: function() {
                    var e = this._parent;
                    e._duration === 1 / 0 && (e._duration = Math.ceil(10 * this._node.duration) / 10, e._sprite.__default[1] === 1 / 0 && (e._sprite.__default[1] = 1e3 * e._duration), e._ended(this)), this._node.removeEventListener("ended", this._endFn, !1)
                }
            }, l = {}, u = function(e) {
                var t = e._src;
                if (l[t]) {
                    e._duration = l[t].duration, d(e);
                    return
                }
                if (/^data:[^;]+;base64,/.test(t)) {
                    for (var n = atob(t.split(",")[1]), r = new Uint8Array(n.length), i = 0; i < n.length; ++i) r[i] = n.charCodeAt(i);
                    h(r.buffer, e)
                } else {
                    var a = new XMLHttpRequest;
                    a.open(e._xhr.method, t, !0), a.withCredentials = e._xhr.withCredentials, a.responseType = "arraybuffer", e._xhr.headers && Object.keys(e._xhr.headers).forEach(function(t) {
                        a.setRequestHeader(t, e._xhr.headers[t])
                    }), a.onload = function() {
                        var t = (a.status + "")[0];
                        if ("0" !== t && "2" !== t && "3" !== t) {
                            e._emit("loaderror", null, "Failed loading audio file with status: " + a.status + ".");
                            return
                        }
                        h(a.response, e)
                    }, a.onerror = function() {
                        e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete l[t], e.load())
                    }, c(a)
                }
            }, c = function(e) {
                try {
                    e.send()
                } catch (t) {
                    e.onerror()
                }
            }, h = function(e, t) {
                var n = function() {
                        t._emit("loaderror", null, "Decoding audio data failed.")
                    },
                    r = function(e) {
                        e && t._sounds.length > 0 ? (l[t._src] = e, d(t, e)) : n()
                    };
                "undefined" != typeof Promise && 1 === a.ctx.decodeAudioData.length ? a.ctx.decodeAudioData(e).then(r).catch(n) : a.ctx.decodeAudioData(e, r, n)
            }, d = function(e, t) {
                t && !e._duration && (e._duration = t.duration), 0 === Object.keys(e._sprite).length && (e._sprite = {
                    __default: [0, 1e3 * e._duration]
                }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue())
            }, f = function() {
                if (a.usingWebAudio) {
                    try {
                        "undefined" != typeof AudioContext ? a.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? a.ctx = new webkitAudioContext : a.usingWebAudio = !1
                    } catch (e) {
                        a.usingWebAudio = !1
                    }
                    a.ctx || (a.usingWebAudio = !1);
                    var t = /iP(hone|od|ad)/.test(a._navigator && a._navigator.platform),
                        n = a._navigator && a._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                        r = n ? parseInt(n[1], 10) : null;
                    if (t && r && r < 9) {
                        var i = /safari/.test(a._navigator && a._navigator.userAgent.toLowerCase());
                        a._navigator && !i && (a.usingWebAudio = !1)
                    }
                    a.usingWebAudio && (a.masterGain = void 0 === a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(), a.masterGain.gain.setValueAtTime(a._muted ? 0 : a._volume, a.ctx.currentTime), a.masterGain.connect(a.ctx.destination)), a._setup()
                }
            }, void 0 !== (r = (function() {
                return {
                    Howler: a,
                    Howl: s
                }
            }).apply(t, [])) && (e.exports = r), t.Howler = a, t.Howl = s, void 0 !== n.g ? (n.g.HowlerGlobal = i, n.g.Howler = a, n.g.Howl = s, n.g.Sound = o) : "undefined" != typeof window && (window.HowlerGlobal = i, window.Howler = a, window.Howl = s, window.Sound = o), HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(e) {
                if (!this.ctx || !this.ctx.listener) return this;
                for (var t = this._howls.length - 1; t >= 0; t--) this._howls[t].stereo(e);
                return this
            }, HowlerGlobal.prototype.pos = function(e, t, n) {
                var r = this;
                return r.ctx && r.ctx.listener ? (t = "number" != typeof t ? r._pos[1] : t, n = "number" != typeof n ? r._pos[2] : n, "number" != typeof e) ? r._pos : (r._pos = [e, t, n], void 0 !== r.ctx.listener.positionX ? (r.ctx.listener.positionX.setTargetAtTime(r._pos[0], Howler.ctx.currentTime, .1), r.ctx.listener.positionY.setTargetAtTime(r._pos[1], Howler.ctx.currentTime, .1), r.ctx.listener.positionZ.setTargetAtTime(r._pos[2], Howler.ctx.currentTime, .1)) : r.ctx.listener.setPosition(r._pos[0], r._pos[1], r._pos[2]), r) : r
            }, HowlerGlobal.prototype.orientation = function(e, t, n, r, i, a) {
                var s = this;
                if (!s.ctx || !s.ctx.listener) return s;
                var o = s._orientation;
                return (t = "number" != typeof t ? o[1] : t, n = "number" != typeof n ? o[2] : n, r = "number" != typeof r ? o[3] : r, i = "number" != typeof i ? o[4] : i, a = "number" != typeof a ? o[5] : a, "number" != typeof e) ? o : (s._orientation = [e, t, n, r, i, a], void 0 !== s.ctx.listener.forwardX ? (s.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), s.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1), s.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), s.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), s.ctx.listener.upY.setTargetAtTime(i, Howler.ctx.currentTime, .1), s.ctx.listener.upZ.setTargetAtTime(a, Howler.ctx.currentTime, .1)) : s.ctx.listener.setOrientation(e, t, n, r, i, a), s)
            }, Howl.prototype.init = (p = Howl.prototype.init, function(e) {
                var t = this;
                return t._orientation = e.orientation || [1, 0, 0], t._stereo = e.stereo || null, t._pos = e.pos || null, t._pannerAttr = {
                    coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : 360,
                    coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : 360,
                    coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : 0,
                    distanceModel: void 0 !== e.distanceModel ? e.distanceModel : "inverse",
                    maxDistance: void 0 !== e.maxDistance ? e.maxDistance : 1e4,
                    panningModel: void 0 !== e.panningModel ? e.panningModel : "HRTF",
                    refDistance: void 0 !== e.refDistance ? e.refDistance : 1,
                    rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : 1
                }, t._onstereo = e.onstereo ? [{
                    fn: e.onstereo
                }] : [], t._onpos = e.onpos ? [{
                    fn: e.onpos
                }] : [], t._onorientation = e.onorientation ? [{
                    fn: e.onorientation
                }] : [], p.call(this, e)
            }), Howl.prototype.stereo = function(e, t) {
                var n = this;
                if (!n._webAudio) return n;
                if ("loaded" !== n._state) return n._queue.push({
                    event: "stereo",
                    action: function() {
                        n.stereo(e, t)
                    }
                }), n;
                var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                if (void 0 === t) {
                    if ("number" != typeof e) return n._stereo;
                    n._stereo = e, n._pos = [e, 0, 0]
                }
                for (var i = n._getSoundIds(t), a = 0; a < i.length; a++) {
                    var s = n._soundById(i[a]);
                    if (s) {
                        if ("number" != typeof e) return s._stereo;
                        s._stereo = e, s._pos = [e, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || v(s, r), "spatial" === r ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(e, 0, 0) : s._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), n._emit("stereo", s._id)
                    }
                }
                return n
            }, Howl.prototype.pos = function(e, t, n, r) {
                var i = this;
                if (!i._webAudio) return i;
                if ("loaded" !== i._state) return i._queue.push({
                    event: "pos",
                    action: function() {
                        i.pos(e, t, n, r)
                    }
                }), i;
                if (t = "number" != typeof t ? 0 : t, n = "number" != typeof n ? -.5 : n, void 0 === r) {
                    if ("number" != typeof e) return i._pos;
                    i._pos = [e, t, n]
                }
                for (var a = i._getSoundIds(r), s = 0; s < a.length; s++) {
                    var o = i._soundById(a[s]);
                    if (o) {
                        if ("number" != typeof e) return o._pos;
                        o._pos = [e, t, n], o._node && ((!o._panner || o._panner.pan) && v(o, "spatial"), void 0 !== o._panner.positionX ? (o._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), o._panner.positionY.setValueAtTime(t, Howler.ctx.currentTime), o._panner.positionZ.setValueAtTime(n, Howler.ctx.currentTime)) : o._panner.setPosition(e, t, n)), i._emit("pos", o._id)
                    }
                }
                return i
            }, Howl.prototype.orientation = function(e, t, n, r) {
                var i = this;
                if (!i._webAudio) return i;
                if ("loaded" !== i._state) return i._queue.push({
                    event: "orientation",
                    action: function() {
                        i.orientation(e, t, n, r)
                    }
                }), i;
                if (t = "number" != typeof t ? i._orientation[1] : t, n = "number" != typeof n ? i._orientation[2] : n, void 0 === r) {
                    if ("number" != typeof e) return i._orientation;
                    i._orientation = [e, t, n]
                }
                for (var a = i._getSoundIds(r), s = 0; s < a.length; s++) {
                    var o = i._soundById(a[s]);
                    if (o) {
                        if ("number" != typeof e) return o._orientation;
                        o._orientation = [e, t, n], o._node && (o._panner || (o._pos || (o._pos = i._pos || [0, 0, -.5]), v(o, "spatial")), void 0 !== o._panner.orientationX ? (o._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), o._panner.orientationY.setValueAtTime(t, Howler.ctx.currentTime), o._panner.orientationZ.setValueAtTime(n, Howler.ctx.currentTime)) : o._panner.setOrientation(e, t, n)), i._emit("orientation", o._id)
                    }
                }
                return i
            }, Howl.prototype.pannerAttr = function() {
                var e, t, n, r = this,
                    i = arguments;
                if (!r._webAudio) return r;
                if (0 === i.length) return r._pannerAttr;
                if (1 === i.length) {
                    if ("object" != typeof i[0]) return (n = r._soundById(parseInt(i[0], 10))) ? n._pannerAttr : r._pannerAttr;
                    e = i[0], void 0 === t && (e.pannerAttr || (e.pannerAttr = {
                        coneInnerAngle: e.coneInnerAngle,
                        coneOuterAngle: e.coneOuterAngle,
                        coneOuterGain: e.coneOuterGain,
                        distanceModel: e.distanceModel,
                        maxDistance: e.maxDistance,
                        refDistance: e.refDistance,
                        rolloffFactor: e.rolloffFactor,
                        panningModel: e.panningModel
                    }), r._pannerAttr = {
                        coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : r._coneInnerAngle,
                        coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : r._coneOuterAngle,
                        coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : r._coneOuterGain,
                        distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : r._distanceModel,
                        maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : r._maxDistance,
                        refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : r._refDistance,
                        rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : r._rolloffFactor,
                        panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : r._panningModel
                    })
                } else 2 === i.length && (e = i[0], t = parseInt(i[1], 10));
                for (var a = r._getSoundIds(t), s = 0; s < a.length; s++)
                    if (n = r._soundById(a[s])) {
                        var o = n._pannerAttr;
                        o = {
                            coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : o.coneInnerAngle,
                            coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : o.coneOuterAngle,
                            coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : o.coneOuterGain,
                            distanceModel: void 0 !== e.distanceModel ? e.distanceModel : o.distanceModel,
                            maxDistance: void 0 !== e.maxDistance ? e.maxDistance : o.maxDistance,
                            refDistance: void 0 !== e.refDistance ? e.refDistance : o.refDistance,
                            rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : o.rolloffFactor,
                            panningModel: void 0 !== e.panningModel ? e.panningModel : o.panningModel
                        };
                        var l = n._panner;
                        l ? (l.coneInnerAngle = o.coneInnerAngle, l.coneOuterAngle = o.coneOuterAngle, l.coneOuterGain = o.coneOuterGain, l.distanceModel = o.distanceModel, l.maxDistance = o.maxDistance, l.refDistance = o.refDistance, l.rolloffFactor = o.rolloffFactor, l.panningModel = o.panningModel) : (n._pos || (n._pos = r._pos || [0, 0, -.5]), v(n, "spatial"))
                    }
                return r
            }, Sound.prototype.init = (m = Sound.prototype.init, function() {
                var e = this,
                    t = e._parent;
                e._orientation = t._orientation, e._stereo = t._stereo, e._pos = t._pos, e._pannerAttr = t._pannerAttr, m.call(this), e._stereo ? t.stereo(e._stereo) : e._pos && t.pos(e._pos[0], e._pos[1], e._pos[2], e._id)
            }), Sound.prototype.reset = (g = Sound.prototype.reset, function() {
                var e = this,
                    t = e._parent;
                return e._orientation = t._orientation, e._stereo = t._stereo, e._pos = t._pos, e._pannerAttr = t._pannerAttr, e._stereo ? t.stereo(e._stereo) : e._pos ? t.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, t._refreshBuffer(e)), g.call(this)
            }), v = function(e, t) {
                "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0)
            }
        },
        6486: function(e, t, n) {
            var r;
            e = n.nmd(e), (function() {
                var i, a = "Expected a function",
                    s = "__lodash_hash_undefined__",
                    o = "__lodash_placeholder__",
                    l = 1 / 0,
                    u = 0 / 0,
                    c = [
                        ["ary", 128],
                        ["bind", 1],
                        ["bindKey", 2],
                        ["curry", 8],
                        ["curryRight", 16],
                        ["flip", 512],
                        ["partial", 32],
                        ["partialRight", 64],
                        ["rearg", 256]
                    ],
                    h = "[object Arguments]",
                    d = "[object Array]",
                    f = "[object Boolean]",
                    p = "[object Date]",
                    m = "[object Error]",
                    g = "[object Function]",
                    v = "[object GeneratorFunction]",
                    _ = "[object Map]",
                    y = "[object Number]",
                    x = "[object Object]",
                    b = "[object Promise]",
                    w = "[object RegExp]",
                    S = "[object Set]",
                    M = "[object String]",
                    T = "[object Symbol]",
                    A = "[object WeakMap]",
                    E = "[object ArrayBuffer]",
                    C = "[object DataView]",
                    I = "[object Float32Array]",
                    P = "[object Float64Array]",
                    R = "[object Int8Array]",
                    L = "[object Int16Array]",
                    D = "[object Int32Array]",
                    k = "[object Uint8Array]",
                    U = "[object Uint8ClampedArray]",
                    O = "[object Uint16Array]",
                    F = "[object Uint32Array]",
                    N = /\b__p \+= '';/g,
                    B = /\b(__p \+=) '' \+/g,
                    z = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                    G = /&(?:amp|lt|gt|quot|#39);/g,
                    V = /[&<>"']/g,
                    W = RegExp(G.source),
                    H = RegExp(V.source),
                    j = /<%-([\s\S]+?)%>/g,
                    q = /<%([\s\S]+?)%>/g,
                    X = /<%=([\s\S]+?)%>/g,
                    Z = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                    Y = /^\w*$/,
                    $ = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                    J = /[\\^$.*+?()[\]{}|]/g,
                    K = RegExp(J.source),
                    Q = /^\s+/,
                    ee = /\s/,
                    et = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                    en = /\{\n\/\* \[wrapped with (.+)\] \*/,
                    er = /,? & /,
                    ei = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                    ea = /[()=,{}\[\]\/\s]/,
                    es = /\\(\\)?/g,
                    eo = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                    el = /\w*$/,
                    eu = /^[-+]0x[0-9a-f]+$/i,
                    ec = /^0b[01]+$/i,
                    eh = /^\[object .+?Constructor\]$/,
                    ed = /^0o[0-7]+$/i,
                    ef = /^(?:0|[1-9]\d*)$/,
                    ep = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                    em = /($^)/,
                    eg = /['\n\r\u2028\u2029\\]/g,
                    ev = "\ud800-\udfff",
                    e_ = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
                    ey = "\\u2700-\\u27bf",
                    ex = "a-z\\xdf-\\xf6\\xf8-\\xff",
                    eb = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                    ew = "\\ufe0e\\ufe0f",
                    eS = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                    eM = "[']",
                    eT = "[" + eS + "]",
                    eA = "[" + e_ + "]",
                    eE = "[" + ex + "]",
                    eC = "[^" + ev + eS + "\\d+" + ey + ex + eb + "]",
                    eI = "\ud83c[\udffb-\udfff]",
                    eP = "[^" + ev + "]",
                    eR = "(?:\ud83c[\udde6-\uddff]){2}",
                    eL = "[\ud800-\udbff][\udc00-\udfff]",
                    eD = "[" + eb + "]",
                    ek = "\\u200d",
                    eU = "(?:" + eE + "|" + eC + ")",
                    eO = "(?:" + eM + "(?:d|ll|m|re|s|t|ve))?",
                    eF = "(?:" + eM + "(?:D|LL|M|RE|S|T|VE))?",
                    eN = "(?:" + eA + "|" + eI + ")?",
                    eB = "[" + ew + "]?",
                    ez = "(?:" + ek + "(?:" + [eP, eR, eL].join("|") + ")" + eB + eN + ")*",
                    eG = eB + eN + ez,
                    eV = "(?:" + ["[" + ey + "]", eR, eL].join("|") + ")" + eG,
                    eW = "(?:" + [eP + eA + "?", eA, eR, eL, "[" + ev + "]"].join("|") + ")",
                    eH = RegExp(eM, "g"),
                    ej = RegExp(eA, "g"),
                    eq = RegExp(eI + "(?=" + eI + ")|" + eW + eG, "g"),
                    eX = RegExp([eD + "?" + eE + "+" + eO + "(?=" + [eT, eD, "$"].join("|") + ")", "(?:" + eD + "|" + eC + ")+" + eF + "(?=" + [eT, eD + eU, "$"].join("|") + ")", eD + "?" + eU + "+" + eO, eD + "+" + eF, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", "\\d+", eV].join("|"), "g"),
                    eZ = RegExp("[" + ek + ev + e_ + ew + "]"),
                    eY = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                    e$ = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                    eJ = -1,
                    eK = {};
                eK[I] = eK[P] = eK[R] = eK[L] = eK[D] = eK[k] = eK[U] = eK[O] = eK[F] = !0, eK[h] = eK[d] = eK[E] = eK[f] = eK[C] = eK[p] = eK[m] = eK[g] = eK[_] = eK[y] = eK[x] = eK[w] = eK[S] = eK[M] = eK[A] = !1;
                var eQ = {};
                eQ[h] = eQ[d] = eQ[E] = eQ[C] = eQ[f] = eQ[p] = eQ[I] = eQ[P] = eQ[R] = eQ[L] = eQ[D] = eQ[_] = eQ[y] = eQ[x] = eQ[w] = eQ[S] = eQ[M] = eQ[T] = eQ[k] = eQ[U] = eQ[O] = eQ[F] = !0, eQ[m] = eQ[g] = eQ[A] = !1;
                var e0 = {
                        "\\": "\\",
                        "'": "'",
                        "\n": "n",
                        "\r": "r",
                        "\u2028": "u2028",
                        "\u2029": "u2029"
                    },
                    e1 = parseFloat,
                    e2 = parseInt,
                    e3 = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                    e4 = "object" == typeof self && self && self.Object === Object && self,
                    e5 = e3 || e4 || Function("return this")(),
                    e6 = t && !t.nodeType && t,
                    e8 = e6 && e && !e.nodeType && e,
                    e7 = e8 && e8.exports === e6,
                    e9 = e7 && e3.process,
                    te = function() {
                        try {
                            var e = e8 && e8.require && e8.require("util").types;
                            if (e) return e;
                            return e9 && e9.binding && e9.binding("util")
                        } catch (t) {}
                    }(),
                    tt = te && te.isArrayBuffer,
                    tn = te && te.isDate,
                    tr = te && te.isMap,
                    ti = te && te.isRegExp,
                    ta = te && te.isSet,
                    ts = te && te.isTypedArray;

                function to(e, t, n) {
                    switch (n.length) {
                        case 0:
                            return e.call(t);
                        case 1:
                            return e.call(t, n[0]);
                        case 2:
                            return e.call(t, n[0], n[1]);
                        case 3:
                            return e.call(t, n[0], n[1], n[2])
                    }
                    return e.apply(t, n)
                }

                function tl(e, t, n, r) {
                    for (var i = -1, a = null == e ? 0 : e.length; ++i < a;) {
                        var s = e[i];
                        t(r, s, n(s), e)
                    }
                    return r
                }

                function tu(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e););
                    return e
                }

                function tc(e, t) {
                    for (var n = null == e ? 0 : e.length; n-- && !1 !== t(e[n], n, e););
                    return e
                }

                function th(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length; ++n < r;)
                        if (!t(e[n], n, e)) return !1;
                    return !0
                }

                function td(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length, i = 0, a = []; ++n < r;) {
                        var s = e[n];
                        t(s, n, e) && (a[i++] = s)
                    }
                    return a
                }

                function tf(e, t) {
                    return !!(null == e ? 0 : e.length) && tS(e, t, 0) > -1
                }

                function tp(e, t, n) {
                    for (var r = -1, i = null == e ? 0 : e.length; ++r < i;)
                        if (n(t, e[r])) return !0;
                    return !1
                }

                function tm(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length, i = Array(r); ++n < r;) i[n] = t(e[n], n, e);
                    return i
                }

                function tg(e, t) {
                    for (var n = -1, r = t.length, i = e.length; ++n < r;) e[i + n] = t[n];
                    return e
                }

                function tv(e, t, n, r) {
                    var i = -1,
                        a = null == e ? 0 : e.length;
                    for (r && a && (n = e[++i]); ++i < a;) n = t(n, e[i], i, e);
                    return n
                }

                function t_(e, t, n, r) {
                    var i = null == e ? 0 : e.length;
                    for (r && i && (n = e[--i]); i--;) n = t(n, e[i], i, e);
                    return n
                }

                function ty(e, t) {
                    for (var n = -1, r = null == e ? 0 : e.length; ++n < r;)
                        if (t(e[n], n, e)) return !0;
                    return !1
                }
                var tx = tE("length");

                function tb(e, t, n) {
                    var r;
                    return n(e, function(e, n, i) {
                        if (t(e, n, i)) return r = n, !1
                    }), r
                }

                function tw(e, t, n, r) {
                    for (var i = e.length, a = n + (r ? 1 : -1); r ? a-- : ++a < i;)
                        if (t(e[a], a, e)) return a;
                    return -1
                }

                function tS(e, t, n) {
                    return t == t ? function(e, t, n) {
                        for (var r = n - 1, i = e.length; ++r < i;)
                            if (e[r] === t) return r;
                        return -1
                    }(e, t, n) : tw(e, tT, n)
                }

                function tM(e, t, n, r) {
                    for (var i = n - 1, a = e.length; ++i < a;)
                        if (r(e[i], t)) return i;
                    return -1
                }

                function tT(e) {
                    return e != e
                }

                function tA(e, t) {
                    var n = null == e ? 0 : e.length;
                    return n ? tP(e, t) / n : u
                }

                function tE(e) {
                    return function(t) {
                        return null == t ? i : t[e]
                    }
                }

                function tC(e) {
                    return function(t) {
                        return null == e ? i : e[t]
                    }
                }

                function tI(e, t, n, r, i) {
                    return i(e, function(e, i, a) {
                        n = r ? (r = !1, e) : t(n, e, i, a)
                    }), n
                }

                function tP(e, t) {
                    for (var n, r = -1, a = e.length; ++r < a;) {
                        var s = t(e[r]);
                        i !== s && (n = i === n ? s : n + s)
                    }
                    return n
                }

                function tR(e, t) {
                    for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n);
                    return r
                }

                function tL(e) {
                    return e ? e.slice(0, tZ(e) + 1).replace(Q, "") : e
                }

                function tD(e) {
                    return function(t) {
                        return e(t)
                    }
                }

                function tk(e, t) {
                    return tm(t, function(t) {
                        return e[t]
                    })
                }

                function tU(e, t) {
                    return e.has(t)
                }

                function tO(e, t) {
                    for (var n = -1, r = e.length; ++n < r && tS(t, e[n], 0) > -1;);
                    return n
                }

                function tF(e, t) {
                    for (var n = e.length; n-- && tS(t, e[n], 0) > -1;);
                    return n
                }
                var tN = tC({
                        : "A",
                        : "A",
                        : "A",
                        : "A",
                        : "A",
                        : "A",
                        : "a",
                        : "a",
                        : "a",
                        : "a",
                        : "a",
                        : "a",
                        : "C",
                        : "c",
                        : "D",
                        : "d",
                        : "E",
                        : "E",
                        : "E",
                        : "E",
                        : "e",
                        : "e",
                        : "e",
                        : "e",
                        : "I",
                        : "I",
                        : "I",
                        : "I",
                        : "i",
                        : "i",
                        : "i",
                        : "i",
                        : "N",
                        : "n",
                        : "O",
                        : "O",
                        : "O",
                        : "O",
                        : "O",
                        : "O",
                        : "o",
                        : "o",
                        : "o",
                        : "o",
                        : "o",
                        : "o",
                        : "U",
                        : "U",
                        : "U",
                        : "U",
                        : "u",
                        : "u",
                        : "u",
                        : "u",
                        : "Y",
                        : "y",
                        : "y",
                        : "Ae",
                        : "ae",
                        : "Th",
                        : "th",
                        : "ss",
                        : "A",
                        : "A",
                        : "A",
                        : "a",
                        : "a",
                        : "a",
                        : "C",
                        : "C",
                        : "C",
                        : "C",
                        : "c",
                        : "c",
                        : "c",
                        : "c",
                        : "D",
                        : "D",
                        : "d",
                        : "d",
                        : "E",
                        : "E",
                        : "E",
                        : "E",
                        : "E",
                        : "e",
                        : "e",
                        : "e",
                        : "e",
                        : "e",
                        : "G",
                        : "G",
                        : "G",
                        : "G",
                        : "g",
                        : "g",
                        : "g",
                        : "g",
                        : "H",
                        : "H",
                        : "h",
                        : "h",
                        : "I",
                        : "I",
                        : "I",
                        : "I",
                        : "I",
                        : "i",
                        : "i",
                        : "i",
                        : "i",
                        : "i",
                        : "J",
                        : "j",
                        : "K",
                        : "k",
                        : "k",
                        : "L",
                        : "L",
                        : "L",
                        : "L",
                        : "L",
                        : "l",
                        : "l",
                        : "l",
                        : "l",
                        : "l",
                        : "N",
                        : "N",
                        : "N",
                        : "N",
                        : "n",
                        : "n",
                        : "n",
                        : "n",
                        : "O",
                        : "O",
                        : "O",
                        : "o",
                        : "o",
                        : "o",
                        : "R",
                        : "R",
                        : "R",
                        : "r",
                        : "r",
                        : "r",
                        : "S",
                        : "S",
                        : "S",
                        : "S",
                        : "s",
                        : "s",
                        : "s",
                        : "s",
                        : "T",
                        : "T",
                        : "T",
                        : "t",
                        : "t",
                        : "t",
                        : "U",
                        : "U",
                        : "U",
                        : "U",
                        : "U",
                        : "U",
                        : "u",
                        : "u",
                        : "u",
                        : "u",
                        : "u",
                        : "u",
                        : "W",
                        : "w",
                        : "Y",
                        : "y",
                        : "Y",
                        : "Z",
                        : "Z",
                        : "Z",
                        : "z",
                        : "z",
                        : "z",
                        : "IJ",
                        : "ij",
                        : "Oe",
                        : "oe",
                        : "'n",
                        : "s"
                    }),
                    tB = tC({
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    });

                function tz(e) {
                    return "\\" + e0[e]
                }

                function tG(e) {
                    return eZ.test(e)
                }

                function tV(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach(function(e, r) {
                        n[++t] = [r, e]
                    }), n
                }

                function tW(e, t) {
                    return function(n) {
                        return e(t(n))
                    }
                }

                function tH(e, t) {
                    for (var n = -1, r = e.length, i = 0, a = []; ++n < r;) {
                        var s = e[n];
                        (s === t || s === o) && (e[n] = o, a[i++] = n)
                    }
                    return a
                }

                function tj(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach(function(e) {
                        n[++t] = e
                    }), n
                }

                function tq(e) {
                    return tG(e) ? function(e) {
                        for (var t = eq.lastIndex = 0; eq.test(e);) ++t;
                        return t
                    }(e) : tx(e)
                }

                function tX(e) {
                    return tG(e) ? e.match(eq) || [] : e.split("")
                }

                function tZ(e) {
                    for (var t = e.length; t-- && ee.test(e.charAt(t)););
                    return t
                }
                var tY = tC({
                        "&amp;": "&",
                        "&lt;": "<",
                        "&gt;": ">",
                        "&quot;": '"',
                        "&#39;": "'"
                    }),
                    t$ = function e(t) {
                        var n, r, ee, ev, e_ = (t = null == t ? e5 : t$.defaults(e5.Object(), t, t$.pick(e5, e$))).Array,
                            ey = t.Date,
                            ex = t.Error,
                            eb = t.Function,
                            ew = t.Math,
                            eS = t.Object,
                            eM = t.RegExp,
                            eT = t.String,
                            eA = t.TypeError,
                            eE = e_.prototype,
                            eC = eb.prototype,
                            eI = eS.prototype,
                            eP = t["__core-js_shared__"],
                            eR = eC.toString,
                            eL = eI.hasOwnProperty,
                            eD = 0,
                            ek = (n = /[^.]+$/.exec(eP && eP.keys && eP.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "",
                            eU = eI.toString,
                            eO = eR.call(eS),
                            eF = e5._,
                            eN = eM("^" + eR.call(eL).replace(J, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                            eB = e7 ? t.Buffer : i,
                            ez = t.Symbol,
                            eG = t.Uint8Array,
                            eV = eB ? eB.allocUnsafe : i,
                            eW = tW(eS.getPrototypeOf, eS),
                            eq = eS.create,
                            eZ = eI.propertyIsEnumerable,
                            e0 = eE.splice,
                            e3 = ez ? ez.isConcatSpreadable : i,
                            e4 = ez ? ez.iterator : i,
                            e6 = ez ? ez.toStringTag : i,
                            e8 = function() {
                                try {
                                    var e = iy(eS, "defineProperty");
                                    return e({}, "", {}), e
                                } catch (t) {}
                            }(),
                            e9 = t.clearTimeout !== e5.clearTimeout && t.clearTimeout,
                            te = ey && ey.now !== e5.Date.now && ey.now,
                            tx = t.setTimeout !== e5.setTimeout && t.setTimeout,
                            tC = ew.ceil,
                            tJ = ew.floor,
                            tK = eS.getOwnPropertySymbols,
                            tQ = eB ? eB.isBuffer : i,
                            t0 = t.isFinite,
                            t1 = eE.join,
                            t2 = tW(eS.keys, eS),
                            t3 = ew.max,
                            t4 = ew.min,
                            t5 = ey.now,
                            t6 = t.parseInt,
                            t8 = ew.random,
                            t7 = eE.reverse,
                            t9 = iy(t, "DataView"),
                            ne = iy(t, "Map"),
                            nt = iy(t, "Promise"),
                            nn = iy(t, "Set"),
                            nr = iy(t, "WeakMap"),
                            ni = iy(eS, "create"),
                            na = nr && new nr,
                            ns = {},
                            no = iH(t9),
                            nl = iH(ne),
                            nu = iH(nt),
                            nc = iH(nn),
                            nh = iH(nr),
                            nd = ez ? ez.prototype : i,
                            nf = nd ? nd.valueOf : i,
                            np = nd ? nd.toString : i;

                        function nm(e) {
                            if (aJ(e) && !az(e) && !(e instanceof ny)) {
                                if (e instanceof n_) return e;
                                if (eL.call(e, "__wrapped__")) return ij(e)
                            }
                            return new n_(e)
                        }
                        var ng = function() {
                            function e() {}
                            return function(t) {
                                if (!a$(t)) return {};
                                if (eq) return eq(t);
                                e.prototype = t;
                                var n = new e;
                                return e.prototype = i, n
                            }
                        }();

                        function nv() {}

                        function n_(e, t) {
                            this.__wrapped__ = e, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, this.__values__ = i
                        }

                        function ny(e) {
                            this.__wrapped__ = e, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = []
                        }

                        function nx(e) {
                            var t = -1,
                                n = null == e ? 0 : e.length;
                            for (this.clear(); ++t < n;) {
                                var r = e[t];
                                this.set(r[0], r[1])
                            }
                        }

                        function nb(e) {
                            var t = -1,
                                n = null == e ? 0 : e.length;
                            for (this.clear(); ++t < n;) {
                                var r = e[t];
                                this.set(r[0], r[1])
                            }
                        }

                        function nw(e) {
                            var t = -1,
                                n = null == e ? 0 : e.length;
                            for (this.clear(); ++t < n;) {
                                var r = e[t];
                                this.set(r[0], r[1])
                            }
                        }

                        function nS(e) {
                            var t = -1,
                                n = null == e ? 0 : e.length;
                            for (this.__data__ = new nw; ++t < n;) this.add(e[t])
                        }

                        function nM(e) {
                            var t = this.__data__ = new nb(e);
                            this.size = t.size
                        }

                        function nT(e, t) {
                            var n = az(e),
                                r = !n && aB(e),
                                i = !n && !r && aH(e),
                                a = !n && !r && !i && a5(e),
                                s = n || r || i || a,
                                o = s ? tR(e.length, eT) : [],
                                l = o.length;
                            for (var u in e)(t || eL.call(e, u)) && !(s && ("length" == u || i && ("offset" == u || "parent" == u) || a && ("buffer" == u || "byteLength" == u || "byteOffset" == u) || iA(u, l))) && o.push(u);
                            return o
                        }

                        function nA(e) {
                            var t = e.length;
                            return t ? e[rd(0, t - 1)] : i
                        }

                        function nE(e, t) {
                            return iG(rj(e), nO(t, 0, e.length))
                        }

                        function nC(e) {
                            return iG(rj(e))
                        }

                        function nI(e, t, n) {
                            (i === n || aO(e[t], n)) && (i !== n || t in e) || nk(e, t, n)
                        }

                        function nP(e, t, n) {
                            var r = e[t];
                            eL.call(e, t) && aO(r, n) && (i !== n || t in e) || nk(e, t, n)
                        }

                        function nR(e, t) {
                            for (var n = e.length; n--;)
                                if (aO(e[n][0], t)) return n;
                            return -1
                        }

                        function nL(e, t, n, r) {
                            return nG(e, function(e, i, a) {
                                t(r, e, n(e), a)
                            }), r
                        }

                        function nD(e, t) {
                            return e && rq(t, sv(t), e)
                        }

                        function nk(e, t, n) {
                            "__proto__" == t && e8 ? e8(e, t, {
                                configurable: !0,
                                enumerable: !0,
                                value: n,
                                writable: !0
                            }) : e[t] = n
                        }

                        function nU(e, t) {
                            for (var n = -1, r = t.length, a = e_(r), s = null == e; ++n < r;) a[n] = s ? i : sd(e, t[n]);
                            return a
                        }

                        function nO(e, t, n) {
                            return e == e && (i !== n && (e = e <= n ? e : n), i !== t && (e = e >= t ? e : t)), e
                        }

                        function nF(e, t, n, r, a, s) {
                            var o, l = 1 & t,
                                u = 2 & t;
                            if (n && (o = a ? n(e, r, a, s) : n(e)), i !== o) return o;
                            if (!a$(e)) return e;
                            var c = az(e);
                            if (c) {
                                if (m = (d = e).length, b = new d.constructor(m), m && "string" == typeof d[0] && eL.call(d, "index") && (b.index = d.index, b.input = d.input), o = b, !l) return rj(e, o)
                            } else {
                                var d, m, b, A, N, B, z = iw(e),
                                    G = z == g || z == v;
                                if (aH(e)) return rB(e, l);
                                if (z == x || z == h || G && !a) {
                                    if (o = u || G ? {} : iM(e), !l) return u ? (A = (B = o) && rq(e, s_(e), B), rq(e, ib(e), A)) : (N = nD(o, e), rq(e, ix(e), N))
                                } else {
                                    if (!eQ[z]) return a ? e : {};
                                    o = function(e, t, n) {
                                        var r, i, a = e.constructor;
                                        switch (t) {
                                            case E:
                                                return rz(e);
                                            case f:
                                            case p:
                                                return new a(+e);
                                            case C:
                                                return r = n ? rz(e.buffer) : e.buffer, new e.constructor(r, e.byteOffset, e.byteLength);
                                            case I:
                                            case P:
                                            case R:
                                            case L:
                                            case D:
                                            case k:
                                            case U:
                                            case O:
                                            case F:
                                                return rG(e, n);
                                            case _:
                                                return new a;
                                            case y:
                                            case M:
                                                return new a(e);
                                            case w:
                                                return (i = new e.constructor(e.source, el.exec(e))).lastIndex = e.lastIndex, i;
                                            case S:
                                                return new a;
                                            case T:
                                                return nf ? eS(nf.call(e)) : {}
                                        }
                                    }(e, z, l)
                                }
                            }
                            s || (s = new nM);
                            var V = s.get(e);
                            if (V) return V;
                            s.set(e, o), a2(e) ? e.forEach(function(r) {
                                o.add(nF(r, t, n, r, e, s))
                            }) : aK(e) && e.forEach(function(r, i) {
                                o.set(i, nF(r, t, n, i, e, s))
                            });
                            var W = c ? i : (4 & t ? u ? ih : ic : u ? s_ : sv)(e);
                            return tu(W || e, function(r, i) {
                                W && (r = e[i = r]), nP(o, i, nF(r, t, n, i, e, s))
                            }), o
                        }

                        function nN(e, t, n) {
                            var r = n.length;
                            if (null == e) return !r;
                            for (e = eS(e); r--;) {
                                var a = n[r],
                                    s = t[a],
                                    o = e[a];
                                if (i === o && !(a in e) || !s(o)) return !1
                            }
                            return !0
                        }

                        function nB(e, t, n) {
                            if ("function" != typeof e) throw new eA(a);
                            return iF(function() {
                                e.apply(i, n)
                            }, t)
                        }

                        function nz(e, t, n, r) {
                            var i = -1,
                                a = tf,
                                s = !0,
                                o = e.length,
                                l = [],
                                u = t.length;
                            if (!o) return l;
                            n && (t = tm(t, tD(n))), r ? (a = tp, s = !1) : t.length >= 200 && (a = tU, s = !1, t = new nS(t));
                            e: for (; ++i < o;) {
                                var c = e[i],
                                    h = null == n ? c : n(c);
                                if (c = r || 0 !== c ? c : 0, s && h == h) {
                                    for (var d = u; d--;)
                                        if (t[d] === h) continue e;
                                    l.push(c)
                                } else a(t, h, r) || l.push(c)
                            }
                            return l
                        }
                        nm.templateSettings = {
                            escape: j,
                            evaluate: q,
                            interpolate: X,
                            variable: "",
                            imports: {
                                _: nm
                            }
                        }, nm.prototype = nv.prototype, nm.prototype.constructor = nm, n_.prototype = ng(nv.prototype), n_.prototype.constructor = n_, ny.prototype = ng(nv.prototype), ny.prototype.constructor = ny, nx.prototype.clear = function() {
                            this.__data__ = ni ? ni(null) : {}, this.size = 0
                        }, nx.prototype.delete = function(e) {
                            var t = this.has(e) && delete this.__data__[e];
                            return this.size -= t ? 1 : 0, t
                        }, nx.prototype.get = function(e) {
                            var t = this.__data__;
                            if (ni) {
                                var n = t[e];
                                return n === s ? i : n
                            }
                            return eL.call(t, e) ? t[e] : i
                        }, nx.prototype.has = function(e) {
                            var t = this.__data__;
                            return ni ? i !== t[e] : eL.call(t, e)
                        }, nx.prototype.set = function(e, t) {
                            var n = this.__data__;
                            return this.size += this.has(e) ? 0 : 1, n[e] = ni && i === t ? s : t, this
                        }, nb.prototype.clear = function() {
                            this.__data__ = [], this.size = 0
                        }, nb.prototype.delete = function(e) {
                            var t = this.__data__,
                                n = nR(t, e);
                            return !(n < 0) && (n == t.length - 1 ? t.pop() : e0.call(t, n, 1), --this.size, !0)
                        }, nb.prototype.get = function(e) {
                            var t = this.__data__,
                                n = nR(t, e);
                            return n < 0 ? i : t[n][1]
                        }, nb.prototype.has = function(e) {
                            return nR(this.__data__, e) > -1
                        }, nb.prototype.set = function(e, t) {
                            var n = this.__data__,
                                r = nR(n, e);
                            return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this
                        }, nw.prototype.clear = function() {
                            this.size = 0, this.__data__ = {
                                hash: new nx,
                                map: new(ne || nb),
                                string: new nx
                            }
                        }, nw.prototype.delete = function(e) {
                            var t = iv(this, e).delete(e);
                            return this.size -= t ? 1 : 0, t
                        }, nw.prototype.get = function(e) {
                            return iv(this, e).get(e)
                        }, nw.prototype.has = function(e) {
                            return iv(this, e).has(e)
                        }, nw.prototype.set = function(e, t) {
                            var n = iv(this, e),
                                r = n.size;
                            return n.set(e, t), this.size += n.size == r ? 0 : 1, this
                        }, nS.prototype.add = nS.prototype.push = function(e) {
                            return this.__data__.set(e, s), this
                        }, nS.prototype.has = function(e) {
                            return this.__data__.has(e)
                        }, nM.prototype.clear = function() {
                            this.__data__ = new nb, this.size = 0
                        }, nM.prototype.delete = function(e) {
                            var t = this.__data__,
                                n = t.delete(e);
                            return this.size = t.size, n
                        }, nM.prototype.get = function(e) {
                            return this.__data__.get(e)
                        }, nM.prototype.has = function(e) {
                            return this.__data__.has(e)
                        }, nM.prototype.set = function(e, t) {
                            var n = this.__data__;
                            if (n instanceof nb) {
                                var r = n.__data__;
                                if (!ne || r.length < 199) return r.push([e, t]), this.size = ++n.size, this;
                                n = this.__data__ = new nw(r)
                            }
                            return n.set(e, t), this.size = n.size, this
                        };
                        var nG = rY(nY),
                            nV = rY(n$, !0);

                        function nW(e, t) {
                            var n = !0;
                            return nG(e, function(e, r, i) {
                                return n = !!t(e, r, i)
                            }), n
                        }

                        function nH(e, t, n) {
                            for (var r = -1, a = e.length; ++r < a;) {
                                var s = e[r],
                                    o = t(s);
                                if (null != o && (i === l ? o == o && !a4(o) : n(o, l))) var l = o,
                                    u = s
                            }
                            return u
                        }

                        function nj(e, t) {
                            var n = [];
                            return nG(e, function(e, r, i) {
                                t(e, r, i) && n.push(e)
                            }), n
                        }

                        function nq(e, t, n, r, i) {
                            var a = -1,
                                s = e.length;
                            for (n || (n = iT), i || (i = []); ++a < s;) {
                                var o = e[a];
                                t > 0 && n(o) ? t > 1 ? nq(o, t - 1, n, r, i) : tg(i, o) : r || (i[i.length] = o)
                            }
                            return i
                        }
                        var nX = r$(),
                            nZ = r$(!0);

                        function nY(e, t) {
                            return e && nX(e, t, sv)
                        }

                        function n$(e, t) {
                            return e && nZ(e, t, sv)
                        }

                        function nJ(e, t) {
                            return td(t, function(t) {
                                return aX(e[t])
                            })
                        }

                        function nK(e, t) {
                            t = rO(t, e);
                            for (var n = 0, r = t.length; null != e && n < r;) e = e[iW(t[n++])];
                            return n && n == r ? e : i
                        }

                        function nQ(e, t, n) {
                            var r = t(e);
                            return az(e) ? r : tg(r, n(e))
                        }

                        function n0(e) {
                            return null == e ? i === e ? "[object Undefined]" : "[object Null]" : e6 && e6 in eS(e) ? function(e) {
                                var t = eL.call(e, e6),
                                    n = e[e6];
                                try {
                                    e[e6] = i;
                                    var r = !0
                                } catch (a) {}
                                var s = eU.call(e);
                                return r && (t ? e[e6] = n : delete e[e6]), s
                            }(e) : eU.call(e)
                        }

                        function n1(e, t) {
                            return e > t
                        }

                        function n2(e, t) {
                            return null != e && eL.call(e, t)
                        }

                        function n3(e, t) {
                            return null != e && t in eS(e)
                        }

                        function n4(e, t, n) {
                            for (var r = n ? tp : tf, a = e[0].length, s = e.length, o = s, l = e_(s), u = 1 / 0, c = []; o--;) {
                                var h = e[o];
                                o && t && (h = tm(h, tD(t))), u = t4(h.length, u), l[o] = !n && (t || a >= 120 && h.length >= 120) ? new nS(o && h) : i
                            }
                            h = e[0];
                            var d = -1,
                                f = l[0];
                            e: for (; ++d < a && c.length < u;) {
                                var p = h[d],
                                    m = t ? t(p) : p;
                                if (p = n || 0 !== p ? p : 0, !(f ? tU(f, m) : r(c, m, n))) {
                                    for (o = s; --o;) {
                                        var g = l[o];
                                        if (!(g ? tU(g, m) : r(e[o], m, n))) continue e
                                    }
                                    f && f.push(m), c.push(p)
                                }
                            }
                            return c
                        }

                        function n5(e, t, n) {
                            t = rO(t, e);
                            var r = null == (e = ik(e, t)) ? e : e[iW(i2(t))];
                            return null == r ? i : to(r, e, n)
                        }

                        function n6(e) {
                            return aJ(e) && n0(e) == h
                        }

                        function n8(e, t, n, r, a) {
                            return e === t || (null != e && null != t && (aJ(e) || aJ(t)) ? function(e, t, n, r, a, s) {
                                var o = az(e),
                                    l = az(t),
                                    u = o ? d : iw(e),
                                    c = l ? d : iw(t);
                                u = u == h ? x : u, c = c == h ? x : c;
                                var g = u == x,
                                    v = c == x,
                                    b = u == c;
                                if (b && aH(e)) {
                                    if (!aH(t)) return !1;
                                    o = !0, g = !1
                                }
                                if (b && !g) return s || (s = new nM), o || a5(e) ? il(e, t, n, r, a, s) : function(e, t, n, r, i, a, s) {
                                    switch (n) {
                                        case C:
                                            if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) break;
                                            e = e.buffer, t = t.buffer;
                                        case E:
                                            if (e.byteLength != t.byteLength || !a(new eG(e), new eG(t))) break;
                                            return !0;
                                        case f:
                                        case p:
                                        case y:
                                            return aO(+e, +t);
                                        case m:
                                            return e.name == t.name && e.message == t.message;
                                        case w:
                                        case M:
                                            return e == t + "";
                                        case _:
                                            var o = tV;
                                        case S:
                                            var l = 1 & r;
                                            if (o || (o = tj), e.size != t.size && !l) break;
                                            var u = s.get(e);
                                            if (u) return u == t;
                                            r |= 2, s.set(e, t);
                                            var c = il(o(e), o(t), r, i, a, s);
                                            return s.delete(e), c;
                                        case T:
                                            if (nf) return nf.call(e) == nf.call(t)
                                    }
                                    return !1
                                }(e, t, u, n, r, a, s);
                                if (!(1 & n)) {
                                    var A = g && eL.call(e, "__wrapped__"),
                                        I = v && eL.call(t, "__wrapped__");
                                    if (A || I) {
                                        var P = A ? e.value() : e,
                                            R = I ? t.value() : t;
                                        return s || (s = new nM), a(P, R, n, r, s)
                                    }
                                }
                                return !!b && (s || (s = new nM), function(e, t, n, r, a, s) {
                                    var o = 1 & n,
                                        l = ic(e),
                                        u = l.length;
                                    if (u != ic(t).length && !o) return !1;
                                    for (var c = u; c--;) {
                                        var h = l[c];
                                        if (!(o ? h in t : eL.call(t, h))) return !1
                                    }
                                    var d = s.get(e),
                                        f = s.get(t);
                                    if (d && f) return d == t && f == e;
                                    var p = !0;
                                    s.set(e, t), s.set(t, e);
                                    for (var m = o; ++c < u;) {
                                        var g = e[h = l[c]],
                                            v = t[h];
                                        if (r) var _ = o ? r(v, g, h, t, e, s) : r(g, v, h, e, t, s);
                                        if (!(i === _ ? g === v || a(g, v, n, r, s) : _)) {
                                            p = !1;
                                            break
                                        }
                                        m || (m = "constructor" == h)
                                    }
                                    if (p && !m) {
                                        var y = e.constructor,
                                            x = t.constructor;
                                        y != x && "constructor" in e && "constructor" in t && !("function" == typeof y && y instanceof y && "function" == typeof x && x instanceof x) && (p = !1)
                                    }
                                    return s.delete(e), s.delete(t), p
                                }(e, t, n, r, a, s))
                            }(e, t, n, r, n8, a) : e != e && t != t)
                        }

                        function n7(e, t, n, r) {
                            var a = n.length,
                                s = a,
                                o = !r;
                            if (null == e) return !s;
                            for (e = eS(e); a--;) {
                                var l = n[a];
                                if (o && l[2] ? l[1] !== e[l[0]] : !(l[0] in e)) return !1
                            }
                            for (; ++a < s;) {
                                var u = (l = n[a])[0],
                                    c = e[u],
                                    h = l[1];
                                if (o && l[2]) {
                                    if (i === c && !(u in e)) return !1
                                } else {
                                    var d = new nM;
                                    if (r) var f = r(c, h, u, e, t, d);
                                    if (!(i === f ? n8(h, c, 3, r, d) : f)) return !1
                                }
                            }
                            return !0
                        }

                        function n9(e) {
                            return !(!a$(e) || ek && ek in e) && (aX(e) ? eN : eh).test(iH(e))
                        }

                        function re(e) {
                            return "function" == typeof e ? e : null == e ? sW : "object" == typeof e ? az(e) ? ra(e[0], e[1]) : ri(e) : sK(e)
                        }

                        function rt(e) {
                            if (!iR(e)) return t2(e);
                            var t = [];
                            for (var n in eS(e)) eL.call(e, n) && "constructor" != n && t.push(n);
                            return t
                        }

                        function rn(e, t) {
                            return e < t
                        }

                        function rr(e, t) {
                            var n = -1,
                                r = aV(e) ? e_(e.length) : [];
                            return nG(e, function(e, i, a) {
                                r[++n] = t(e, i, a)
                            }), r
                        }

                        function ri(e) {
                            var t = i_(e);
                            return 1 == t.length && t[0][2] ? iL(t[0][0], t[0][1]) : function(n) {
                                return n === e || n7(n, e, t)
                            }
                        }

                        function ra(e, t) {
                            var n;
                            return iC(e) && (n = t) == n && !a$(n) ? iL(iW(e), t) : function(n) {
                                var r = sd(n, e);
                                return i === r && r === t ? sf(n, e) : n8(t, r, 3)
                            }
                        }

                        function rs(e, t, n, r, a) {
                            e !== t && nX(t, function(s, o) {
                                if (a || (a = new nM), a$(s))(function(e, t, n, r, a, s, o) {
                                    var l = iU(e, n),
                                        u = iU(t, n),
                                        c = o.get(u);
                                    if (c) {
                                        nI(e, n, c);
                                        return
                                    }
                                    var h = s ? s(l, u, n + "", e, t, o) : i,
                                        d = i === h;
                                    if (d) {
                                        var f = az(u),
                                            p = !f && aH(u),
                                            m = !f && !p && a5(u);
                                        h = u, f || p || m ? az(l) ? h = l : aW(l) ? h = rj(l) : p ? (d = !1, h = rB(u, !0)) : m ? (d = !1, h = rG(u, !0)) : h = [] : a0(u) || aB(u) ? (h = l, aB(l) ? h = sr(l) : (!a$(l) || aX(l)) && (h = iM(u))) : d = !1
                                    }
                                    d && (o.set(u, h), a(h, u, r, s, o), o.delete(u)), nI(e, n, h)
                                })(e, t, o, n, rs, r, a);
                                else {
                                    var l = r ? r(iU(e, o), s, o + "", e, t, a) : i;
                                    i === l && (l = s), nI(e, o, l)
                                }
                            }, s_)
                        }

                        function ro(e, t) {
                            var n = e.length;
                            if (n) return iA(t += t < 0 ? n : 0, n) ? e[t] : i
                        }

                        function rl(e, t, n) {
                            t = t.length ? tm(t, function(e) {
                                return az(e) ? function(t) {
                                    return nK(t, 1 === e.length ? e[0] : e)
                                } : e
                            }) : [sW];
                            var r = -1;
                            return t = tm(t, tD(ig())),
                                function(e, t) {
                                    var n = e.length;
                                    for (e.sort(t); n--;) e[n] = e[n].value;
                                    return e
                                }(rr(e, function(e, n, i) {
                                    return {
                                        criteria: tm(t, function(t) {
                                            return t(e)
                                        }),
                                        index: ++r,
                                        value: e
                                    }
                                }), function(e, t) {
                                    return function(e, t, n) {
                                        for (var r = -1, i = e.criteria, a = t.criteria, s = i.length, o = n.length; ++r < s;) {
                                            var l = rV(i[r], a[r]);
                                            if (l) {
                                                if (r >= o) return l;
                                                return l * ("desc" == n[r] ? -1 : 1)
                                            }
                                        }
                                        return e.index - t.index
                                    }(e, t, n)
                                })
                        }

                        function ru(e, t, n) {
                            for (var r = -1, i = t.length, a = {}; ++r < i;) {
                                var s = t[r],
                                    o = nK(e, s);
                                n(o, s) && rv(a, rO(s, e), o)
                            }
                            return a
                        }

                        function rc(e, t, n, r) {
                            var i = r ? tM : tS,
                                a = -1,
                                s = t.length,
                                o = e;
                            for (e === t && (t = rj(t)), n && (o = tm(e, tD(n))); ++a < s;)
                                for (var l = 0, u = t[a], c = n ? n(u) : u;
                                    (l = i(o, c, l, r)) > -1;) o !== e && e0.call(o, l, 1), e0.call(e, l, 1);
                            return e
                        }

                        function rh(e, t) {
                            for (var n = e ? t.length : 0, r = n - 1; n--;) {
                                var i = t[n];
                                if (n == r || i !== a) {
                                    var a = i;
                                    iA(i) ? e0.call(e, i, 1) : rC(e, i)
                                }
                            }
                            return e
                        }

                        function rd(e, t) {
                            return e + tJ(t8() * (t - e + 1))
                        }

                        function rf(e, t) {
                            var n = "";
                            if (!e || t < 1 || t > 9007199254740991) return n;
                            do t % 2 && (n += e), (t = tJ(t / 2)) && (e += e); while (t);
                            return n
                        }

                        function rp(e, t) {
                            return iN(iD(e, t, sW), e + "")
                        }

                        function rm(e) {
                            return nA(sA(e))
                        }

                        function rg(e, t) {
                            var n = sA(e);
                            return iG(n, nO(t, 0, n.length))
                        }

                        function rv(e, t, n, r) {
                            if (!a$(e)) return e;
                            t = rO(t, e);
                            for (var a = -1, s = t.length, o = s - 1, l = e; null != l && ++a < s;) {
                                var u = iW(t[a]),
                                    c = n;
                                if ("__proto__" === u || "constructor" === u || "prototype" === u) break;
                                if (a != o) {
                                    var h = l[u];
                                    c = r ? r(h, u, l) : i, i === c && (c = a$(h) ? h : iA(t[a + 1]) ? [] : {})
                                }
                                nP(l, u, c), l = l[u]
                            }
                            return e
                        }
                        var r_ = na ? function(e, t) {
                            return na.set(e, t), e
                        } : sW;

                        function ry(e) {
                            return iG(sA(e))
                        }

                        function rx(e, t, n) {
                            var r = -1,
                                i = e.length;
                            t < 0 && (t = -t > i ? 0 : i + t), (n = n > i ? i : n) < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
                            for (var a = e_(i); ++r < i;) a[r] = e[r + t];
                            return a
                        }

                        function rb(e, t) {
                            var n;
                            return nG(e, function(e, r, i) {
                                return !(n = t(e, r, i))
                            }), !!n
                        }

                        function rw(e, t, n) {
                            var r = 0,
                                i = null == e ? r : e.length;
                            if ("number" == typeof t && t == t && i <= 2147483647) {
                                for (; r < i;) {
                                    var a = r + i >>> 1,
                                        s = e[a];
                                    null !== s && !a4(s) && (n ? s <= t : s < t) ? r = a + 1 : i = a
                                }
                                return i
                            }
                            return rS(e, t, sW, n)
                        }

                        function rS(e, t, n, r) {
                            var a = 0,
                                s = null == e ? 0 : e.length;
                            if (0 === s) return 0;
                            for (var o = (t = n(t)) != t, l = null === t, u = a4(t), c = i === t; a < s;) {
                                var h = tJ((a + s) / 2),
                                    d = n(e[h]),
                                    f = i !== d,
                                    p = null === d,
                                    m = d == d,
                                    g = a4(d);
                                if (o) var v = r || m;
                                else v = c ? m && (r || f) : l ? m && f && (r || !p) : u ? m && f && !p && (r || !g) : !p && !g && (r ? d <= t : d < t);
                                v ? a = h + 1 : s = h
                            }
                            return t4(s, 4294967294)
                        }

                        function rM(e, t) {
                            for (var n = -1, r = e.length, i = 0, a = []; ++n < r;) {
                                var s = e[n],
                                    o = t ? t(s) : s;
                                if (!n || !aO(o, l)) {
                                    var l = o;
                                    a[i++] = 0 === s ? 0 : s
                                }
                            }
                            return a
                        }

                        function rT(e) {
                            return "number" == typeof e ? e : a4(e) ? u : +e
                        }

                        function rA(e) {
                            if ("string" == typeof e) return e;
                            if (az(e)) return tm(e, rA) + "";
                            if (a4(e)) return np ? np.call(e) : "";
                            var t = e + "";
                            return "0" == t && 1 / e == -l ? "-0" : t
                        }

                        function rE(e, t, n) {
                            var r = -1,
                                i = tf,
                                a = e.length,
                                s = !0,
                                o = [],
                                l = o;
                            if (n) s = !1, i = tp;
                            else if (a >= 200) {
                                var u = t ? null : it(e);
                                if (u) return tj(u);
                                s = !1, i = tU, l = new nS
                            } else l = t ? [] : o;
                            e: for (; ++r < a;) {
                                var c = e[r],
                                    h = t ? t(c) : c;
                                if (c = n || 0 !== c ? c : 0, s && h == h) {
                                    for (var d = l.length; d--;)
                                        if (l[d] === h) continue e;
                                    t && l.push(h), o.push(c)
                                } else i(l, h, n) || (l !== o && l.push(h), o.push(c))
                            }
                            return o
                        }

                        function rC(e, t) {
                            return t = rO(t, e), null == (e = ik(e, t)) || delete e[iW(i2(t))]
                        }

                        function rI(e, t, n, r) {
                            return rv(e, t, n(nK(e, t)), r)
                        }

                        function rP(e, t, n, r) {
                            for (var i = e.length, a = r ? i : -1;
                                (r ? a-- : ++a < i) && t(e[a], a, e););
                            return n ? rx(e, r ? 0 : a, r ? a + 1 : i) : rx(e, r ? a + 1 : 0, r ? i : a)
                        }

                        function rR(e, t) {
                            var n = e;
                            return n instanceof ny && (n = n.value()), tv(t, function(e, t) {
                                return t.func.apply(t.thisArg, tg([e], t.args))
                            }, n)
                        }

                        function rL(e, t, n) {
                            var r = e.length;
                            if (r < 2) return r ? rE(e[0]) : [];
                            for (var i = -1, a = e_(r); ++i < r;)
                                for (var s = e[i], o = -1; ++o < r;) o != i && (a[i] = nz(a[i] || s, e[o], t, n));
                            return rE(nq(a, 1), t, n)
                        }

                        function rD(e, t, n) {
                            for (var r = -1, a = e.length, s = t.length, o = {}; ++r < a;) {
                                var l = r < s ? t[r] : i;
                                n(o, e[r], l)
                            }
                            return o
                        }

                        function rk(e) {
                            return aW(e) ? e : []
                        }

                        function rU(e) {
                            return "function" == typeof e ? e : sW
                        }

                        function rO(e, t) {
                            return az(e) ? e : iC(e, t) ? [e] : iV(si(e))
                        }

                        function rF(e, t, n) {
                            var r = e.length;
                            return n = i === n ? r : n, !t && n >= r ? e : rx(e, t, n)
                        }
                        var rN = e9 || function(e) {
                            return e5.clearTimeout(e)
                        };

                        function rB(e, t) {
                            if (t) return e.slice();
                            var n = e.length,
                                r = eV ? eV(n) : new e.constructor(n);
                            return e.copy(r), r
                        }

                        function rz(e) {
                            var t = new e.constructor(e.byteLength);
                            return new eG(t).set(new eG(e)), t
                        }

                        function rG(e, t) {
                            var n = t ? rz(e.buffer) : e.buffer;
                            return new e.constructor(n, e.byteOffset, e.length)
                        }

                        function rV(e, t) {
                            if (e !== t) {
                                var n = i !== e,
                                    r = null === e,
                                    a = e == e,
                                    s = a4(e),
                                    o = i !== t,
                                    l = null === t,
                                    u = t == t,
                                    c = a4(t);
                                if (!l && !c && !s && e > t || s && o && u && !l && !c || r && o && u || !n && u || !a) return 1;
                                if (!r && !s && !c && e < t || c && n && a && !r && !s || l && n && a || !o && a || !u) return -1
                            }
                            return 0
                        }

                        function rW(e, t, n, r) {
                            for (var i = -1, a = e.length, s = n.length, o = -1, l = t.length, u = t3(a - s, 0), c = e_(l + u), h = !r; ++o < l;) c[o] = t[o];
                            for (; ++i < s;)(h || i < a) && (c[n[i]] = e[i]);
                            for (; u--;) c[o++] = e[i++];
                            return c
                        }

                        function rH(e, t, n, r) {
                            for (var i = -1, a = e.length, s = -1, o = n.length, l = -1, u = t.length, c = t3(a - o, 0), h = e_(c + u), d = !r; ++i < c;) h[i] = e[i];
                            for (var f = i; ++l < u;) h[f + l] = t[l];
                            for (; ++s < o;)(d || i < a) && (h[f + n[s]] = e[i++]);
                            return h
                        }

                        function rj(e, t) {
                            var n = -1,
                                r = e.length;
                            for (t || (t = e_(r)); ++n < r;) t[n] = e[n];
                            return t
                        }

                        function rq(e, t, n, r) {
                            var a = !n;
                            n || (n = {});
                            for (var s = -1, o = t.length; ++s < o;) {
                                var l = t[s],
                                    u = r ? r(n[l], e[l], l, n, e) : i;
                                i === u && (u = e[l]), a ? nk(n, l, u) : nP(n, l, u)
                            }
                            return n
                        }

                        function rX(e, t) {
                            return function(n, r) {
                                var i = az(n) ? tl : nL,
                                    a = t ? t() : {};
                                return i(n, e, ig(r, 2), a)
                            }
                        }

                        function rZ(e) {
                            return rp(function(t, n) {
                                var r = -1,
                                    a = n.length,
                                    s = a > 1 ? n[a - 1] : i,
                                    o = a > 2 ? n[2] : i;
                                for (s = e.length > 3 && "function" == typeof s ? (a--, s) : i, o && iE(n[0], n[1], o) && (s = a < 3 ? i : s, a = 1), t = eS(t); ++r < a;) {
                                    var l = n[r];
                                    l && e(t, l, r, s)
                                }
                                return t
                            })
                        }

                        function rY(e, t) {
                            return function(n, r) {
                                if (null == n) return n;
                                if (!aV(n)) return e(n, r);
                                for (var i = n.length, a = t ? i : -1, s = eS(n);
                                    (t ? a-- : ++a < i) && !1 !== r(s[a], a, s););
                                return n
                            }
                        }

                        function r$(e) {
                            return function(t, n, r) {
                                for (var i = -1, a = eS(t), s = r(t), o = s.length; o--;) {
                                    var l = s[e ? o : ++i];
                                    if (!1 === n(a[l], l, a)) break
                                }
                                return t
                            }
                        }

                        function rJ(e) {
                            return function(t) {
                                var n = tG(t = si(t)) ? tX(t) : i,
                                    r = n ? n[0] : t.charAt(0),
                                    a = n ? rF(n, 1).join("") : t.slice(1);
                                return r[e]() + a
                            }
                        }

                        function rK(e) {
                            return function(t) {
                                return tv(sF(sI(t).replace(eH, "")), e, "")
                            }
                        }

                        function rQ(e) {
                            return function() {
                                var t = arguments;
                                switch (t.length) {
                                    case 0:
                                        return new e;
                                    case 1:
                                        return new e(t[0]);
                                    case 2:
                                        return new e(t[0], t[1]);
                                    case 3:
                                        return new e(t[0], t[1], t[2]);
                                    case 4:
                                        return new e(t[0], t[1], t[2], t[3]);
                                    case 5:
                                        return new e(t[0], t[1], t[2], t[3], t[4]);
                                    case 6:
                                        return new e(t[0], t[1], t[2], t[3], t[4], t[5]);
                                    case 7:
                                        return new e(t[0], t[1], t[2], t[3], t[4], t[5], t[6])
                                }
                                var n = ng(e.prototype),
                                    r = e.apply(n, t);
                                return a$(r) ? r : n
                            }
                        }

                        function r0(e) {
                            return function(t, n, r) {
                                var a = eS(t);
                                if (!aV(t)) {
                                    var s = ig(n, 3);
                                    t = sv(t), n = function(e) {
                                        return s(a[e], e, a)
                                    }
                                }
                                var o = e(t, n, r);
                                return o > -1 ? a[s ? t[o] : o] : i
                            }
                        }

                        function r1(e) {
                            return iu(function(t) {
                                var n = t.length,
                                    r = n,
                                    s = n_.prototype.thru;
                                for (e && t.reverse(); r--;) {
                                    var o = t[r];
                                    if ("function" != typeof o) throw new eA(a);
                                    if (s && !l && "wrapper" == ip(o)) var l = new n_([], !0)
                                }
                                for (r = l ? r : n; ++r < n;) {
                                    var u = ip(o = t[r]),
                                        c = "wrapper" == u ? id(o) : i;
                                    l = c && iI(c[0]) && 424 == c[1] && !c[4].length && 1 == c[9] ? l[ip(c[0])].apply(l, c[3]) : 1 == o.length && iI(o) ? l[u]() : l.thru(o)
                                }
                                return function() {
                                    var e = arguments,
                                        r = e[0];
                                    if (l && 1 == e.length && az(r)) return l.plant(r).value();
                                    for (var i = 0, a = n ? t[i].apply(this, e) : r; ++i < n;) a = t[i].call(this, a);
                                    return a
                                }
                            })
                        }

                        function r2(e, t, n, r, a, s, o, l, u, c) {
                            var h = 128 & t,
                                d = 1 & t,
                                f = 2 & t,
                                p = 24 & t,
                                m = 512 & t,
                                g = f ? i : rQ(e);
                            return function v() {
                                for (var _ = arguments.length, y = e_(_), x = _; x--;) y[x] = arguments[x];
                                if (p) var b = im(v),
                                    w = function(e, t) {
                                        for (var n = e.length, r = 0; n--;) e[n] === t && ++r;
                                        return r
                                    }(y, b);
                                if (r && (y = rW(y, r, a, p)), s && (y = rH(y, s, o, p)), _ -= w, p && _ < c) {
                                    var S = tH(y, b);
                                    return r9(e, t, r2, v.placeholder, n, y, S, l, u, c - _)
                                }
                                var M = d ? n : this,
                                    T = f ? M[e] : e;
                                return _ = y.length, l ? y = function(e, t) {
                                    for (var n = e.length, r = t4(t.length, n), a = rj(e); r--;) {
                                        var s = t[r];
                                        e[r] = iA(s, n) ? a[s] : i
                                    }
                                    return e
                                }(y, l) : m && _ > 1 && y.reverse(), h && u < _ && (y.length = u), this && this !== e5 && this instanceof v && (T = g || rQ(T)), T.apply(M, y)
                            }
                        }

                        function r3(e, t) {
                            return function(n, r) {
                                var i, a;
                                return i = t(r), a = {}, nY(n, function(t, n, r) {
                                    e(a, i(t), n, r)
                                }), a
                            }
                        }

                        function r4(e, t) {
                            return function(n, r) {
                                var a;
                                if (i === n && i === r) return t;
                                if (i !== n && (a = n), i !== r) {
                                    if (i === a) return r;
                                    "string" == typeof n || "string" == typeof r ? (n = rA(n), r = rA(r)) : (n = rT(n), r = rT(r)), a = e(n, r)
                                }
                                return a
                            }
                        }

                        function r5(e) {
                            return iu(function(t) {
                                return t = tm(t, tD(ig())), rp(function(n) {
                                    var r = this;
                                    return e(t, function(e) {
                                        return to(e, r, n)
                                    })
                                })
                            })
                        }

                        function r6(e, t) {
                            var n = (t = i === t ? " " : rA(t)).length;
                            if (n < 2) return n ? rf(t, e) : t;
                            var r = rf(t, tC(e / tq(t)));
                            return tG(t) ? rF(tX(r), 0, e).join("") : r.slice(0, e)
                        }

                        function r8(e) {
                            return function(t, n, r) {
                                return r && "number" != typeof r && iE(t, n, r) && (n = r = i), t = a9(t), i === n ? (n = t, t = 0) : n = a9(n), r = i === r ? t < n ? 1 : -1 : a9(r),
                                    function(e, t, n, r) {
                                        for (var i = -1, a = t3(tC((t - e) / (n || 1)), 0), s = e_(a); a--;) s[r ? a : ++i] = e, e += n;
                                        return s
                                    }(t, n, r, e)
                            }
                        }

                        function r7(e) {
                            return function(t, n) {
                                return "string" == typeof t && "string" == typeof n || (t = sn(t), n = sn(n)), e(t, n)
                            }
                        }

                        function r9(e, t, n, r, a, s, o, l, u, c) {
                            var h = 8 & t;
                            t |= h ? 32 : 64, 4 & (t &= ~(h ? 64 : 32)) || (t &= -4);
                            var d = [e, t, a, h ? s : i, h ? o : i, h ? i : s, h ? i : o, l, u, c],
                                f = n.apply(i, d);
                            return iI(e) && iO(f, d), f.placeholder = r, iB(f, e, t)
                        }

                        function ie(e) {
                            var t = ew[e];
                            return function(e, n) {
                                if (e = sn(e), (n = null == n ? 0 : t4(se(n), 292)) && t0(e)) {
                                    var r = (si(e) + "e").split("e");
                                    return +((r = (si(t(r[0] + "e" + (+r[1] + n))) + "e").split("e"))[0] + "e" + (+r[1] - n))
                                }
                                return t(e)
                            }
                        }
                        var it = nn && 1 / tj(new nn([, -0]))[1] == l ? function(e) {
                            return new nn(e)
                        } : sZ;

                        function ir(e) {
                            return function(t) {
                                var n, r, i = iw(t);
                                return i == _ ? tV(t) : i == S ? (n = -1, r = Array(t.size), t.forEach(function(e) {
                                    r[++n] = [e, e]
                                }), r) : tm(e(t), function(e) {
                                    return [e, t[e]]
                                })
                            }
                        }

                        function ii(e, t, n, r, s, l, u, c) {
                            var h = 2 & t;
                            if (!h && "function" != typeof e) throw new eA(a);
                            var d = r ? r.length : 0;
                            if (d || (t &= -97, r = s = i), u = i === u ? u : t3(se(u), 0), c = i === c ? c : se(c), d -= s ? s.length : 0, 64 & t) {
                                var f = r,
                                    p = s;
                                r = s = i
                            }
                            var m = h ? i : id(e),
                                g = [e, t, n, r, s, f, p, l, u, c];
                            if (m && function(e, t) {
                                    var n = e[1],
                                        r = t[1],
                                        i = n | r,
                                        a = i < 131,
                                        s = 128 == r && 8 == n || 128 == r && 256 == n && e[7].length <= t[8] || 384 == r && t[7].length <= t[8] && 8 == n;
                                    if (a || s) {
                                        1 & r && (e[2] = t[2], i |= 1 & n ? 0 : 4);
                                        var l = t[3];
                                        if (l) {
                                            var u = e[3];
                                            e[3] = u ? rW(u, l, t[4]) : l, e[4] = u ? tH(e[3], o) : t[4]
                                        }(l = t[5]) && (u = e[5], e[5] = u ? rH(u, l, t[6]) : l, e[6] = u ? tH(e[5], o) : t[6]), (l = t[7]) && (e[7] = l), 128 & r && (e[8] = null == e[8] ? t[8] : t4(e[8], t[8])), null == e[9] && (e[9] = t[9]), e[0] = t[0], e[1] = i
                                    }
                                }(g, m), e = g[0], t = g[1], n = g[2], r = g[3], s = g[4], (c = g[9] = i === g[9] ? h ? 0 : e.length : t3(g[9] - d, 0)) || !(24 & t) || (t &= -25), t && 1 != t) 8 == t || 16 == t ? (v = e, _ = t, y = c, x = rQ(v), L = function e() {
                                for (var t = arguments.length, n = e_(t), r = t, a = im(e); r--;) n[r] = arguments[r];
                                var s = t < 3 && n[0] !== a && n[t - 1] !== a ? [] : tH(n, a);
                                return (t -= s.length) < y ? r9(v, _, r2, e.placeholder, i, n, s, i, i, y - t) : to(this && this !== e5 && this instanceof e ? x : v, this, n)
                            }) : 32 != t && 33 != t || s.length ? L = r2.apply(i, g) : (b = e, w = t, S = n, M = r, T = 1 & w, A = rQ(b), L = function e() {
                                for (var t = -1, n = arguments.length, r = -1, i = M.length, a = e_(i + n), s = this && this !== e5 && this instanceof e ? A : b; ++r < i;) a[r] = M[r];
                                for (; n--;) a[r++] = arguments[++t];
                                return to(s, T ? S : this, a)
                            });
                            else var v, _, y, x, b, w, S, M, T, A, E, C, I, P, R, L = (E = e, C = t, I = n, P = 1 & C, R = rQ(E), function e() {
                                return (this && this !== e5 && this instanceof e ? R : E).apply(P ? I : this, arguments)
                            });
                            return iB((m ? r_ : iO)(L, g), e, t)
                        }

                        function ia(e, t, n, r) {
                            return i === e || aO(e, eI[n]) && !eL.call(r, n) ? t : e
                        }

                        function is(e, t, n, r, a, s) {
                            return a$(e) && a$(t) && (s.set(t, e), rs(e, t, i, is, s), s.delete(t)), e
                        }

                        function io(e) {
                            return a0(e) ? i : e
                        }

                        function il(e, t, n, r, a, s) {
                            var o = 1 & n,
                                l = e.length,
                                u = t.length;
                            if (l != u && !(o && u > l)) return !1;
                            var c = s.get(e),
                                h = s.get(t);
                            if (c && h) return c == t && h == e;
                            var d = -1,
                                f = !0,
                                p = 2 & n ? new nS : i;
                            for (s.set(e, t), s.set(t, e); ++d < l;) {
                                var m = e[d],
                                    g = t[d];
                                if (r) var v = o ? r(g, m, d, t, e, s) : r(m, g, d, e, t, s);
                                if (i !== v) {
                                    if (v) continue;
                                    f = !1;
                                    break
                                }
                                if (p) {
                                    if (!ty(t, function(e, t) {
                                            if (!tU(p, t) && (m === e || a(m, e, n, r, s))) return p.push(t)
                                        })) {
                                        f = !1;
                                        break
                                    }
                                } else if (!(m === g || a(m, g, n, r, s))) {
                                    f = !1;
                                    break
                                }
                            }
                            return s.delete(e), s.delete(t), f
                        }

                        function iu(e) {
                            return iN(iD(e, i, iJ), e + "")
                        }

                        function ic(e) {
                            return nQ(e, sv, ix)
                        }

                        function ih(e) {
                            return nQ(e, s_, ib)
                        }
                        var id = na ? function(e) {
                            return na.get(e)
                        } : sZ;

                        function ip(e) {
                            for (var t = e.name + "", n = ns[t], r = eL.call(ns, t) ? n.length : 0; r--;) {
                                var i = n[r],
                                    a = i.func;
                                if (null == a || a == e) return i.name
                            }
                            return t
                        }

                        function im(e) {
                            return (eL.call(nm, "placeholder") ? nm : e).placeholder
                        }

                        function ig() {
                            var e = nm.iteratee || sH;
                            return e = e === sH ? re : e, arguments.length ? e(arguments[0], arguments[1]) : e
                        }

                        function iv(e, t) {
                            var n, r = e.__data__;
                            return ("string" == (n = typeof t) || "number" == n || "symbol" == n || "boolean" == n ? "__proto__" !== t : null === t) ? r["string" == typeof t ? "string" : "hash"] : r.map
                        }

                        function i_(e) {
                            for (var t = sv(e), n = t.length; n--;) {
                                var r = t[n],
                                    i = e[r];
                                t[n] = [r, i, i == i && !a$(i)]
                            }
                            return t
                        }

                        function iy(e, t) {
                            var n = null == e ? i : e[t];
                            return n9(n) ? n : i
                        }
                        var ix = tK ? function(e) {
                                return null == e ? [] : td(tK(e = eS(e)), function(t) {
                                    return eZ.call(e, t)
                                })
                            } : s1,
                            ib = tK ? function(e) {
                                for (var t = []; e;) tg(t, ix(e)), e = eW(e);
                                return t
                            } : s1,
                            iw = n0;

                        function iS(e, t, n) {
                            t = rO(t, e);
                            for (var r = -1, i = t.length, a = !1; ++r < i;) {
                                var s = iW(t[r]);
                                if (!(a = null != e && n(e, s))) break;
                                e = e[s]
                            }
                            return a || ++r != i ? a : !!(i = null == e ? 0 : e.length) && aY(i) && iA(s, i) && (az(e) || aB(e))
                        }

                        function iM(e) {
                            return "function" != typeof e.constructor || iR(e) ? {} : ng(eW(e))
                        }

                        function iT(e) {
                            return az(e) || aB(e) || !!(e3 && e && e[e3])
                        }

                        function iA(e, t) {
                            var n = typeof e;
                            return !!(t = null == t ? 9007199254740991 : t) && ("number" == n || "symbol" != n && ef.test(e)) && e > -1 && e % 1 == 0 && e < t
                        }

                        function iE(e, t, n) {
                            if (!a$(n)) return !1;
                            var r = typeof t;
                            return ("number" == r ? !!(aV(n) && iA(t, n.length)) : "string" == r && t in n) && aO(n[t], e)
                        }

                        function iC(e, t) {
                            if (az(e)) return !1;
                            var n = typeof e;
                            return !!("number" == n || "symbol" == n || "boolean" == n || null == e || a4(e)) || Y.test(e) || !Z.test(e) || null != t && e in eS(t)
                        }

                        function iI(e) {
                            var t = ip(e),
                                n = nm[t];
                            if ("function" != typeof n || !(t in ny.prototype)) return !1;
                            if (e === n) return !0;
                            var r = id(n);
                            return !!r && e === r[0]
                        }(t9 && iw(new t9(new ArrayBuffer(1))) != C || ne && iw(new ne) != _ || nt && iw(nt.resolve()) != b || nn && iw(new nn) != S || nr && iw(new nr) != A) && (iw = function(e) {
                            var t = n0(e),
                                n = t == x ? e.constructor : i,
                                r = n ? iH(n) : "";
                            if (r) switch (r) {
                                case no:
                                    return C;
                                case nl:
                                    return _;
                                case nu:
                                    return b;
                                case nc:
                                    return S;
                                case nh:
                                    return A
                            }
                            return t
                        });
                        var iP = eP ? aX : s2;

                        function iR(e) {
                            var t = e && e.constructor,
                                n = "function" == typeof t && t.prototype || eI;
                            return e === n
                        }

                        function iL(e, t) {
                            return function(n) {
                                return null != n && n[e] === t && (i !== t || e in eS(n))
                            }
                        }

                        function iD(e, t, n) {
                            return t = t3(i === t ? e.length - 1 : t, 0),
                                function() {
                                    for (var r = arguments, i = -1, a = t3(r.length - t, 0), s = e_(a); ++i < a;) s[i] = r[t + i];
                                    i = -1;
                                    for (var o = e_(t + 1); ++i < t;) o[i] = r[i];
                                    return o[t] = n(s), to(e, this, o)
                                }
                        }

                        function ik(e, t) {
                            return t.length < 2 ? e : nK(e, rx(t, 0, -1))
                        }

                        function iU(e, t) {
                            if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t) return e[t]
                        }
                        var iO = iz(r_),
                            iF = tx || function(e, t) {
                                return e5.setTimeout(e, t)
                            },
                            iN = iz(e8 ? function(e, t) {
                                return e8(e, "toString", {
                                    configurable: !0,
                                    enumerable: !1,
                                    value: sz(t),
                                    writable: !0
                                })
                            } : sW);

                        function iB(e, t, n) {
                            var r, i, a = t + "";
                            return iN(e, function(e, t) {
                                var n = t.length;
                                if (!n) return e;
                                var r = n - 1;
                                return t[r] = (n > 1 ? "& " : "") + t[r], t = t.join(n > 2 ? ", " : " "), e.replace(et, "{\n/* [wrapped with " + t + "] */\n")
                            }(a, (r = (i = a.match(en)) ? i[1].split(er) : [], tu(c, function(e) {
                                var t = "_." + e[0];
                                n & e[1] && !tf(r, t) && r.push(t)
                            }), r.sort())))
                        }

                        function iz(e) {
                            var t = 0,
                                n = 0;
                            return function() {
                                var r = t5(),
                                    a = 16 - (r - n);
                                if (n = r, a > 0) {
                                    if (++t >= 800) return arguments[0]
                                } else t = 0;
                                return e.apply(i, arguments)
                            }
                        }

                        function iG(e, t) {
                            var n = -1,
                                r = e.length,
                                a = r - 1;
                            for (t = i === t ? r : t; ++n < t;) {
                                var s = rd(n, a),
                                    o = e[s];
                                e[s] = e[n], e[n] = o
                            }
                            return e.length = t, e
                        }
                        var iV = (ee = (r = aP(function(e) {
                            var t = [];
                            return 46 === e.charCodeAt(0) && t.push(""), e.replace($, function(e, n, r, i) {
                                t.push(r ? i.replace(es, "$1") : n || e)
                            }), t
                        }, function(e) {
                            return 500 === ee.size && ee.clear(), e
                        })).cache, r);

                        function iW(e) {
                            if ("string" == typeof e || a4(e)) return e;
                            var t = e + "";
                            return "0" == t && 1 / e == -l ? "-0" : t
                        }

                        function iH(e) {
                            if (null != e) {
                                try {
                                    return eR.call(e)
                                } catch (t) {}
                                try {
                                    return e + ""
                                } catch (n) {}
                            }
                            return ""
                        }

                        function ij(e) {
                            if (e instanceof ny) return e.clone();
                            var t = new n_(e.__wrapped__, e.__chain__);
                            return t.__actions__ = rj(e.__actions__), t.__index__ = e.__index__, t.__values__ = e.__values__, t
                        }
                        var iq = rp(function(e, t) {
                                return aW(e) ? nz(e, nq(t, 1, aW, !0)) : []
                            }),
                            iX = rp(function(e, t) {
                                var n = i2(t);
                                return aW(n) && (n = i), aW(e) ? nz(e, nq(t, 1, aW, !0), ig(n, 2)) : []
                            }),
                            iZ = rp(function(e, t) {
                                var n = i2(t);
                                return aW(n) && (n = i), aW(e) ? nz(e, nq(t, 1, aW, !0), i, n) : []
                            });

                        function iY(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            if (!r) return -1;
                            var i = null == n ? 0 : se(n);
                            return i < 0 && (i = t3(r + i, 0)), tw(e, ig(t, 3), i)
                        }

                        function i$(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            if (!r) return -1;
                            var a = r - 1;
                            return i !== n && (a = se(n), a = n < 0 ? t3(r + a, 0) : t4(a, r - 1)), tw(e, ig(t, 3), a, !0)
                        }

                        function iJ(e) {
                            return (null == e ? 0 : e.length) ? nq(e, 1) : []
                        }

                        function iK(e) {
                            return e && e.length ? e[0] : i
                        }
                        var iQ = rp(function(e) {
                                var t = tm(e, rk);
                                return t.length && t[0] === e[0] ? n4(t) : []
                            }),
                            i0 = rp(function(e) {
                                var t = i2(e),
                                    n = tm(e, rk);
                                return t === i2(n) ? t = i : n.pop(), n.length && n[0] === e[0] ? n4(n, ig(t, 2)) : []
                            }),
                            i1 = rp(function(e) {
                                var t = i2(e),
                                    n = tm(e, rk);
                                return (t = "function" == typeof t ? t : i) && n.pop(), n.length && n[0] === e[0] ? n4(n, i, t) : []
                            });

                        function i2(e) {
                            var t = null == e ? 0 : e.length;
                            return t ? e[t - 1] : i
                        }
                        var i3 = rp(i4);

                        function i4(e, t) {
                            return e && e.length && t && t.length ? rc(e, t) : e
                        }
                        var i5 = iu(function(e, t) {
                            var n = null == e ? 0 : e.length,
                                r = nU(e, t);
                            return rh(e, tm(t, function(e) {
                                return iA(e, n) ? +e : e
                            }).sort(rV)), r
                        });

                        function i6(e) {
                            return null == e ? e : t7.call(e)
                        }
                        var i8 = rp(function(e) {
                                return rE(nq(e, 1, aW, !0))
                            }),
                            i7 = rp(function(e) {
                                var t = i2(e);
                                return aW(t) && (t = i), rE(nq(e, 1, aW, !0), ig(t, 2))
                            }),
                            i9 = rp(function(e) {
                                var t = i2(e);
                                return t = "function" == typeof t ? t : i, rE(nq(e, 1, aW, !0), i, t)
                            });

                        function ae(e) {
                            if (!(e && e.length)) return [];
                            var t = 0;
                            return e = td(e, function(e) {
                                if (aW(e)) return t = t3(e.length, t), !0
                            }), tR(t, function(t) {
                                return tm(e, tE(t))
                            })
                        }

                        function at(e, t) {
                            if (!(e && e.length)) return [];
                            var n = ae(e);
                            return null == t ? n : tm(n, function(e) {
                                return to(t, i, e)
                            })
                        }
                        var an = rp(function(e, t) {
                                return aW(e) ? nz(e, t) : []
                            }),
                            ar = rp(function(e) {
                                return rL(td(e, aW))
                            }),
                            ai = rp(function(e) {
                                var t = i2(e);
                                return aW(t) && (t = i), rL(td(e, aW), ig(t, 2))
                            }),
                            aa = rp(function(e) {
                                var t = i2(e);
                                return t = "function" == typeof t ? t : i, rL(td(e, aW), i, t)
                            }),
                            as = rp(ae),
                            ao = rp(function(e) {
                                var t = e.length,
                                    n = t > 1 ? e[t - 1] : i;
                                return n = "function" == typeof n ? (e.pop(), n) : i, at(e, n)
                            });

                        function al(e) {
                            var t = nm(e);
                            return t.__chain__ = !0, t
                        }

                        function au(e, t) {
                            return t(e)
                        }
                        var ac = iu(function(e) {
                                var t = e.length,
                                    n = t ? e[0] : 0,
                                    r = this.__wrapped__,
                                    a = function(t) {
                                        return nU(t, e)
                                    };
                                return !(t > 1) && !this.__actions__.length && r instanceof ny && iA(n) ? ((r = r.slice(n, +n + (t ? 1 : 0))).__actions__.push({
                                    func: au,
                                    args: [a],
                                    thisArg: i
                                }), new n_(r, this.__chain__).thru(function(e) {
                                    return t && !e.length && e.push(i), e
                                })) : this.thru(a)
                            }),
                            ah = rX(function(e, t, n) {
                                eL.call(e, n) ? ++e[n] : nk(e, n, 1)
                            }),
                            ad = r0(iY),
                            af = r0(i$);

                        function ap(e, t) {
                            return (az(e) ? tu : nG)(e, ig(t, 3))
                        }

                        function am(e, t) {
                            return (az(e) ? tc : nV)(e, ig(t, 3))
                        }
                        var ag = rX(function(e, t, n) {
                                eL.call(e, n) ? e[n].push(t) : nk(e, n, [t])
                            }),
                            av = rp(function(e, t, n) {
                                var r = -1,
                                    i = "function" == typeof t,
                                    a = aV(e) ? e_(e.length) : [];
                                return nG(e, function(e) {
                                    a[++r] = i ? to(t, e, n) : n5(e, t, n)
                                }), a
                            }),
                            a_ = rX(function(e, t, n) {
                                nk(e, n, t)
                            });

                        function ay(e, t) {
                            return (az(e) ? tm : rr)(e, ig(t, 3))
                        }
                        var ax = rX(function(e, t, n) {
                                e[n ? 0 : 1].push(t)
                            }, function() {
                                return [
                                    [],
                                    []
                                ]
                            }),
                            ab = rp(function(e, t) {
                                if (null == e) return [];
                                var n = t.length;
                                return n > 1 && iE(e, t[0], t[1]) ? t = [] : n > 2 && iE(t[0], t[1], t[2]) && (t = [t[0]]), rl(e, nq(t, 1), [])
                            }),
                            aw = te || function() {
                                return e5.Date.now()
                            };

                        function aS(e, t, n) {
                            return t = n ? i : t, t = e && null == t ? e.length : t, ii(e, 128, i, i, i, i, t)
                        }

                        function aM(e, t) {
                            var n;
                            if ("function" != typeof t) throw new eA(a);
                            return e = se(e),
                                function() {
                                    return --e > 0 && (n = t.apply(this, arguments)), e <= 1 && (t = i), n
                                }
                        }
                        var aT = rp(function(e, t, n) {
                                var r = 1;
                                if (n.length) {
                                    var i = tH(n, im(aT));
                                    r |= 32
                                }
                                return ii(e, r, t, n, i)
                            }),
                            aA = rp(function(e, t, n) {
                                var r = 3;
                                if (n.length) {
                                    var i = tH(n, im(aA));
                                    r |= 32
                                }
                                return ii(t, r, e, n, i)
                            });

                        function aE(e, t, n) {
                            var r, s, o, l, u, c, h = 0,
                                d = !1,
                                f = !1,
                                p = !0;
                            if ("function" != typeof e) throw new eA(a);

                            function m(t) {
                                var n = r,
                                    a = s;
                                return r = s = i, h = t, l = e.apply(a, n)
                            }

                            function g(e) {
                                var n = e - c,
                                    r = e - h;
                                return i === c || n >= t || n < 0 || f && r >= o
                            }

                            function v() {
                                var e, n, r, i = aw();
                                if (g(i)) return _(i);
                                u = iF(v, (e = i - c, n = i - h, r = t - e, f ? t4(r, o - n) : r))
                            }

                            function _(e) {
                                return (u = i, p && r) ? m(e) : (r = s = i, l)
                            }

                            function y() {
                                var e, n = aw(),
                                    a = g(n);
                                if (r = arguments, s = this, c = n, a) {
                                    if (i === u) return h = e = c, u = iF(v, t), d ? m(e) : l;
                                    if (f) return rN(u), u = iF(v, t), m(c)
                                }
                                return i === u && (u = iF(v, t)), l
                            }
                            return t = sn(t) || 0, a$(n) && (d = !!n.leading, o = (f = "maxWait" in n) ? t3(sn(n.maxWait) || 0, t) : o, p = "trailing" in n ? !!n.trailing : p), y.cancel = function() {
                                i !== u && rN(u), h = 0, r = c = s = u = i
                            }, y.flush = function() {
                                return i === u ? l : _(aw())
                            }, y
                        }
                        var aC = rp(function(e, t) {
                                return nB(e, 1, t)
                            }),
                            aI = rp(function(e, t, n) {
                                return nB(e, sn(t) || 0, n)
                            });

                        function aP(e, t) {
                            if ("function" != typeof e || null != t && "function" != typeof t) throw new eA(a);
                            var n = function() {
                                var r = arguments,
                                    i = t ? t.apply(this, r) : r[0],
                                    a = n.cache;
                                if (a.has(i)) return a.get(i);
                                var s = e.apply(this, r);
                                return n.cache = a.set(i, s) || a, s
                            };
                            return n.cache = new(aP.Cache || nw), n
                        }

                        function aR(e) {
                            if ("function" != typeof e) throw new eA(a);
                            return function() {
                                var t = arguments;
                                switch (t.length) {
                                    case 0:
                                        return !e.call(this);
                                    case 1:
                                        return !e.call(this, t[0]);
                                    case 2:
                                        return !e.call(this, t[0], t[1]);
                                    case 3:
                                        return !e.call(this, t[0], t[1], t[2])
                                }
                                return !e.apply(this, t)
                            }
                        }
                        aP.Cache = nw;
                        var aL = rp(function(e, t) {
                                var n = (t = 1 == t.length && az(t[0]) ? tm(t[0], tD(ig())) : tm(nq(t, 1), tD(ig()))).length;
                                return rp(function(r) {
                                    for (var i = -1, a = t4(r.length, n); ++i < a;) r[i] = t[i].call(this, r[i]);
                                    return to(e, this, r)
                                })
                            }),
                            aD = rp(function(e, t) {
                                var n = tH(t, im(aD));
                                return ii(e, 32, i, t, n)
                            }),
                            ak = rp(function(e, t) {
                                var n = tH(t, im(ak));
                                return ii(e, 64, i, t, n)
                            }),
                            aU = iu(function(e, t) {
                                return ii(e, 256, i, i, i, t)
                            });

                        function aO(e, t) {
                            return e === t || e != e && t != t
                        }
                        var aF = r7(n1),
                            aN = r7(function(e, t) {
                                return e >= t
                            }),
                            aB = n6(function() {
                                return arguments
                            }()) ? n6 : function(e) {
                                return aJ(e) && eL.call(e, "callee") && !eZ.call(e, "callee")
                            },
                            az = e_.isArray,
                            aG = tt ? tD(tt) : function(e) {
                                return aJ(e) && n0(e) == E
                            };

                        function aV(e) {
                            return null != e && aY(e.length) && !aX(e)
                        }

                        function aW(e) {
                            return aJ(e) && aV(e)
                        }
                        var aH = tQ || s2,
                            aj = tn ? tD(tn) : function(e) {
                                return aJ(e) && n0(e) == p
                            };

                        function aq(e) {
                            if (!aJ(e)) return !1;
                            var t = n0(e);
                            return t == m || "[object DOMException]" == t || "string" == typeof e.message && "string" == typeof e.name && !a0(e)
                        }

                        function aX(e) {
                            if (!a$(e)) return !1;
                            var t = n0(e);
                            return t == g || t == v || "[object AsyncFunction]" == t || "[object Proxy]" == t
                        }

                        function aZ(e) {
                            return "number" == typeof e && e == se(e)
                        }

                        function aY(e) {
                            return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
                        }

                        function a$(e) {
                            var t = typeof e;
                            return null != e && ("object" == t || "function" == t)
                        }

                        function aJ(e) {
                            return null != e && "object" == typeof e
                        }
                        var aK = tr ? tD(tr) : function(e) {
                            return aJ(e) && iw(e) == _
                        };

                        function aQ(e) {
                            return "number" == typeof e || aJ(e) && n0(e) == y
                        }

                        function a0(e) {
                            if (!aJ(e) || n0(e) != x) return !1;
                            var t = eW(e);
                            if (null === t) return !0;
                            var n = eL.call(t, "constructor") && t.constructor;
                            return "function" == typeof n && n instanceof n && eR.call(n) == eO
                        }
                        var a1 = ti ? tD(ti) : function(e) {
                                return aJ(e) && n0(e) == w
                            },
                            a2 = ta ? tD(ta) : function(e) {
                                return aJ(e) && iw(e) == S
                            };

                        function a3(e) {
                            return "string" == typeof e || !az(e) && aJ(e) && n0(e) == M
                        }

                        function a4(e) {
                            return "symbol" == typeof e || aJ(e) && n0(e) == T
                        }
                        var a5 = ts ? tD(ts) : function(e) {
                                return aJ(e) && aY(e.length) && !!eK[n0(e)]
                            },
                            a6 = r7(rn),
                            a8 = r7(function(e, t) {
                                return e <= t
                            });

                        function a7(e) {
                            if (!e) return [];
                            if (aV(e)) return a3(e) ? tX(e) : rj(e);
                            if (e4 && e[e4]) return function(e) {
                                for (var t, n = []; !(t = e.next()).done;) n.push(t.value);
                                return n
                            }(e[e4]());
                            var t = iw(e);
                            return (t == _ ? tV : t == S ? tj : sA)(e)
                        }

                        function a9(e) {
                            return e ? (e = sn(e)) === l || e === -l ? (e < 0 ? -1 : 1) * 17976931348623157e292 : e == e ? e : 0 : 0 === e ? e : 0
                        }

                        function se(e) {
                            var t = a9(e),
                                n = t % 1;
                            return t == t ? n ? t - n : t : 0
                        }

                        function st(e) {
                            return e ? nO(se(e), 0, 4294967295) : 0
                        }

                        function sn(e) {
                            if ("number" == typeof e) return e;
                            if (a4(e)) return u;
                            if (a$(e)) {
                                var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                                e = a$(t) ? t + "" : t
                            }
                            if ("string" != typeof e) return 0 === e ? e : +e;
                            e = tL(e);
                            var n = ec.test(e);
                            return n || ed.test(e) ? e2(e.slice(2), n ? 2 : 8) : eu.test(e) ? u : +e
                        }

                        function sr(e) {
                            return rq(e, s_(e))
                        }

                        function si(e) {
                            return null == e ? "" : rA(e)
                        }
                        var sa = rZ(function(e, t) {
                                if (iR(t) || aV(t)) {
                                    rq(t, sv(t), e);
                                    return
                                }
                                for (var n in t) eL.call(t, n) && nP(e, n, t[n])
                            }),
                            ss = rZ(function(e, t) {
                                rq(t, s_(t), e)
                            }),
                            so = rZ(function(e, t, n, r) {
                                rq(t, s_(t), e, r)
                            }),
                            sl = rZ(function(e, t, n, r) {
                                rq(t, sv(t), e, r)
                            }),
                            su = iu(nU),
                            sc = rp(function(e, t) {
                                e = eS(e);
                                var n = -1,
                                    r = t.length,
                                    a = r > 2 ? t[2] : i;
                                for (a && iE(t[0], t[1], a) && (r = 1); ++n < r;)
                                    for (var s = t[n], o = s_(s), l = -1, u = o.length; ++l < u;) {
                                        var c = o[l],
                                            h = e[c];
                                        (i === h || aO(h, eI[c]) && !eL.call(e, c)) && (e[c] = s[c])
                                    }
                                return e
                            }),
                            sh = rp(function(e) {
                                return e.push(i, is), to(sx, i, e)
                            });

                        function sd(e, t, n) {
                            var r = null == e ? i : nK(e, t);
                            return i === r ? n : r
                        }

                        function sf(e, t) {
                            return null != e && iS(e, t, n3)
                        }
                        var sp = r3(function(e, t, n) {
                                null != t && "function" != typeof t.toString && (t = eU.call(t)), e[t] = n
                            }, sz(sW)),
                            sm = r3(function(e, t, n) {
                                null != t && "function" != typeof t.toString && (t = eU.call(t)), eL.call(e, t) ? e[t].push(n) : e[t] = [n]
                            }, ig),
                            sg = rp(n5);

                        function sv(e) {
                            return aV(e) ? nT(e) : rt(e)
                        }

                        function s_(e) {
                            return aV(e) ? nT(e, !0) : function(e) {
                                if (!a$(e)) return function(e) {
                                    var t = [];
                                    if (null != e)
                                        for (var n in eS(e)) t.push(n);
                                    return t
                                }(e);
                                var t = iR(e),
                                    n = [];
                                for (var r in e) "constructor" == r && (t || !eL.call(e, r)) || n.push(r);
                                return n
                            }(e)
                        }
                        var sy = rZ(function(e, t, n) {
                                rs(e, t, n)
                            }),
                            sx = rZ(function(e, t, n, r) {
                                rs(e, t, n, r)
                            }),
                            sb = iu(function(e, t) {
                                var n = {};
                                if (null == e) return n;
                                var r = !1;
                                t = tm(t, function(t) {
                                    return t = rO(t, e), r || (r = t.length > 1), t
                                }), rq(e, ih(e), n), r && (n = nF(n, 7, io));
                                for (var i = t.length; i--;) rC(n, t[i]);
                                return n
                            }),
                            sw = iu(function(e, t) {
                                return null == e ? {} : ru(e, t, function(t, n) {
                                    return sf(e, n)
                                })
                            });

                        function sS(e, t) {
                            if (null == e) return {};
                            var n = tm(ih(e), function(e) {
                                return [e]
                            });
                            return t = ig(t), ru(e, n, function(e, n) {
                                return t(e, n[0])
                            })
                        }
                        var sM = ir(sv),
                            sT = ir(s_);

                        function sA(e) {
                            return null == e ? [] : tk(e, sv(e))
                        }
                        var sE = rK(function(e, t, n) {
                            return t = t.toLowerCase(), e + (n ? sC(t) : t)
                        });

                        function sC(e) {
                            return sO(si(e).toLowerCase())
                        }

                        function sI(e) {
                            return (e = si(e)) && e.replace(ep, tN).replace(ej, "")
                        }
                        var sP = rK(function(e, t, n) {
                                return e + (n ? "-" : "") + t.toLowerCase()
                            }),
                            sR = rK(function(e, t, n) {
                                return e + (n ? " " : "") + t.toLowerCase()
                            }),
                            sL = rJ("toLowerCase"),
                            sD = rK(function(e, t, n) {
                                return e + (n ? "_" : "") + t.toLowerCase()
                            }),
                            sk = rK(function(e, t, n) {
                                return e + (n ? " " : "") + sO(t)
                            }),
                            sU = rK(function(e, t, n) {
                                return e + (n ? " " : "") + t.toUpperCase()
                            }),
                            sO = rJ("toUpperCase");

                        function sF(e, t, n) {
                            if (e = si(e), t = n ? i : t, i === t) {
                                var r;
                                return (r = e, eY.test(r)) ? e.match(eX) || [] : e.match(ei) || []
                            }
                            return e.match(t) || []
                        }
                        var sN = rp(function(e, t) {
                                try {
                                    return to(e, i, t)
                                } catch (n) {
                                    return aq(n) ? n : new ex(n)
                                }
                            }),
                            sB = iu(function(e, t) {
                                return tu(t, function(t) {
                                    nk(e, t = iW(t), aT(e[t], e))
                                }), e
                            });

                        function sz(e) {
                            return function() {
                                return e
                            }
                        }
                        var sG = r1(),
                            sV = r1(!0);

                        function sW(e) {
                            return e
                        }

                        function sH(e) {
                            return re("function" == typeof e ? e : nF(e, 1))
                        }
                        var sj = rp(function(e, t) {
                                return function(n) {
                                    return n5(n, e, t)
                                }
                            }),
                            sq = rp(function(e, t) {
                                return function(n) {
                                    return n5(e, n, t)
                                }
                            });

                        function sX(e, t, n) {
                            var r = sv(t),
                                i = nJ(t, r);
                            null != n || a$(t) && (i.length || !r.length) || (n = t, t = e, e = this, i = nJ(t, sv(t)));
                            var a = !(a$(n) && "chain" in n) || !!n.chain,
                                s = aX(e);
                            return tu(i, function(n) {
                                var r = t[n];
                                e[n] = r, s && (e.prototype[n] = function() {
                                    var t = this.__chain__;
                                    if (a || t) {
                                        var n = e(this.__wrapped__);
                                        return (n.__actions__ = rj(this.__actions__)).push({
                                            func: r,
                                            args: arguments,
                                            thisArg: e
                                        }), n.__chain__ = t, n
                                    }
                                    return r.apply(e, tg([this.value()], arguments))
                                })
                            }), e
                        }

                        function sZ() {}
                        var sY = r5(tm),
                            s$ = r5(th),
                            sJ = r5(ty);

                        function sK(e) {
                            return iC(e) ? tE(iW(e)) : function(t) {
                                return nK(t, e)
                            }
                        }
                        var sQ = r8(),
                            s0 = r8(!0);

                        function s1() {
                            return []
                        }

                        function s2() {
                            return !1
                        }
                        var s3 = r4(function(e, t) {
                                return e + t
                            }, 0),
                            s4 = ie("ceil"),
                            s5 = r4(function(e, t) {
                                return e / t
                            }, 1),
                            s6 = ie("floor"),
                            s8 = r4(function(e, t) {
                                return e * t
                            }, 1),
                            s7 = ie("round"),
                            s9 = r4(function(e, t) {
                                return e - t
                            }, 0);
                        return nm.after = function(e, t) {
                            if ("function" != typeof t) throw new eA(a);
                            return e = se(e),
                                function() {
                                    if (--e < 1) return t.apply(this, arguments)
                                }
                        }, nm.ary = aS, nm.assign = sa, nm.assignIn = ss, nm.assignInWith = so, nm.assignWith = sl, nm.at = su, nm.before = aM, nm.bind = aT, nm.bindAll = sB, nm.bindKey = aA, nm.castArray = function() {
                            if (!arguments.length) return [];
                            var e = arguments[0];
                            return az(e) ? e : [e]
                        }, nm.chain = al, nm.chunk = function(e, t, n) {
                            t = (n ? iE(e, t, n) : i === t) ? 1 : t3(se(t), 0);
                            var r = null == e ? 0 : e.length;
                            if (!r || t < 1) return [];
                            for (var a = 0, s = 0, o = e_(tC(r / t)); a < r;) o[s++] = rx(e, a, a += t);
                            return o
                        }, nm.compact = function(e) {
                            for (var t = -1, n = null == e ? 0 : e.length, r = 0, i = []; ++t < n;) {
                                var a = e[t];
                                a && (i[r++] = a)
                            }
                            return i
                        }, nm.concat = function() {
                            var e = arguments.length;
                            if (!e) return [];
                            for (var t = e_(e - 1), n = arguments[0], r = e; r--;) t[r - 1] = arguments[r];
                            return tg(az(n) ? rj(n) : [n], nq(t, 1))
                        }, nm.cond = function(e) {
                            var t = null == e ? 0 : e.length,
                                n = ig();
                            return e = t ? tm(e, function(e) {
                                if ("function" != typeof e[1]) throw new eA(a);
                                return [n(e[0]), e[1]]
                            }) : [], rp(function(n) {
                                for (var r = -1; ++r < t;) {
                                    var i = e[r];
                                    if (to(i[0], this, n)) return to(i[1], this, n)
                                }
                            })
                        }, nm.conforms = function(e) {
                            var t, n;
                            return n = sv(t = nF(e, 1)),
                                function(e) {
                                    return nN(e, t, n)
                                }
                        }, nm.constant = sz, nm.countBy = ah, nm.create = function(e, t) {
                            var n = ng(e);
                            return null == t ? n : nD(n, t)
                        }, nm.curry = function e(t, n, r) {
                            n = r ? i : n;
                            var a = ii(t, 8, i, i, i, i, i, n);
                            return a.placeholder = e.placeholder, a
                        }, nm.curryRight = function e(t, n, r) {
                            n = r ? i : n;
                            var a = ii(t, 16, i, i, i, i, i, n);
                            return a.placeholder = e.placeholder, a
                        }, nm.debounce = aE, nm.defaults = sc, nm.defaultsDeep = sh, nm.defer = aC, nm.delay = aI, nm.difference = iq, nm.differenceBy = iX, nm.differenceWith = iZ, nm.drop = function(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            return r ? rx(e, (t = n || i === t ? 1 : se(t)) < 0 ? 0 : t, r) : []
                        }, nm.dropRight = function(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            return r ? rx(e, 0, (t = r - (t = n || i === t ? 1 : se(t))) < 0 ? 0 : t) : []
                        }, nm.dropRightWhile = function(e, t) {
                            return e && e.length ? rP(e, ig(t, 3), !0, !0) : []
                        }, nm.dropWhile = function(e, t) {
                            return e && e.length ? rP(e, ig(t, 3), !0) : []
                        }, nm.fill = function(e, t, n, r) {
                            var a = null == e ? 0 : e.length;
                            return a ? (n && "number" != typeof n && iE(e, t, n) && (n = 0, r = a), function(e, t, n, r) {
                                var a = e.length;
                                for ((n = se(n)) < 0 && (n = -n > a ? 0 : a + n), (r = i === r || r > a ? a : se(r)) < 0 && (r += a), r = n > r ? 0 : st(r); n < r;) e[n++] = t;
                                return e
                            }(e, t, n, r)) : []
                        }, nm.filter = function(e, t) {
                            return (az(e) ? td : nj)(e, ig(t, 3))
                        }, nm.flatMap = function(e, t) {
                            return nq(ay(e, t), 1)
                        }, nm.flatMapDeep = function(e, t) {
                            return nq(ay(e, t), l)
                        }, nm.flatMapDepth = function(e, t, n) {
                            return n = i === n ? 1 : se(n), nq(ay(e, t), n)
                        }, nm.flatten = iJ, nm.flattenDeep = function(e) {
                            return (null == e ? 0 : e.length) ? nq(e, l) : []
                        }, nm.flattenDepth = function(e, t) {
                            return (null == e ? 0 : e.length) ? nq(e, t = i === t ? 1 : se(t)) : []
                        }, nm.flip = function(e) {
                            return ii(e, 512)
                        }, nm.flow = sG, nm.flowRight = sV, nm.fromPairs = function(e) {
                            for (var t = -1, n = null == e ? 0 : e.length, r = {}; ++t < n;) {
                                var i = e[t];
                                r[i[0]] = i[1]
                            }
                            return r
                        }, nm.functions = function(e) {
                            return null == e ? [] : nJ(e, sv(e))
                        }, nm.functionsIn = function(e) {
                            return null == e ? [] : nJ(e, s_(e))
                        }, nm.groupBy = ag, nm.initial = function(e) {
                            return (null == e ? 0 : e.length) ? rx(e, 0, -1) : []
                        }, nm.intersection = iQ, nm.intersectionBy = i0, nm.intersectionWith = i1, nm.invert = sp, nm.invertBy = sm, nm.invokeMap = av, nm.iteratee = sH, nm.keyBy = a_, nm.keys = sv, nm.keysIn = s_, nm.map = ay, nm.mapKeys = function(e, t) {
                            var n = {};
                            return t = ig(t, 3), nY(e, function(e, r, i) {
                                nk(n, t(e, r, i), e)
                            }), n
                        }, nm.mapValues = function(e, t) {
                            var n = {};
                            return t = ig(t, 3), nY(e, function(e, r, i) {
                                nk(n, r, t(e, r, i))
                            }), n
                        }, nm.matches = function(e) {
                            return ri(nF(e, 1))
                        }, nm.matchesProperty = function(e, t) {
                            return ra(e, nF(t, 1))
                        }, nm.memoize = aP, nm.merge = sy, nm.mergeWith = sx, nm.method = sj, nm.methodOf = sq, nm.mixin = sX, nm.negate = aR, nm.nthArg = function(e) {
                            return e = se(e), rp(function(t) {
                                return ro(t, e)
                            })
                        }, nm.omit = sb, nm.omitBy = function(e, t) {
                            return sS(e, aR(ig(t)))
                        }, nm.once = function(e) {
                            return aM(2, e)
                        }, nm.orderBy = function(e, t, n, r) {
                            return null == e ? [] : (az(t) || (t = null == t ? [] : [t]), az(n = r ? i : n) || (n = null == n ? [] : [n]), rl(e, t, n))
                        }, nm.over = sY, nm.overArgs = aL, nm.overEvery = s$, nm.overSome = sJ, nm.partial = aD, nm.partialRight = ak, nm.partition = ax, nm.pick = sw, nm.pickBy = sS, nm.property = sK, nm.propertyOf = function(e) {
                            return function(t) {
                                return null == e ? i : nK(e, t)
                            }
                        }, nm.pull = i3, nm.pullAll = i4, nm.pullAllBy = function(e, t, n) {
                            return e && e.length && t && t.length ? rc(e, t, ig(n, 2)) : e
                        }, nm.pullAllWith = function(e, t, n) {
                            return e && e.length && t && t.length ? rc(e, t, i, n) : e
                        }, nm.pullAt = i5, nm.range = sQ, nm.rangeRight = s0, nm.rearg = aU, nm.reject = function(e, t) {
                            return (az(e) ? td : nj)(e, aR(ig(t, 3)))
                        }, nm.remove = function(e, t) {
                            var n = [];
                            if (!(e && e.length)) return n;
                            var r = -1,
                                i = [],
                                a = e.length;
                            for (t = ig(t, 3); ++r < a;) {
                                var s = e[r];
                                t(s, r, e) && (n.push(s), i.push(r))
                            }
                            return rh(e, i), n
                        }, nm.rest = function(e, t) {
                            if ("function" != typeof e) throw new eA(a);
                            return rp(e, t = i === t ? t : se(t))
                        }, nm.reverse = i6, nm.sampleSize = function(e, t, n) {
                            return t = (n ? iE(e, t, n) : i === t) ? 1 : se(t), (az(e) ? nE : rg)(e, t)
                        }, nm.set = function(e, t, n) {
                            return null == e ? e : rv(e, t, n)
                        }, nm.setWith = function(e, t, n, r) {
                            return r = "function" == typeof r ? r : i, null == e ? e : rv(e, t, n, r)
                        }, nm.shuffle = function(e) {
                            return (az(e) ? nC : ry)(e)
                        }, nm.slice = function(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            return r ? (n && "number" != typeof n && iE(e, t, n) ? (t = 0, n = r) : (t = null == t ? 0 : se(t), n = i === n ? r : se(n)), rx(e, t, n)) : []
                        }, nm.sortBy = ab, nm.sortedUniq = function(e) {
                            return e && e.length ? rM(e) : []
                        }, nm.sortedUniqBy = function(e, t) {
                            return e && e.length ? rM(e, ig(t, 2)) : []
                        }, nm.split = function(e, t, n) {
                            return (n && "number" != typeof n && iE(e, t, n) && (t = n = i), n = i === n ? 4294967295 : n >>> 0) ? (e = si(e)) && ("string" == typeof t || null != t && !a1(t)) && !(t = rA(t)) && tG(e) ? rF(tX(e), 0, n) : e.split(t, n) : []
                        }, nm.spread = function(e, t) {
                            if ("function" != typeof e) throw new eA(a);
                            return t = null == t ? 0 : t3(se(t), 0), rp(function(n) {
                                var r = n[t],
                                    i = rF(n, 0, t);
                                return r && tg(i, r), to(e, this, i)
                            })
                        }, nm.tail = function(e) {
                            var t = null == e ? 0 : e.length;
                            return t ? rx(e, 1, t) : []
                        }, nm.take = function(e, t, n) {
                            return e && e.length ? rx(e, 0, (t = n || i === t ? 1 : se(t)) < 0 ? 0 : t) : []
                        }, nm.takeRight = function(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            return r ? rx(e, (t = r - (t = n || i === t ? 1 : se(t))) < 0 ? 0 : t, r) : []
                        }, nm.takeRightWhile = function(e, t) {
                            return e && e.length ? rP(e, ig(t, 3), !1, !0) : []
                        }, nm.takeWhile = function(e, t) {
                            return e && e.length ? rP(e, ig(t, 3)) : []
                        }, nm.tap = function(e, t) {
                            return t(e), e
                        }, nm.throttle = function(e, t, n) {
                            var r = !0,
                                i = !0;
                            if ("function" != typeof e) throw new eA(a);
                            return a$(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), aE(e, t, {
                                leading: r,
                                maxWait: t,
                                trailing: i
                            })
                        }, nm.thru = au, nm.toArray = a7, nm.toPairs = sM, nm.toPairsIn = sT, nm.toPath = function(e) {
                            return az(e) ? tm(e, iW) : a4(e) ? [e] : rj(iV(si(e)))
                        }, nm.toPlainObject = sr, nm.transform = function(e, t, n) {
                            var r = az(e),
                                i = r || aH(e) || a5(e);
                            if (t = ig(t, 4), null == n) {
                                var a = e && e.constructor;
                                n = i ? r ? new a : [] : a$(e) && aX(a) ? ng(eW(e)) : {}
                            }
                            return (i ? tu : nY)(e, function(e, r, i) {
                                return t(n, e, r, i)
                            }), n
                        }, nm.unary = function(e) {
                            return aS(e, 1)
                        }, nm.union = i8, nm.unionBy = i7, nm.unionWith = i9, nm.uniq = function(e) {
                            return e && e.length ? rE(e) : []
                        }, nm.uniqBy = function(e, t) {
                            return e && e.length ? rE(e, ig(t, 2)) : []
                        }, nm.uniqWith = function(e, t) {
                            return t = "function" == typeof t ? t : i, e && e.length ? rE(e, i, t) : []
                        }, nm.unset = function(e, t) {
                            return null == e || rC(e, t)
                        }, nm.unzip = ae, nm.unzipWith = at, nm.update = function(e, t, n) {
                            return null == e ? e : rI(e, t, rU(n))
                        }, nm.updateWith = function(e, t, n, r) {
                            return r = "function" == typeof r ? r : i, null == e ? e : rI(e, t, rU(n), r)
                        }, nm.values = sA, nm.valuesIn = function(e) {
                            return null == e ? [] : tk(e, s_(e))
                        }, nm.without = an, nm.words = sF, nm.wrap = function(e, t) {
                            return aD(rU(t), e)
                        }, nm.xor = ar, nm.xorBy = ai, nm.xorWith = aa, nm.zip = as, nm.zipObject = function(e, t) {
                            return rD(e || [], t || [], nP)
                        }, nm.zipObjectDeep = function(e, t) {
                            return rD(e || [], t || [], rv)
                        }, nm.zipWith = ao, nm.entries = sM, nm.entriesIn = sT, nm.extend = ss, nm.extendWith = so, sX(nm, nm), nm.add = s3, nm.attempt = sN, nm.camelCase = sE, nm.capitalize = sC, nm.ceil = s4, nm.clamp = function(e, t, n) {
                            return i === n && (n = t, t = i), i !== n && (n = (n = sn(n)) == n ? n : 0), i !== t && (t = (t = sn(t)) == t ? t : 0), nO(sn(e), t, n)
                        }, nm.clone = function(e) {
                            return nF(e, 4)
                        }, nm.cloneDeep = function(e) {
                            return nF(e, 5)
                        }, nm.cloneDeepWith = function(e, t) {
                            return nF(e, 5, t = "function" == typeof t ? t : i)
                        }, nm.cloneWith = function(e, t) {
                            return nF(e, 4, t = "function" == typeof t ? t : i)
                        }, nm.conformsTo = function(e, t) {
                            return null == t || nN(e, t, sv(t))
                        }, nm.deburr = sI, nm.defaultTo = function(e, t) {
                            return null == e || e != e ? t : e
                        }, nm.divide = s5, nm.endsWith = function(e, t, n) {
                            e = si(e), t = rA(t);
                            var r = e.length,
                                a = n = i === n ? r : nO(se(n), 0, r);
                            return (n -= t.length) >= 0 && e.slice(n, a) == t
                        }, nm.eq = aO, nm.escape = function(e) {
                            return (e = si(e)) && H.test(e) ? e.replace(V, tB) : e
                        }, nm.escapeRegExp = function(e) {
                            return (e = si(e)) && K.test(e) ? e.replace(J, "\\$&") : e
                        }, nm.every = function(e, t, n) {
                            var r = az(e) ? th : nW;
                            return n && iE(e, t, n) && (t = i), r(e, ig(t, 3))
                        }, nm.find = ad, nm.findIndex = iY, nm.findKey = function(e, t) {
                            return tb(e, ig(t, 3), nY)
                        }, nm.findLast = af, nm.findLastIndex = i$, nm.findLastKey = function(e, t) {
                            return tb(e, ig(t, 3), n$)
                        }, nm.floor = s6, nm.forEach = ap, nm.forEachRight = am, nm.forIn = function(e, t) {
                            return null == e ? e : nX(e, ig(t, 3), s_)
                        }, nm.forInRight = function(e, t) {
                            return null == e ? e : nZ(e, ig(t, 3), s_)
                        }, nm.forOwn = function(e, t) {
                            return e && nY(e, ig(t, 3))
                        }, nm.forOwnRight = function(e, t) {
                            return e && n$(e, ig(t, 3))
                        }, nm.get = sd, nm.gt = aF, nm.gte = aN, nm.has = function(e, t) {
                            return null != e && iS(e, t, n2)
                        }, nm.hasIn = sf, nm.head = iK, nm.identity = sW, nm.includes = function(e, t, n, r) {
                            e = aV(e) ? e : sA(e), n = n && !r ? se(n) : 0;
                            var i = e.length;
                            return n < 0 && (n = t3(i + n, 0)), a3(e) ? n <= i && e.indexOf(t, n) > -1 : !!i && tS(e, t, n) > -1
                        }, nm.indexOf = function(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            if (!r) return -1;
                            var i = null == n ? 0 : se(n);
                            return i < 0 && (i = t3(r + i, 0)), tS(e, t, i)
                        }, nm.inRange = function(e, t, n) {
                            var r, a, s;
                            return t = a9(t), i === n ? (n = t, t = 0) : n = a9(n), (r = e = sn(e)) >= t4(a = t, s = n) && r < t3(a, s)
                        }, nm.invoke = sg, nm.isArguments = aB, nm.isArray = az, nm.isArrayBuffer = aG, nm.isArrayLike = aV, nm.isArrayLikeObject = aW, nm.isBoolean = function(e) {
                            return !0 === e || !1 === e || aJ(e) && n0(e) == f
                        }, nm.isBuffer = aH, nm.isDate = aj, nm.isElement = function(e) {
                            return aJ(e) && 1 === e.nodeType && !a0(e)
                        }, nm.isEmpty = function(e) {
                            if (null == e) return !0;
                            if (aV(e) && (az(e) || "string" == typeof e || "function" == typeof e.splice || aH(e) || a5(e) || aB(e))) return !e.length;
                            var t = iw(e);
                            if (t == _ || t == S) return !e.size;
                            if (iR(e)) return !rt(e).length;
                            for (var n in e)
                                if (eL.call(e, n)) return !1;
                            return !0
                        }, nm.isEqual = function(e, t) {
                            return n8(e, t)
                        }, nm.isEqualWith = function(e, t, n) {
                            var r = (n = "function" == typeof n ? n : i) ? n(e, t) : i;
                            return i === r ? n8(e, t, i, n) : !!r
                        }, nm.isError = aq, nm.isFinite = function(e) {
                            return "number" == typeof e && t0(e)
                        }, nm.isFunction = aX, nm.isInteger = aZ, nm.isLength = aY, nm.isMap = aK, nm.isMatch = function(e, t) {
                            return e === t || n7(e, t, i_(t))
                        }, nm.isMatchWith = function(e, t, n) {
                            return n = "function" == typeof n ? n : i, n7(e, t, i_(t), n)
                        }, nm.isNaN = function(e) {
                            return aQ(e) && e != +e
                        }, nm.isNative = function(e) {
                            if (iP(e)) throw new ex("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
                            return n9(e)
                        }, nm.isNil = function(e) {
                            return null == e
                        }, nm.isNull = function(e) {
                            return null === e
                        }, nm.isNumber = aQ, nm.isObject = a$, nm.isObjectLike = aJ, nm.isPlainObject = a0, nm.isRegExp = a1, nm.isSafeInteger = function(e) {
                            return aZ(e) && e >= -9007199254740991 && e <= 9007199254740991
                        }, nm.isSet = a2, nm.isString = a3, nm.isSymbol = a4, nm.isTypedArray = a5, nm.isUndefined = function(e) {
                            return i === e
                        }, nm.isWeakMap = function(e) {
                            return aJ(e) && iw(e) == A
                        }, nm.isWeakSet = function(e) {
                            return aJ(e) && "[object WeakSet]" == n0(e)
                        }, nm.join = function(e, t) {
                            return null == e ? "" : t1.call(e, t)
                        }, nm.kebabCase = sP, nm.last = i2, nm.lastIndexOf = function(e, t, n) {
                            var r = null == e ? 0 : e.length;
                            if (!r) return -1;
                            var a = r;
                            return i !== n && (a = (a = se(n)) < 0 ? t3(r + a, 0) : t4(a, r - 1)), t == t ? function(e, t, n) {
                                for (var r = n + 1; r-- && e[r] !== t;);
                                return r
                            }(e, t, a) : tw(e, tT, a, !0)
                        }, nm.lowerCase = sR, nm.lowerFirst = sL, nm.lt = a6, nm.lte = a8, nm.max = function(e) {
                            return e && e.length ? nH(e, sW, n1) : i
                        }, nm.maxBy = function(e, t) {
                            return e && e.length ? nH(e, ig(t, 2), n1) : i
                        }, nm.mean = function(e) {
                            return tA(e, sW)
                        }, nm.meanBy = function(e, t) {
                            return tA(e, ig(t, 2))
                        }, nm.min = function(e) {
                            return e && e.length ? nH(e, sW, rn) : i
                        }, nm.minBy = function(e, t) {
                            return e && e.length ? nH(e, ig(t, 2), rn) : i
                        }, nm.stubArray = s1, nm.stubFalse = s2, nm.stubObject = function() {
                            return {}
                        }, nm.stubString = function() {
                            return ""
                        }, nm.stubTrue = function() {
                            return !0
                        }, nm.multiply = s8, nm.nth = function(e, t) {
                            return e && e.length ? ro(e, se(t)) : i
                        }, nm.noConflict = function() {
                            return e5._ === this && (e5._ = eF), this
                        }, nm.noop = sZ, nm.now = aw, nm.pad = function(e, t, n) {
                            e = si(e);
                            var r = (t = se(t)) ? tq(e) : 0;
                            if (!t || r >= t) return e;
                            var i = (t - r) / 2;
                            return r6(tJ(i), n) + e + r6(tC(i), n)
                        }, nm.padEnd = function(e, t, n) {
                            e = si(e);
                            var r = (t = se(t)) ? tq(e) : 0;
                            return t && r < t ? e + r6(t - r, n) : e
                        }, nm.padStart = function(e, t, n) {
                            e = si(e);
                            var r = (t = se(t)) ? tq(e) : 0;
                            return t && r < t ? r6(t - r, n) + e : e
                        }, nm.parseInt = function(e, t, n) {
                            return n || null == t ? t = 0 : t && (t = +t), t6(si(e).replace(Q, ""), t || 0)
                        }, nm.random = function(e, t, n) {
                            if (n && "boolean" != typeof n && iE(e, t, n) && (t = n = i), i === n && ("boolean" == typeof t ? (n = t, t = i) : "boolean" == typeof e && (n = e, e = i)), i === e && i === t ? (e = 0, t = 1) : (e = a9(e), i === t ? (t = e, e = 0) : t = a9(t)), e > t) {
                                var r = e;
                                e = t, t = r
                            }
                            if (n || e % 1 || t % 1) {
                                var a = t8();
                                return t4(e + a * (t - e + e1("1e-" + ((a + "").length - 1))), t)
                            }
                            return rd(e, t)
                        }, nm.reduce = function(e, t, n) {
                            var r = az(e) ? tv : tI,
                                i = arguments.length < 3;
                            return r(e, ig(t, 4), n, i, nG)
                        }, nm.reduceRight = function(e, t, n) {
                            var r = az(e) ? t_ : tI,
                                i = arguments.length < 3;
                            return r(e, ig(t, 4), n, i, nV)
                        }, nm.repeat = function(e, t, n) {
                            return t = (n ? iE(e, t, n) : i === t) ? 1 : se(t), rf(si(e), t)
                        }, nm.replace = function() {
                            var e = arguments,
                                t = si(e[0]);
                            return e.length < 3 ? t : t.replace(e[1], e[2])
                        }, nm.result = function(e, t, n) {
                            t = rO(t, e);
                            var r = -1,
                                a = t.length;
                            for (a || (a = 1, e = i); ++r < a;) {
                                var s = null == e ? i : e[iW(t[r])];
                                i === s && (r = a, s = n), e = aX(s) ? s.call(e) : s
                            }
                            return e
                        }, nm.round = s7, nm.runInContext = e, nm.sample = function(e) {
                            return (az(e) ? nA : rm)(e)
                        }, nm.size = function(e) {
                            if (null == e) return 0;
                            if (aV(e)) return a3(e) ? tq(e) : e.length;
                            var t = iw(e);
                            return t == _ || t == S ? e.size : rt(e).length
                        }, nm.snakeCase = sD, nm.some = function(e, t, n) {
                            var r = az(e) ? ty : rb;
                            return n && iE(e, t, n) && (t = i), r(e, ig(t, 3))
                        }, nm.sortedIndex = function(e, t) {
                            return rw(e, t)
                        }, nm.sortedIndexBy = function(e, t, n) {
                            return rS(e, t, ig(n, 2))
                        }, nm.sortedIndexOf = function(e, t) {
                            var n = null == e ? 0 : e.length;
                            if (n) {
                                var r = rw(e, t);
                                if (r < n && aO(e[r], t)) return r
                            }
                            return -1
                        }, nm.sortedLastIndex = function(e, t) {
                            return rw(e, t, !0)
                        }, nm.sortedLastIndexBy = function(e, t, n) {
                            return rS(e, t, ig(n, 2), !0)
                        }, nm.sortedLastIndexOf = function(e, t) {
                            if (null == e ? 0 : e.length) {
                                var n = rw(e, t, !0) - 1;
                                if (aO(e[n], t)) return n
                            }
                            return -1
                        }, nm.startCase = sk, nm.startsWith = function(e, t, n) {
                            return e = si(e), n = null == n ? 0 : nO(se(n), 0, e.length), t = rA(t), e.slice(n, n + t.length) == t
                        }, nm.subtract = s9, nm.sum = function(e) {
                            return e && e.length ? tP(e, sW) : 0
                        }, nm.sumBy = function(e, t) {
                            return e && e.length ? tP(e, ig(t, 2)) : 0
                        }, nm.template = function(e, t, n) {
                            var r = nm.templateSettings;
                            n && iE(e, t, n) && (t = i), e = si(e), t = so({}, t, r, ia);
                            var a, s, o = so({}, t.imports, r.imports, ia),
                                l = sv(o),
                                u = tk(o, l),
                                c = 0,
                                h = t.interpolate || em,
                                d = "__p += '",
                                f = eM((t.escape || em).source + "|" + h.source + "|" + (h === X ? eo : em).source + "|" + (t.evaluate || em).source + "|$", "g"),
                                p = "//# sourceURL=" + (eL.call(t, "sourceURL") ? (t.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++eJ + "]") + "\n";
                            e.replace(f, function(t, n, r, i, o, l) {
                                return r || (r = i), d += e.slice(c, l).replace(eg, tz), n && (a = !0, d += "' +\n__e(" + n + ") +\n'"), o && (s = !0, d += "';\n" + o + ";\n__p += '"), r && (d += "' +\n((__t = (" + r + ")) == null ? '' : __t) +\n'"), c = l + t.length, t
                            }), d += "';\n";
                            var m = eL.call(t, "variable") && t.variable;
                            if (m) {
                                if (ea.test(m)) throw new ex("Invalid `variable` option passed into `_.template`")
                            } else d = "with (obj) {\n" + d + "\n}\n";
                            d = (s ? d.replace(N, "") : d).replace(B, "$1").replace(z, "$1;"), d = "function(" + (m || "obj") + ") {\n" + (m ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (a ? ", __e = _.escape" : "") + (s ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + d + "return __p\n}";
                            var g = sN(function() {
                                return eb(l, p + "return " + d).apply(i, u)
                            });
                            if (g.source = d, aq(g)) throw g;
                            return g
                        }, nm.times = function(e, t) {
                            if ((e = se(e)) < 1 || e > 9007199254740991) return [];
                            var n = 4294967295,
                                r = t4(e, 4294967295);
                            t = ig(t), e -= 4294967295;
                            for (var i = tR(r, t); ++n < e;) t(n);
                            return i
                        }, nm.toFinite = a9, nm.toInteger = se, nm.toLength = st, nm.toLower = function(e) {
                            return si(e).toLowerCase()
                        }, nm.toNumber = sn, nm.toSafeInteger = function(e) {
                            return e ? nO(se(e), -9007199254740991, 9007199254740991) : 0 === e ? e : 0
                        }, nm.toString = si, nm.toUpper = function(e) {
                            return si(e).toUpperCase()
                        }, nm.trim = function(e, t, n) {
                            if ((e = si(e)) && (n || i === t)) return tL(e);
                            if (!e || !(t = rA(t))) return e;
                            var r = tX(e),
                                a = tX(t),
                                s = tO(r, a),
                                o = tF(r, a) + 1;
                            return rF(r, s, o).join("")
                        }, nm.trimEnd = function(e, t, n) {
                            if ((e = si(e)) && (n || i === t)) return e.slice(0, tZ(e) + 1);
                            if (!e || !(t = rA(t))) return e;
                            var r = tX(e),
                                a = tF(r, tX(t)) + 1;
                            return rF(r, 0, a).join("")
                        }, nm.trimStart = function(e, t, n) {
                            if ((e = si(e)) && (n || i === t)) return e.replace(Q, "");
                            if (!e || !(t = rA(t))) return e;
                            var r = tX(e),
                                a = tO(r, tX(t));
                            return rF(r, a).join("")
                        }, nm.truncate = function(e, t) {
                            var n = 30,
                                r = "...";
                            if (a$(t)) {
                                var a = "separator" in t ? t.separator : a;
                                n = "length" in t ? se(t.length) : n, r = "omission" in t ? rA(t.omission) : r
                            }
                            var s = (e = si(e)).length;
                            if (tG(e)) {
                                var o = tX(e);
                                s = o.length
                            }
                            if (n >= s) return e;
                            var l = n - tq(r);
                            if (l < 1) return r;
                            var u = o ? rF(o, 0, l).join("") : e.slice(0, l);
                            if (i === a) return u + r;
                            if (o && (l += u.length - l), a1(a)) {
                                if (e.slice(l).search(a)) {
                                    var c, h = u;
                                    for (a.global || (a = eM(a.source, si(el.exec(a)) + "g")), a.lastIndex = 0; c = a.exec(h);) var d = c.index;
                                    u = u.slice(0, i === d ? l : d)
                                }
                            } else if (e.indexOf(rA(a), l) != l) {
                                var f = u.lastIndexOf(a);
                                f > -1 && (u = u.slice(0, f))
                            }
                            return u + r
                        }, nm.unescape = function(e) {
                            return (e = si(e)) && W.test(e) ? e.replace(G, tY) : e
                        }, nm.uniqueId = function(e) {
                            var t = ++eD;
                            return si(e) + t
                        }, nm.upperCase = sU, nm.upperFirst = sO, nm.each = ap, nm.eachRight = am, nm.first = iK, sX(nm, (ev = {}, nY(nm, function(e, t) {
                            eL.call(nm.prototype, t) || (ev[t] = e)
                        }), ev), {
                            chain: !1
                        }), nm.VERSION = "4.17.21", tu(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(e) {
                            nm[e].placeholder = nm
                        }), tu(["drop", "take"], function(e, t) {
                            ny.prototype[e] = function(n) {
                                n = i === n ? 1 : t3(se(n), 0);
                                var r = this.__filtered__ && !t ? new ny(this) : this.clone();
                                return r.__filtered__ ? r.__takeCount__ = t4(n, r.__takeCount__) : r.__views__.push({
                                    size: t4(n, 4294967295),
                                    type: e + (r.__dir__ < 0 ? "Right" : "")
                                }), r
                            }, ny.prototype[e + "Right"] = function(t) {
                                return this.reverse()[e](t).reverse()
                            }
                        }), tu(["filter", "map", "takeWhile"], function(e, t) {
                            var n = t + 1,
                                r = 1 == n || 3 == n;
                            ny.prototype[e] = function(e) {
                                var t = this.clone();
                                return t.__iteratees__.push({
                                    iteratee: ig(e, 3),
                                    type: n
                                }), t.__filtered__ = t.__filtered__ || r, t
                            }
                        }), tu(["head", "last"], function(e, t) {
                            var n = "take" + (t ? "Right" : "");
                            ny.prototype[e] = function() {
                                return this[n](1).value()[0]
                            }
                        }), tu(["initial", "tail"], function(e, t) {
                            var n = "drop" + (t ? "" : "Right");
                            ny.prototype[e] = function() {
                                return this.__filtered__ ? new ny(this) : this[n](1)
                            }
                        }), ny.prototype.compact = function() {
                            return this.filter(sW)
                        }, ny.prototype.find = function(e) {
                            return this.filter(e).head()
                        }, ny.prototype.findLast = function(e) {
                            return this.reverse().find(e)
                        }, ny.prototype.invokeMap = rp(function(e, t) {
                            return "function" == typeof e ? new ny(this) : this.map(function(n) {
                                return n5(n, e, t)
                            })
                        }), ny.prototype.reject = function(e) {
                            return this.filter(aR(ig(e)))
                        }, ny.prototype.slice = function(e, t) {
                            e = se(e);
                            var n = this;
                            return n.__filtered__ && (e > 0 || t < 0) ? new ny(n) : (e < 0 ? n = n.takeRight(-e) : e && (n = n.drop(e)), i !== t && (n = (t = se(t)) < 0 ? n.dropRight(-t) : n.take(t - e)), n)
                        }, ny.prototype.takeRightWhile = function(e) {
                            return this.reverse().takeWhile(e).reverse()
                        }, ny.prototype.toArray = function() {
                            return this.take(4294967295)
                        }, nY(ny.prototype, function(e, t) {
                            var n = /^(?:filter|find|map|reject)|While$/.test(t),
                                r = /^(?:head|last)$/.test(t),
                                a = nm[r ? "take" + ("last" == t ? "Right" : "") : t],
                                s = r || /^find/.test(t);
                            a && (nm.prototype[t] = function() {
                                var t = this.__wrapped__,
                                    o = r ? [1] : arguments,
                                    l = t instanceof ny,
                                    u = o[0],
                                    c = l || az(t),
                                    h = function(e) {
                                        var t = a.apply(nm, tg([e], o));
                                        return r && d ? t[0] : t
                                    };
                                c && n && "function" == typeof u && 1 != u.length && (l = c = !1);
                                var d = this.__chain__,
                                    f = !!this.__actions__.length,
                                    p = s && !d,
                                    m = l && !f;
                                if (!s && c) {
                                    t = m ? t : new ny(this);
                                    var g = e.apply(t, o);
                                    return g.__actions__.push({
                                        func: au,
                                        args: [h],
                                        thisArg: i
                                    }), new n_(g, d)
                                }
                                return p && m ? e.apply(this, o) : (g = this.thru(h), p ? r ? g.value()[0] : g.value() : g)
                            })
                        }), tu(["pop", "push", "shift", "sort", "splice", "unshift"], function(e) {
                            var t = eE[e],
                                n = /^(?:push|sort|unshift)$/.test(e) ? "tap" : "thru",
                                r = /^(?:pop|shift)$/.test(e);
                            nm.prototype[e] = function() {
                                var e = arguments;
                                if (r && !this.__chain__) {
                                    var i = this.value();
                                    return t.apply(az(i) ? i : [], e)
                                }
                                return this[n](function(n) {
                                    return t.apply(az(n) ? n : [], e)
                                })
                            }
                        }), nY(ny.prototype, function(e, t) {
                            var n = nm[t];
                            if (n) {
                                var r = n.name + "";
                                eL.call(ns, r) || (ns[r] = []), ns[r].push({
                                    name: t,
                                    func: n
                                })
                            }
                        }), ns[r2(i, 2).name] = [{
                            name: "wrapper",
                            func: i
                        }], ny.prototype.clone = function() {
                            var e = new ny(this.__wrapped__);
                            return e.__actions__ = rj(this.__actions__), e.__dir__ = this.__dir__, e.__filtered__ = this.__filtered__, e.__iteratees__ = rj(this.__iteratees__), e.__takeCount__ = this.__takeCount__, e.__views__ = rj(this.__views__), e
                        }, ny.prototype.reverse = function() {
                            if (this.__filtered__) {
                                var e = new ny(this);
                                e.__dir__ = -1, e.__filtered__ = !0
                            } else e = this.clone(), e.__dir__ *= -1;
                            return e
                        }, ny.prototype.value = function() {
                            var e = this.__wrapped__.value(),
                                t = this.__dir__,
                                n = az(e),
                                r = t < 0,
                                i = n ? e.length : 0,
                                a = function(e, t, n) {
                                    for (var r = -1, i = n.length; ++r < i;) {
                                        var a = n[r],
                                            s = a.size;
                                        switch (a.type) {
                                            case "drop":
                                                e += s;
                                                break;
                                            case "dropRight":
                                                t -= s;
                                                break;
                                            case "take":
                                                t = t4(t, e + s);
                                                break;
                                            case "takeRight":
                                                e = t3(e, t - s)
                                        }
                                    }
                                    return {
                                        start: e,
                                        end: t
                                    }
                                }(0, i, this.__views__),
                                s = a.start,
                                o = a.end,
                                l = o - s,
                                u = r ? o : s - 1,
                                c = this.__iteratees__,
                                h = c.length,
                                d = 0,
                                f = t4(l, this.__takeCount__);
                            if (!n || !r && i == l && f == l) return rR(e, this.__actions__);
                            var p = [];
                            e: for (; l-- && d < f;) {
                                for (var m = -1, g = e[u += t]; ++m < h;) {
                                    var v = c[m],
                                        _ = v.iteratee,
                                        y = v.type,
                                        x = _(g);
                                    if (2 == y) g = x;
                                    else if (!x) {
                                        if (1 == y) continue e;
                                        break e
                                    }
                                }
                                p[d++] = g
                            }
                            return p
                        }, nm.prototype.at = ac, nm.prototype.chain = function() {
                            return al(this)
                        }, nm.prototype.commit = function() {
                            return new n_(this.value(), this.__chain__)
                        }, nm.prototype.next = function() {
                            i === this.__values__ && (this.__values__ = a7(this.value()));
                            var e = this.__index__ >= this.__values__.length,
                                t = e ? i : this.__values__[this.__index__++];
                            return {
                                done: e,
                                value: t
                            }
                        }, nm.prototype.plant = function(e) {
                            for (var t, n = this; n instanceof nv;) {
                                var r = ij(n);
                                r.__index__ = 0, r.__values__ = i, t ? a.__wrapped__ = r : t = r;
                                var a = r;
                                n = n.__wrapped__
                            }
                            return a.__wrapped__ = e, t
                        }, nm.prototype.reverse = function() {
                            var e = this.__wrapped__;
                            if (e instanceof ny) {
                                var t = e;
                                return this.__actions__.length && (t = new ny(this)), (t = t.reverse()).__actions__.push({
                                    func: au,
                                    args: [i6],
                                    thisArg: i
                                }), new n_(t, this.__chain__)
                            }
                            return this.thru(i6)
                        }, nm.prototype.toJSON = nm.prototype.valueOf = nm.prototype.value = function() {
                            return rR(this.__wrapped__, this.__actions__)
                        }, nm.prototype.first = nm.prototype.head, e4 && (nm.prototype[e4] = function() {
                            return this
                        }), nm
                    }();
                e5._ = t$, r = (function() {
                    return t$
                }).call(t, n, t, e), i !== r && (e.exports = r)
            }).call(this)
        },
        3837: function(e, t, n) {
            (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function() {
                return n(8039)
            }])
        },
        4564: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function(e) {
                let {
                    children: t
                } = e;
                return t
            }, t.suspense = function() {
                let e = Error(r.NEXT_DYNAMIC_NO_SSR_CODE);
                throw e.digest = r.NEXT_DYNAMIC_NO_SSR_CODE, e
            }, (0, n(2648).Z)(n(7294));
            var r = n(2983)
        },
        7645: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function(e, t) {
                let n = s.default,
                    i = {
                        loading: e => {
                            let {
                                error: t,
                                isLoading: n,
                                pastDelay: r
                            } = e;
                            return null
                        }
                    };
                e instanceof Promise ? i.loader = () => e : "function" == typeof e ? i.loader = e : "object" == typeof e && (i = r({}, i, e)), i = r({}, i, t);
                let a = i.loader,
                    o = () => a().then(l);
                if (i.loadableGenerated && delete(i = r({}, i, i.loadableGenerated, {
                        loader: o
                    })).loadableGenerated, "boolean" == typeof i.ssr) {
                    if (!i.ssr) return delete i.ssr, u(o, i);
                    delete i.ssr
                }
                return n(i)
            }, t.noSSR = u;
            var r = n(6495).Z,
                i = n(2648).Z,
                a = (0, n(1598).Z)(n(7294)),
                s = i(n(4588)),
                o = i(n(4564));

            function l(e) {
                return {
                    default: e.default || e
                }
            }

            function u(e, t) {
                delete t.webpack, delete t.modules;
                let n = a.lazy(e),
                    r = t.loading,
                    i = a.default.createElement(r, {
                        error: null,
                        isLoading: !0,
                        pastDelay: !1,
                        timedOut: !1
                    });
                return e => a.default.createElement(a.Suspense, {
                    fallback: i
                }, a.default.createElement(o.default, null, a.default.createElement(n, Object.assign({}, e))))
            }("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", {
                value: !0
            }), Object.assign(t.default, t), e.exports = t.default)
        },
        3644: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.LoadableContext = void 0;
            var r = (0, n(2648).Z)(n(7294));
            let i = r.default.createContext(null);
            t.LoadableContext = i
        },
        4588: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0;
            var r = n(6495).Z,
                i = (0, n(2648).Z)(n(7294)),
                a = n(3644);
            let s = [],
                o = [],
                l = !1;

            function u(e) {
                let t = e(),
                    n = {
                        loading: !0,
                        loaded: null,
                        error: null
                    };
                return n.promise = t.then(e => (n.loading = !1, n.loaded = e, e)).catch(e => {
                    throw n.loading = !1, n.error = e, e
                }), n
            }
            class c {
                promise() {
                    return this._res.promise
                }
                retry() {
                    this._clearTimeouts(), this._res = this._loadFn(this._opts.loader), this._state = {
                        pastDelay: !1,
                        timedOut: !1
                    };
                    let {
                        _res: e,
                        _opts: t
                    } = this;
                    e.loading && ("number" == typeof t.delay && (0 === t.delay ? this._state.pastDelay = !0 : this._delay = setTimeout(() => {
                        this._update({
                            pastDelay: !0
                        })
                    }, t.delay)), "number" == typeof t.timeout && (this._timeout = setTimeout(() => {
                        this._update({
                            timedOut: !0
                        })
                    }, t.timeout))), this._res.promise.then(() => {
                        this._update({}), this._clearTimeouts()
                    }).catch(e => {
                        this._update({}), this._clearTimeouts()
                    }), this._update({})
                }
                _update(e) {
                    this._state = r({}, this._state, {
                        error: this._res.error,
                        loaded: this._res.loaded,
                        loading: this._res.loading
                    }, e), this._callbacks.forEach(e => e())
                }
                _clearTimeouts() {
                    clearTimeout(this._delay), clearTimeout(this._timeout)
                }
                getCurrentValue() {
                    return this._state
                }
                subscribe(e) {
                    return this._callbacks.add(e), () => {
                        this._callbacks.delete(e)
                    }
                }
                constructor(e, t) {
                    this._loadFn = e, this._opts = t, this._callbacks = new Set, this._delay = null, this._timeout = null, this.retry()
                }
            }

            function h(e) {
                return function(e, t) {
                    let n = Object.assign({
                        loader: null,
                        loading: null,
                        delay: 200,
                        timeout: null,
                        webpack: null,
                        modules: null
                    }, t);
                    n.lazy = i.default.lazy(n.loader);
                    let r = null;

                    function s() {
                        if (!r) {
                            let t = new c(e, n);
                            r = {
                                getCurrentValue: t.getCurrentValue.bind(t),
                                subscribe: t.subscribe.bind(t),
                                retry: t.retry.bind(t),
                                promise: t.promise.bind(t)
                            }
                        }
                        return r.promise()
                    }
                    if (!l) {
                        let u = n.webpack ? n.webpack() : n.modules;
                        u && o.push(e => {
                            for (let t of u)
                                if (-1 !== e.indexOf(t)) return s()
                        })
                    }

                    function h(e) {
                        ! function() {
                            s();
                            let e = i.default.useContext(a.LoadableContext);
                            e && Array.isArray(n.modules) && n.modules.forEach(t => {
                                e(t)
                            })
                        }();
                        let t = i.default.createElement(n.loading, {
                            isLoading: !0,
                            pastDelay: !0,
                            error: null
                        });
                        return i.default.createElement(i.default.Suspense, {
                            fallback: t
                        }, i.default.createElement(n.lazy, e))
                    }
                    return h.preload = () => s(), h.displayName = "LoadableComponent", h
                }(u, e)
            }

            function d(e, t) {
                let n = [];
                for (; e.length;) {
                    let r = e.pop();
                    n.push(r(t))
                }
                return Promise.all(n).then(() => {
                    if (e.length) return d(e, t)
                })
            }
            h.preloadAll = () => new Promise((e, t) => {
                d(s).then(e, t)
            }), h.preloadReady = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                return new Promise(t => {
                    let n = () => (l = !0, t());
                    d(o, e).then(n, n)
                })
            }, window.__NEXT_PRELOADREADY = h.preloadReady, t.default = h
        },
        1345: function(e, t, n) {
            "use strict";
            n.d(t, {
                E0: function() {
                    return g
                },
                X9: function() {
                    return m
                },
                iD: function() {
                    return p
                }
            });
            var r = n(9477),
                i = n(7430),
                a = n(7294),
                s = n(6955),
                o = n(1802),
                l = n(4661),
                u = n(2113),
                c = n(1575),
                h = n(4219);
            let d = (e, t, n, r, i) => {
                    n.memoQuaternion.damp(n.quaternion, 4, i), n.quaternion.copy(n.memoQuaternion), r.memoQuaternion.damp(r.quaternion, 4, i), r.quaternion.copy(r.memoQuaternion)
                },
                f = (e, t, n, r, i, a, s) => {
                    i.memoTargetQuaternion.needUpdateTarget ? (t.up.copy(s.upVector), t.lookAt(n), t.rotation.setFromQuaternion(t.quaternion, "XZY"), t.rotation.x = 0, t.rotation.z = 0, t.quaternion.setFromEuler(t.rotation), t.quaternion.slerp(i.quaternion, .5), i.memoTargetQuaternion.copy(t.quaternion), i.memoTargetQuaternion.needUpdateTarget = !1) : (i.memoTargetQuaternion.rotateWithoutUpdateCnt++, i.memoTargetQuaternion.rotateWithoutUpdateCnt >= 6 && (i.memoTargetQuaternion.needUpdateTarget = !0, i.memoTargetQuaternion.rotateWithoutUpdateCnt = 0)), i.memoQuaternion.damp(i.memoTargetQuaternion, 4, a), i.quaternion.copy(i.memoQuaternion), r.memoTargetQuaternion.needUpdateTarget ? (e.up.copy(s.upVector), e.lookAt(n), e.quaternion.multiply(i.memoTargetQuaternion), e.rotation.setFromQuaternion(e.quaternion, "XZY"), e.rotation.x = Math.max(-.6, Math.min(.5, e.rotation.x)), e.quaternion.setFromEuler(e.rotation), r.memoTargetQuaternion.copy(e.quaternion), r.memoTargetQuaternion.needUpdateTarget = !1) : (r.memoTargetQuaternion.rotateWithoutUpdateCnt++, r.memoTargetQuaternion.rotateWithoutUpdateCnt >= 6 && (r.memoTargetQuaternion.needUpdateTarget = !0, r.memoTargetQuaternion.rotateWithoutUpdateCnt = 0)), r.memoQuaternion.damp(r.memoTargetQuaternion, 4, a), r.quaternion.copy(r.memoQuaternion)
                },
                p = (e, t, n, l, u, c, p) => {
                    let m = (0, s.oR)(e => e.gpuTier),
                        g = 24 + 4 * Math.random(),
                        v = Math.PI / 2.1,
                        _ = (0, a.useMemo)(() => new r.Vector3, []),
                        y = e,
                        x = l.current,
                        b = n.current,
                        w = c.current,
                        S = u.current,
                        M = (e, n, r) => {
                            for (let i = 0; i < e.length; i++) {
                                let a = e[i];
                                if (!a || a.playerId === t || a.dontLookAtMe) continue;
                                let s = a.eyePosition,
                                    l = s.distanceTo(p.eyePosition) + ("robot" === a.playerId ? 6 : 0);
                                a.playerId === (0, o.PR)().id && (l = Math.max(l - 10, .5)), !(l > n) && !(l > g) && !(l < .5) && (r.objectY.up.copy(p.upVector), r.objectY.lookAt(s), r.objectY.rotation.setFromQuaternion(r.objectY.quaternion, "YXZ"), r.objectY.rotation.y > v || r.objectY.rotation.y < -v || (r.objectY.rotation.setFromQuaternion(r.objectY.quaternion, "XYZ"), _.copy(s), r.memoTargetPlayerId = a.playerId, n = l))
                            }
                        };
                    (0, i.zX)("postAnimRaf_".concat(t), e => {
                        if (0 === m && "tempId" !== t || !y || !x || !b || !w || !S) return;
                        let {
                            testExperience: n
                        } = (0, h.VB)();
                        if ((t !== (0, o.PR)().id || !n) && y.objectY) {
                            if (p && p.noHeadTracking && (y.needUpdateTarget = !1, y.memoTargetPlayerId = null), y.needUpdateTarget && !p.lookatcrystal ? (_.set(0, 0, 0), M(s.Fm, 999999, y), M(s.Fk, 999999, y), 0 === _.length() && (y.memoTargetPlayerId = null), y.needUpdateTarget = !1) : (y.withoutUpdateCnt++, y.withoutUpdateCnt > 10 && (y.needUpdateTarget = !0, y.withoutUpdateCnt = 0)), p.lookatcrystal && (y.memoTargetPlayerId = "crystal"), y.memoTargetPlayerId) {
                                let r = s.Fm.find(e => y.memoTargetPlayerId === e.playerId);
                                if (r || (r = s.Fk.find(e => y.memoTargetPlayerId === e.playerId)), !r) {
                                    y.needUpdateTarget = !0, d(x, b, w, S, e);
                                    return
                                }
                                _.copy(r.eyePosition ? r.eyePosition : r.position), f(x, b, _, w, S, e, p)
                            } else d(x, b, w, S, e)
                        }
                    })
                },
                m = () => {
                    (0, i.zX)("hideModel", e => {
                        let {
                            hide: t = !0
                        } = e, {
                            localModel: n,
                            instance: r
                        } = (0, c.XV)(), {
                            id: i
                        } = (0, o.PR)();
                        n.position.y = t ? -8888 : 0, n.updateMatrixWorld(), r.setMatrixAt(i, n.matrixWorld)
                    })
                },
                g = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                        {
                            onboarded: n
                        } = (0, o.PR)();
                    if (!n) return;
                    let {
                        firstPerson: r
                    } = (0, l.A8)();
                    e ? (r && (0, i.Kn)("hideModel", {
                        hide: !1
                    }), (0, s.IW)({
                        isCustomising: !0,
                        customisationStep: t
                    }), (0, i.Kn)("anim_".concat((0, o.PR)().id), {
                        name: "inSettings",
                        timeScale: 1
                    }), (0, l.Th)({
                        preventDrag: !0
                    }), (0, i.Kn)("customisationCamera", {
                        callback: () => {
                            (0, s.IW)({
                                ryoikiTenkai: !0
                            })
                        }
                    })) : (r && (0, i.Kn)("hideModel", {
                        hide: !0
                    }), (0, s.IW)({
                        isCustomising: !1,
                        ryoikiTenkai: !1,
                        customisationStep: ""
                    }), (0, i.Kn)("anim_".concat((0, o.PR)().id), {
                        name: "idle" + (.5 > Math.random() ? "_mirror" : ""),
                        blendDuration: 1,
                        timeScale: u.MQ.idle
                    }), (0, l.Th)({
                        preventDrag: !1
                    }), (0, i.Kn)("resetOffsetCamera"))
                }
        },
        1901: function(e, t, n) {
            "use strict";
            n.d(t, {
                T: function() {
                    return s
                }
            });
            var r = n(7297),
                i = n(7379);

            function a() {
                let e = (0, r.Z)(["\n  display: block;\n  svg {\n    width: 100%;\n    height: 100%;\n    max-width: none;\n    margin-top: 0;\n  }\n"]);
                return a = function() {
                    return e
                }, e
            }
            let s = i.ZP.div.withConfig({
                componentId: "sc-ad78894e-0"
            })(a())
        },
        6955: function(e, t, n) {
            "use strict";
            n.d(t, {
                AJ: function() {
                    return E
                },
                CI: function() {
                    return d
                },
                EA: function() {
                    return C
                },
                Fk: function() {
                    return S
                },
                Fm: function() {
                    return w
                },
                IW: function() {
                    return R
                },
                QF: function() {
                    return f
                },
                Wv: function() {
                    return A
                },
                a9: function() {
                    return M
                },
                eR: function() {
                    return p
                },
                oC: function() {
                    return T
                },
                oR: function() {
                    return I
                },
                wC: function() {
                    return m
                },
                y0: function() {
                    return P
                }
            });
            var r = n(7294),
                i = n(9477),
                a = n(4671),
                s = n(374),
                o = n(9240),
                l = n(7430),
                u = n(1802),
                c = n(1345),
                h = n(2113);
            let d = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g,
                f = {
                    startAnim: null,
                    sections: {
                        planseq1: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        head: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        fullhead: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        blue: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        gameplay: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        roadmap: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        planseq2: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        planseq3: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        team: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        },
                        footer: {
                            ref: null,
                            ratio: 0,
                            offsetvw: 0
                        }
                    },
                    planseq1: {
                        value: 0,
                        smooth: 0
                    },
                    fullhead: {
                        value: 0,
                        smooth: 0
                    },
                    head: {
                        value: 0,
                        smooth: 0
                    },
                    blue: {
                        value: 0,
                        smooth: 0
                    },
                    gameplay: {
                        value: 0,
                        smooth: 0
                    },
                    roadmap: {
                        value: 0,
                        smooth: 0
                    },
                    planseq2: {
                        value: 0,
                        smooth: 0
                    },
                    planseq3: {
                        value: 0,
                        smooth: 0
                    },
                    team: {
                        value: 0,
                        smooth: 0
                    },
                    footer: {
                        value: 0,
                        smooth: 0
                    },
                    uscroll: {},
                    runraf: !1,
                    startAnimationFinished: !1
                },
                p = new i.Vector3(300, 1e3, 1200),
                m = {
                    0: {
                        aa: !0,
                        fur: !0,
                        dpr: 1,
                        quality: 2,
                        shadows: !0,
                        bloom: !0
                    },
                    1: {
                        aa: !0,
                        fur: !0,
                        dpr: 1,
                        quality: 2,
                        shadows: !0,
                        bloom: !0
                    },
                    2: {
                        aa: !0,
                        fur: !0,
                        dpr: 1,
                        quality: 2,
                        shadows: !0,
                        bloom: !0
                    },
                    3: {
                        aa: !0,
                        fur: !0,
                        dpr: 1,
                        quality: 3,
                        shadows: !0,
                        bloom: !0
                    }
                },
                g = {
                    backward: !1,
                    forward: !1,
                    left: !1,
                    right: !1
                },
                v = (0, a.Z)((e, t) => {
                    let n = n => {
                        Object.keys(t()).forEach(r => {
                            let i = t()[r];
                            if ("function" != typeof i) {
                                if (r === n) {
                                    let a = {};
                                    a[n] = !i, e(a)
                                } else if (i) {
                                    let s = {};
                                    s[r] = !1, e(s)
                                }
                            }
                        })
                    };
                    return {
                        navigate: n,
                        auth: !1,
                        settings: !1,
                        menu: !1
                    }
                }),
                _ = e => v(e, s.Z);
            Object.assign(_, v);
            let {
                getState: y,
                setState: x
            } = v, b = (0, a.Z)((e, t) => ({
                playerApi: null,
                router: null,
                portalAnim: (0, r.createRef)(null),
                outOfBoundCount: 0,
                players: [],
                activateArmy: !0,
                playersPublic: {},
                allMessages: [],
                totalMessages: 0,
                db: null,
                dom: (0, r.createRef)(null),
                control: (0, r.createRef)(null),
                actions: {
                    goonboarding: () => {},
                    reset: () => {},
                    goTop: () => {}
                },
                api: null,
                flowmap: null,
                viewMatrixCamera: null,
                gpuTierAdded: !1,
                fadeout: !1,
                controlsRef: (0, r.createRef)(null),
                camera: !1,
                freecam: !1,
                headScrolled: !1,
                goBackMetaverse: !1,
                showLoadingMetaverse: !1,
                hasSeenExperienceOnce: !1,
                hasSeenTry: !1,
                hasScrolled: !1,
                dpr: 1,
                quality: 1,
                aa: !0,
                fur: !0,
                bloom: !0,
                shadows: !1,
                isCustomising: !1,
                isMobile: null,
                gpuTier: 0,
                ryoikiTenkai: !0,
                customisationStep: "",
                isIdle: !1,
                isAfk: !1,
                toasts: [],
                totalToastsChange: 0,
                showPlayerName: !1,
                controls: g,
                onboardingStep: 0,
                debug: !0,
                editor: !1,
                gemQuestStarted: !1,
                debugShadows: !1,
                throttled: 100,
                orbit: !1,
                canInteractWith: void 0,
                stats: !0,
                isWritingMsg: !1,
                joinedRoomTime: 0,
                cinematic: 0,
                isEditingName: !1,
                blockSendMessage: !1,
                hiddenUi: !1,
                autoWalkOn: !1,
                autoWalkDestinations: [{
                    dest: [204.09, 32.52, -46.83],
                    velocity: 12,
                    onReach: () => {
                        (0, l.Kn)("anim_".concat((0, u.PR)().id), {
                            name: "glide",
                            blendDuration: .25,
                            timeScale: h.MQ.glide
                        })
                    }
                }],
                updateFont: n => {
                    if ("/fonts/NotoSansRegularLatin.woff" === t().font) {
                        let r = "/fonts/NotoSansRegular".concat(n, ".woff");
                        (0, o.C5)({
                            font: r
                        }, () => {
                            e({
                                font: r
                            }), (0, l.Kn)("updateFont", {
                                font: r
                            })
                        })
                    }
                },
                pushToast: n => {
                    let {
                        msg: r,
                        icon: i = "warn"
                    } = n, {
                        toasts: a,
                        totalToastsChange: s
                    } = t();
                    a.push({
                        msg: r,
                        icon: i,
                        t: performance.now(),
                        id: "_toast" + s,
                        removing: !1
                    }), e({
                        toasts: a,
                        totalToastsChange: s + 1
                    })
                },
                removeToastById: n => {
                    let {
                        toasts: r,
                        totalToastsChange: i
                    } = t(), a = r.filter(e => e.id !== n);
                    e({
                        toasts: a,
                        totalToastsChange: i + 1
                    })
                },
                font: "/fonts/NotoSansRegularLatin.woff",
                get: t,
                set: e,
                addToGeneralChat: (n, r) => e(e => {
                    e.allMessages.push({
                        playerId: r,
                        message: n,
                        timesent: new Date
                    });
                    let i = {
                        allMessages: e.allMessages,
                        totalMessages: e.allMessages.length + 1
                    };
                    return d.test(n) && t().updateFont("JP"), i
                }),
                changeCustomisationStep: n => {
                    let r = ["", "colors", "name"],
                        i = r.indexOf(t().customisationStep);
                    if (0 === i && -1 === n || i === r.length - 1 && 1 === n) {
                        (0, c.E0)(!1);
                        return
                    }
                    let a = i + n;
                    "" === r[a] && (0, c.E0)(!1), e({
                        customisationStep: r[a]
                    })
                }
            })), w = [], S = [], M = 3.78, T = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 ? arguments[2] : void 0;
                return n || (n = w.find(t => t.playerId === e)) || (n = S.find(t => t.playerId === e)), M * (t ? .85 : 1) * (n ? parseFloat(n.height) : 1) + (n && (n.activAnimations.glide || n.activAnimations.glide_mirror) ? 1 : 0)
            }, A = new i.Vector3(0, 1, 0);
            A.resetToDefault = function() {
                this.set(0, 1, 0)
            };
            let E = new i.Vector3(0, 1, 0);
            E.resetToDefault = function() {
                this.set(0, 0, 1)
            };
            let C = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = w.find(t => t.playerId === e),
                        r = S.find(t => t.playerId === e);
                    if (n || r) return n || r;
                    let a = {
                        playerId: e,
                        position: new i.Vector3,
                        quaternion: new i.Quaternion,
                        activPetAnimations: {},
                        activAnimations: {},
                        activAdditiveAnimations: {},
                        color: new i.Vector3(u.cE[0], u.cE[1], u.cE[2]),
                        holo: 0,
                        fly: 0,
                        flyLerp: 0,
                        height: 1,
                        heightLerp: 1,
                        dirVector: new i.Vector3(0, 0, 1),
                        upVector: new i.Vector3(0, 1, 0),
                        eyePosition: new i.Vector3(0, 0, 0),
                        playingEmote: !1,
                        noHeadTracking: !1,
                        isCharacterInstance: !0,
                        teleport: !1,
                        ...t
                    };
                    return a.isCharacterInstance ? w.push(a) : S.push(a), a
                },
                I = e => b(e, s.Z);
            Object.assign(I, b);
            let {
                getState: P,
                setState: R
            } = b
        },
        1575: function(e, t, n) {
            "use strict";
            n.d(t, {
                EA: function() {
                    return c
                },
                WL: function() {
                    return l
                },
                XV: function() {
                    return u
                }
            });
            var r = n(4671),
                i = n(374),
                a = n(8597),
                s = n(7294);
            let o = (0, r.Z)((0, a.XR)(() => ({
                    instance: null,
                    petInstance: null,
                    characterModel: null,
                    dummy: null,
                    ref: (0, s.createRef)(null),
                    localModel: null,
                    move: !1,
                    moveAlongZ: !1,
                    force: 10,
                    forceFactor: 0,
                    turnFactor: 0,
                    jumpVelocity: 30,
                    yAxisCtrl: 0,
                    xAxisCtrl: 0,
                    instanceReady: !1
                }))),
                l = e => o(e, i.Z);
            Object.assign(l, o);
            let {
                getState: u,
                setState: c
            } = o
        },
        4219: function(e, t, n) {
            "use strict";
            n.d(t, {
                KG: function() {
                    return l
                },
                N1: function() {
                    return s
                },
                VB: function() {
                    return o
                }
            }), n(7294);
            var r = n(4671),
                i = n(374);
            let a = (0, r.Z)((e, t) => ({
                    showSpinnerLoading: !1,
                    showChat: !1,
                    focusChat: !1,
                    showEmoteWheel: !1,
                    showControlModal: !1,
                    openWebFrame: "",
                    testExperience: !1,
                    startedMoved: !1
                })),
                s = e => a(e, i.Z);
            Object.assign(s, a);
            let {
                getState: o,
                setState: l
            } = a
        },
        4504: function(e, t, n) {
            "use strict";
            n.d(t, {
                N1: function() {
                    return u
                },
                U2: function() {
                    return o
                },
                nZ: function() {
                    return l
                }
            });
            var r = n(4671),
                i = n(374),
                a = n(1575);
            let s = (0, r.Z)((e, t) => ({
                    active: !0,
                    startLoadTimestamp: 0,
                    firstLoad: !0,
                    fetching: !1,
                    hideLoader: () => {
                        let {
                            characterModel: t
                        } = (0, a.XV)();
                        t && e({
                            active: !1
                        })
                    }
                })),
                o = e => s(e, i.Z);
            Object.assign(o, s);
            let {
                getState: l,
                setState: u
            } = s
        },
        1802: function(e, t, n) {
            "use strict";
            n.d(t, {
                LM: function() {
                    return u
                },
                PR: function() {
                    return c
                },
                av: function() {
                    return h
                },
                cE: function() {
                    return s
                }
            });
            var r = n(4671),
                i = n(374),
                a = n(1766);
            let s = [0, 9, 4],
                o = {
                    id: "tempId",
                    ref: null,
                    user: null,
                    email: null,
                    quaternion: [0, 0, 0, 1],
                    position: [.25, 2.5, 2],
                    messages: [],
                    writingMessage: !1,
                    animation: 3,
                    name: "",
                    skin: {
                        color: s,
                        height: 1
                    }
                },
                l = (0, r.Z)((e, t) => ({ ...o,
                    settings: {
                        hideUi: !1,
                        camera: {
                            invert: !1
                        },
                        audio: {
                            mute: !1,
                            bgm: .8,
                            sfx: 1
                        },
                        accessibility: {
                            biggerText: !1
                        },
                        privacy: {
                            showNames: !0,
                            offline: !1,
                            showChat: !0,
                            showCharacter: !0,
                            alwaysShowChat: !0
                        }
                    },
                    toggleMute: () => {
                        let n = t().settings,
                            r = !n.audio.mute;
                        n.audio.mute = r, e({
                            settings: n
                        }), a.Howler.mute(r)
                    }
                })),
                u = e => l(e, i.Z);
            Object.assign(u, l);
            let {
                getState: c,
                setState: h
            } = l
        },
        2113: function(e, t, n) {
            "use strict";
            n.d(t, {
                MQ: function() {
                    return m
                },
                dN: function() {
                    return _
                },
                l0: function() {
                    return p
                }
            });
            var r = n(9477),
                i = n(7430),
                a = n(7294);
            let s = ["leanright", "leanright_mirror", "leanFoward", "leanback", "land"],
                o = ["jump", "jump_mirror", "land", "thankyou", "thankyou_mirror", "bow", "meditate"],
                l = ["idle", "idle_mirror"],
                u = ["land"],
                c = ["thankyou", "bow"],
                h = ["meditate", "meditateyoyo", "dance", "bow", "thankyou"],
                d = ["dance", "bow", "thankyou", "inSettings"],
                f = ["meditateyoyo"],
                p = {
                    0: "bow",
                    1: "dance",
                    2: "glide",
                    3: "idle",
                    4: "jump",
                    5: "kneel",
                    6: "kneelidle",
                    7: "land",
                    8: "leanback",
                    9: "leanFoward",
                    10: "leanright",
                    11: "meditate",
                    12: "meditateyoyo",
                    13: "run",
                    14: "slide",
                    15: "thankyou",
                    16: "turnright",
                    17: "bow_mirror",
                    18: "dance_mirror",
                    19: "glide_mirror",
                    20: "idle_mirror",
                    21: "jump_mirror",
                    22: "kneel_mirror",
                    23: "kneelidle_mirror",
                    24: "land_mirror",
                    25: "leanback_mirror",
                    26: "leanFoward_mirror",
                    27: "leanright_mirror",
                    28: "meditate_mirror",
                    29: "meditateyoyo_mirror",
                    30: "run_mirror",
                    31: "slide_mirror",
                    32: "thankyou_mirror",
                    33: "turnright_mirror",
                    34: "default",
                    35: "default_mirror",
                    36: "walk",
                    37: "walk_mirror",
                    38: "inSettings"
                },
                m = {
                    bow: .3,
                    dance: .6,
                    glide: .3,
                    idle: .2,
                    jump: .6,
                    kneel: 1,
                    kneelidle: 1,
                    land: 1,
                    leanback: 1,
                    leanFoward: 1,
                    leanright: 1,
                    meditate: .05,
                    meditateyoyo: .025,
                    run: 1,
                    slide: .3,
                    thankyou: .3,
                    turnright: .5,
                    default: 1,
                    walk: .6,
                    inSettings: 1
                },
                g = {
                    run: [{
                        frame: 11,
                        event: "leftFoot"
                    }, {
                        frame: 23,
                        event: "rightFoot"
                    }]
                },
                v = {};
            Object.keys(p).forEach(e => {
                v[p[e]] = parseInt(e)
            });
            let _ = (e, t, n, v) => {
                let _ = (0, a.useRef)({}),
                    [y] = (0, a.useState)(() => new r.AnimationMixer(e)),
                    x = function(e) {
                        if (u.includes(e.action._clip.name) && e.action.fadeOut(.01), c.includes(e.action._clip.name) && (0, i.Kn)("anim_".concat(n), {
                                name: "idle",
                                play: !0,
                                reset: !0,
                                timeScale: m.idle
                            }), e.action.framesCallBacks.length > 0)
                            for (let t = 0; t < e.action.framesCallBacks.length; t++) e.action.framesCallBacks[t].played = !1
                    },
                    b = function(e) {
                        if (e.action.framesCallBacks.length > 0)
                            for (let t = 0; t < e.action.framesCallBacks.length; t++) e.action.framesCallBacks[t].played = !1;
                        l.includes(e.action._clip.name) && (0, i.Kn)("anim_".concat(n), {
                            name: e.action._clip.name.replace("_mirror", "") + (.5 > Math.random() ? "_mirror" : ""),
                            play: !0,
                            blendDuration: .4,
                            timeScale: m[e.action._clip.name.replace("_mirror", "")]
                        })
                    };
                (0, a.useEffect)(() => (y.addEventListener("finished", x), y.addEventListener("loop", b), () => {
                    y.removeEventListener("finished", x), y.removeEventListener("loop", b)
                }));
                let w = (0, a.useMemo)(() => {
                        let a = {};
                        return t.forEach(t => Object.defineProperty(a, t.name, {
                            enumerable: !0,
                            get() {
                                if (e) {
                                    if (_.current[t.name] && _.current[t.name].rootUuid === e.uuid) return _.current[t.name];
                                    _.current[t.name] = y.clipAction(t, e), _.current[t.name].rootUuid = e.uuid, o.includes(t.name) && (_.current[t.name].clampWhenFinished = !0, _.current[t.name].loop = r.LoopOnce), f.includes(t.name) && (_.current[t.name].loop = r.LoopPingPong), _.current[t.name].framesCallBacks = [], g[t.name] && g[t.name].forEach(e => {
                                        let n = e.frame / _.current[t.name]._clip.tracks[0].times.length * 100;
                                        _.current[t.name].framesCallBacks.push({
                                            eventPctMin: n,
                                            event: e.event
                                        })
                                    });
                                    let a = _.current[t.name]._update;
                                    return _.current[t.name]._update = function(e, t, r, s) {
                                        if (a.call(this, e, t, r, s), this.framesCallBacks.length > 0)
                                            for (let o = 0; o < this.framesCallBacks.length; o++) {
                                                let l = this.framesCallBacks[o],
                                                    u = Math.floor(this.time / this._clip.duration * 100);
                                                !l.played && l.eventPctMin * this.timeScale <= u * this.timeScale && (l.played = !0, (0, i.Kn)("sound_".concat(n), {
                                                    name: l.event
                                                }))
                                            }
                                    }, _.current[t.name]
                                }
                            }
                        })), {
                            ref: e,
                            clips: t,
                            actions: a,
                            names: t.map(e => e.name),
                            mixer: y
                        }
                    }, [e]),
                    S = t => {
                        let {
                            name: r,
                            play: a = !0,
                            reset: o = !1,
                            blendDuration: l = 1,
                            timeScale: u = 1
                        } = t;
                        if (!e) return null;
                        if (!v) return;
                        let {
                            actions: c
                        } = w, f = c[r], p = r.replace("_mirror", "");
                        if (h.includes(p) && (v.playingEmote = a), d.includes(p) && (v.noHeadTracking = a), f) {
                            if (a) {
                                if (f.fadingOut && f._scheduleFading(l, f.getEffectiveWeight(), 1), f.fadingOut = !1, f.setEffectiveTimeScale(u), o ? f.reset().fadeIn(l).play() : 0 !== f.weight && f.isRunning() ? f.play() : (f.paused = !1, f.enabled = !0, f.fadeIn(l).play()), s.includes(r)) v.activAdditiveAnimations[r] = !0;
                                else if (!v.activAnimations.hasOwnProperty(r)) {
                                    for (let g in v.activAnimations) {
                                        let _ = g.replace("_mirror", "");
                                        h.includes(_) && !h.includes(p) && (v.playingEmote = !1), d.includes(_) && !d.includes(p) && (v.noHeadTracking = !1), c[g].fadingOut = !0, c[g].fadeOut(.5), delete v.activAnimations[g]
                                    }
                                    v.activAnimations[r] = !0
                                }
                            } else if (!a && !1 === f.fadingOut) {
                                if (f.fadingOut = !0, f._scheduleFading(l, f.getEffectiveWeight(), 0), s.includes(r)) delete v.activAdditiveAnimations[r];
                                else
                                    for (let y in v.activAnimations) y === r && delete v.activAnimations[y];
                                0 === Object.keys(v.activAnimations).length && (0, i.Kn)("anim_".concat(n), {
                                    name: "default",
                                    play: !0,
                                    blendDuration: .2,
                                    timeScale: m.default
                                })
                            }
                        }
                    };
                return (0, i.zX)("anim_".concat(n), S), v.initAnim && S({
                    name: p[v.initAnim],
                    play: !0,
                    timeScale: m[p[v.initAnim].replace("_mirror", "")]
                }), (0, a.useEffect)(() => () => {
                    _.current = {}, Object.values(w.actions).forEach(t => {
                        e && y.uncacheAction(t, e)
                    })
                }, []), [w]
            }
        },
        8039: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return ee
                }
            });
            var r = n(7297),
                i = n(5893),
                a = n(1163),
                s = n(6955),
                o = n(7294),
                l = n(9008),
                u = n.n(l);
            let c = "https://meta ninjaz .co/",
                h = "meta ninjaz is a Web-First Metaverse. A barrier-free experience for millions of users.",
                d = "meta ninjaz ",
                f = e => {
                    let {
                        title: t = "meta ninjaz "
                    } = e;
                    return (0, i.jsx)(i.Fragment, {
                        children: (0, i.jsxs)(u(), {
                            children: [(0, i.jsx)("meta", {
                                charSet: "utf-8"
                            }), (0, i.jsx)("meta", {
                                name: "language",
                                content: "english"
                            }), (0, i.jsx)("meta", {
                                httpEquiv: "content-type",
                                content: "text/html"
                            }), (0, i.jsx)("meta", {
                                name: "author",
                                content: d
                            }), (0, i.jsx)("meta", {
                                name: "designer",
                                content: d
                            }), (0, i.jsx)("meta", {
                                name: "publisher",
                                content: d
                            }), (0, i.jsx)("title", {
                                children: t
                            }), (0, i.jsx)("meta", {
                                name: "description",
                                content: h
                            }), (0, i.jsx)("meta", {
                                name: "keywords",
                                content: "metaverse, web3, nfts"
                            }), (0, i.jsx)("meta", {
                                name: "robots",
                                content: "index,follow"
                            }), (0, i.jsx)("meta", {
                                name: "distribution",
                                content: "web"
                            }), (0, i.jsx)("meta", {
                                name: "og:title",
                                content: t
                            }), (0, i.jsx)("meta", {
                                name: "og:type",
                                content: "site"
                            }), (0, i.jsx)("meta", {
                                name: "og:url",
                                content: c
                            }), (0, i.jsx)("meta", {
                                name: "og:image",
                                content: c + "icons/ogp.png"
                            }), (0, i.jsx)("meta", {
                                name: "og:site_name",
                                content: t
                            }), (0, i.jsx)("meta", {
                                name: "og:description",
                                content: h
                            }), (0, i.jsx)("meta", {
                                name: "twitter:title",
                                content: t
                            }), (0, i.jsx)("meta", {
                                name: "twitter:description",
                                content: h
                            }), (0, i.jsx)("meta", {
                                name: "twitter:site",
                                content: "@scrataco"
                            }), (0, i.jsx)("meta", {
                                name: "twitter:card",
                                content: "summary_large_image"
                            }), (0, i.jsx)("meta", {
                                name: "twitter:image",
                                content: c + "icons/twitter.png"
                            }), (0, i.jsx)("link", {
                                rel: "apple-touch-icon",
                                href: "/icons/apple-touch-icon.png"
                            }), (0, i.jsx)("link", {
                                rel: "apple-touch-icon",
                                sizes: "16x16",
                                href: "/icons/favicon-16x16.png"
                            }), (0, i.jsx)("link", {
                                rel: "apple-touch-icon",
                                sizes: "32x32",
                                href: "/icons/favicon-32x32.png"
                            }), (0, i.jsx)("link", {
                                rel: "apple-touch-icon",
                                sizes: "180x180",
                                href: "/icons/apple-touch-icon.png"
                            }), (0, i.jsx)("link", {
                                rel: "manifest",
                                href: "/manifest.json"
                            }), (0, i.jsx)("link", {
                                rel: "mask-icon",
                                color: "#000000",
                                href: "/icons/favicon.svg"
                            }), (0, i.jsx)("link", {
                                rel: "apple-touch-startup-image",
                                href: "/startup.png"
                            }), (0, i.jsx)("meta", {
                                name: "viewport",
                                content: "width=device-width, minimum-scale=1, initial-scale=1.0, maximum-scale=5, viewport-fit=cover"
                            }), (0, i.jsx)("meta", {
                                name: "theme-color",
                                content: "#000"
                            }), (0, i.jsx)("link", {
                                rel: "icon",
                                type: "image/svg+xml",
                                href: "/icons/favicon.svg"
                            })]
                        })
                    })
                };
            var p = n(5152),
                m = n.n(p),
                g = n(5518),
                v = n(7379);
            n(7112);
            var _ = n(4504),
                y = n(1472);

            function x() {
                let e = (0, r.Z)(["\n  position: fixed;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  text-align: center;\n  z-index: 99999;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  &::before {\n    content: ' ';\n    display: block;\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background: #fff;\n    z-index: 0;\n  }\n  & > div {\n    position: relative;\n    z-index: 1;\n  }\n  &.hide {\n    &::before {\n      content: none;\n    }\n\n    svg {\n      transition: transform 0.3s cubic-bezier(0.25, 0.005, 0.24, 0.905);\n      transform: translate3d(0, 60px, 0);\n    }\n\n    .loadProgBar {\n      transition: transform 0.3s cubic-bezier(0.25, 0.005, 0.24, 0.905) 0.1s;\n      transform: scaleX(0) translateZ(0);\n    }\n  }\n"]);
                return x = function() {
                    return e
                }, e
            }

            function b() {
                let e = (0, r.Z)(["\n  display: block;\n  width: 220px;\n  & > div {\n    padding: 0 10px 15px;\n    overflow: hidden;\n  }\n\n  @media all and (max-width: 700px) {\n    width: 180px;\n    & > div {\n      padding: 0 10px 12px;\n    }\n    svg {\n      height: auto;\n    }\n  }\n"]);
                return b = function() {
                    return e
                }, e
            }

            function w() {
                let e = (0, r.Z)(["\n  display: block;\n  width: 180px;\n  height: 2px;\n  background-color: #eaeaea;\n  margin: 0 auto;\n  position: relative;\n\n  &::before,\n  &::after {\n    content: ' ';\n    display: block;\n    position: absolute;\n    top: 0;\n    width: 2px;\n    height: 2px;\n    background: #ff8800;\n    transform-origin: left center;\n  }\n\n  &::before {\n    left: -8px;\n  }\n\n  &::after {\n    right: -8px;\n  }\n\n  @media all and (max-width: 700px) {\n    width: 148px;\n  }\n"]);
                return w = function() {
                    return e
                }, e
            }

            function S() {
                let e = (0, r.Z)(["\n  display: block;\n  width: 180px;\n  height: 2px;\n  transform: scaleX(0) translateZ(0);\n  transition: transform 1s ease;\n  background: #ff8800;\n  margin: 0 auto;\n\n  @media all and (max-width: 700px) {\n    width: 148px;\n  }\n"]);
                return S = function() {
                    return e
                }, e
            }
            let M = (0, v.ZP)(y.a.div).withConfig({
                    componentId: "sc-df9972ce-0"
                })(x()),
                T = v.ZP.div.withConfig({
                    componentId: "sc-df9972ce-1"
                })(b()),
                A = (0, v.ZP)(y.a.div).withConfig({
                    componentId: "sc-df9972ce-2"
                })(w()),
                E = (0, v.ZP)(y.a.div).withConfig({
                    componentId: "sc-df9972ce-3"
                })(S());
            var C = n(9521),
                I = n(1901);
            let P = e => {
                    let {
                        color: t = "#242424",
                        ...n
                    } = e;
                    return (0, i.jsx)(I.T, { ...n,
                        children: (0, i.jsxs)("svg", {
                            width: "220",
                            height: "45",
                            viewBox: "0 0 780 159",
                            fill: "none",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: [(0, i.jsx)("path", {
                                fillRule: "evenodd",
                                clipRule: "evenodd",
                                d: "M36.535 14.576c-14.704 0-21.959 8.388-21.959 15.44 0 3.159 1.61 6.21 5.871 9.102 4.383 2.974 10.944 5.259 18.82 6.417 8.588 1.263 17.635 3.165 24.61 7.46 3.619 2.227 6.842 5.19 9.127 9.154 2.294 3.98 3.407 8.562 3.407 13.66 0 9.147-5.059 16.82-12.026 21.943-6.971 5.125-16.25 8.073-26.18 8.073-9.928 0-19.207-2.948-26.178-8.073C5.059 92.63 0 84.956 0 75.808a7.288 7.288 0 1 1 14.576 0c0 3.405 1.862 7.096 6.084 10.2 4.22 3.101 10.399 5.24 17.546 5.24s13.326-2.139 17.545-5.24c4.223-3.104 6.084-6.795 6.084-10.2 0-2.924-.62-4.923-1.46-6.38-.848-1.471-2.158-2.802-4.139-4.021-4.221-2.6-10.633-4.207-19.09-5.451-9.172-1.349-18.07-4.153-24.884-8.777C5.326 46.472 0 39.41 0 30.017 0 11.964 17.087 0 36.535 0c13.376 0 28.307 6.424 34.85 23.575a7.288 7.288 0 1 1-13.618 5.196c-3.913-10.257-12.45-14.195-21.233-14.195Z",
                                fill: t
                            }), (0, i.jsx)("path", {
                                d: "M140.675 11.673c-2.179-3.09-6.417-4.004-9.374-1.647-12.121 9.66-19.89 24.55-19.89 41.254 0 29.117 23.605 52.721 52.722 52.721 29.118 0 52.722-23.604 52.722-52.722 0-16.857-7.911-31.866-20.224-41.517-2.952-2.314-7.149-1.398-9.316 1.664-2.466 3.483-1.31 8.308 1.904 11.116 8.004 6.993 13.06 17.275 13.06 28.737 0 21.068-17.079 38.146-38.146 38.146s-38.146-17.078-38.146-38.145c0-11.354 4.961-21.55 12.833-28.538 3.172-2.815 4.3-7.603 1.855-11.069Z",
                                fill: t
                            }), (0, i.jsx)("path", {
                                d: "M166.045 14.685a2 2 0 0 1-3.268 0l-8.14-11.532C153.702 1.83 154.649 0 156.271 0h16.28c1.622 0 2.569 1.829 1.634 3.153l-8.14 11.532ZM304.577 90.868c21.068 0 38.146-17.079 38.146-38.146V7.289a7.289 7.289 0 0 1 14.576-.001v45.434c0 29.117-23.604 52.722-52.722 52.722-29.117 0-52.722-23.605-52.722-52.722V7.288a7.288 7.288 0 0 1 14.577 0v45.434c0 21.067 17.078 38.146 38.145 38.146Z",
                                fill: t
                            }), (0, i.jsx)("path", {
                                fillRule: "evenodd",
                                clipRule: "evenodd",
                                d: "M445.15 14.832c-21.068 0-38.146 17.078-38.146 38.146 0 21.067 17.078 38.146 38.146 38.146 21.067 0 38.146-17.079 38.146-38.146 0-21.068-17.079-38.146-38.146-38.146Zm-52.722 38.146c0-29.118 23.604-52.722 52.722-52.722 29.117 0 52.722 23.604 52.722 52.722 0 29.117-23.605 52.722-52.722 52.722-29.118 0-52.722-23.605-52.722-52.722Z",
                                fill: t
                            }), (0, i.jsx)("path", {
                                fillRule: "evenodd",
                                clipRule: "evenodd",
                                d: "M490.584 45.188a7.288 7.288 0 0 1 7.288 7.288v53.791c0 29.117-23.604 52.722-52.722 52.722-23.932 0-44.122-15.94-50.568-37.766a7.288 7.288 0 0 1 13.979-4.129c4.667 15.8 19.292 27.318 36.589 27.318 21.068 0 38.146-17.078 38.146-38.145v-53.79a7.288 7.288 0 0 1 7.288-7.288Z",
                                fill: t
                            }), (0, i.jsx)("path", {
                                d: "M484.983 3.851C483.807 2.57 484.717.5 486.458.5h15.453a2 2 0 0 1 2 2v16.858c0 1.824-2.242 2.696-3.474 1.352L484.983 3.85Z",
                                fill: t
                            }), (0, i.jsx)("path", {
                                fillRule: "evenodd",
                                clipRule: "evenodd",
                                d: "M586.021 14.576c-21.068 0-38.146 17.079-38.146 38.146s17.078 38.146 38.146 38.146a37.939 37.939 0 0 0 21.483-6.62 7.288 7.288 0 0 1 8.22 12.037 52.51 52.51 0 0 1-29.703 9.159c-29.118 0-52.722-23.605-52.722-52.722C533.299 23.604 556.903 0 586.021 0c29.117 0 52.722 23.604 52.722 52.722v7.288h-52.722a7.288 7.288 0 0 1 0-14.576h37.45c-3.401-17.581-18.875-30.858-37.45-30.858ZM726.465 14.576c-21.067 0-38.146 17.079-38.146 38.146v45.433h-7.285 7.285a7.288 7.288 0 1 1-14.576.001h7.288-7.288v-85.53a7.288 7.288 0 0 1 14.576 0v3.702C697.92 6.268 711.461 0 726.465 0c29.118 0 52.722 23.604 52.722 52.722v45.434h-14.576V52.722c0-21.067-17.078-38.146-38.146-38.146Zm45.434 90.868a7.288 7.288 0 0 1-7.288-7.288h14.576a7.288 7.288 0 0 1-7.288 7.288Z",
                                fill: t
                            })]
                        })
                    })
                },
                R = () => {
                    let {
                        progress: e,
                        loaded: t,
                        active: n
                    } = (0, C.S)(), r = (0, _.U2)(e => e.active), a = (0, y.useTransition)(r || n, {
                        from: {
                            opacity: 0
                        },
                        enter: {
                            opacity: 1
                        },
                        leave: {
                            opacity: 1
                        },
                        config: y.config.gentle,
                        onRest: () => {}
                    });
                    return (0, o.useEffect)(() => {
                        (0, _.N1)({
                            startLoadTimestamp: Date.now()
                        })
                    }, []), (0, o.useEffect)(() => {
                        if (100 === e && t) {
                            let n = setInterval(() => {
                                Date.now() - (0, _.nZ)().startLoadTimestamp > 3e3 && clearInterval(n)
                            }, 100)
                        }
                    }, [t, e]), a((t, n) => n && (0, i.jsx)(M, {
                        style: t,
                        className: r ? "" : "hide",
                        children: (0, i.jsxs)("div", {
                            children: [(0, i.jsx)(T, {
                                children: (0, i.jsx)("div", {
                                    children: (0, i.jsx)(P, {})
                                })
                            }), (0, i.jsx)(A, {
                                className: "loadProgBar",
                                style: t,
                                children: (0, i.jsx)(E, {
                                    style: {
                                        transform: "scaleX(".concat(e / 100, ") translateZ(0)")
                                    }
                                })
                            })]
                        })
                    }))
                },
                L = () => (0, i.jsx)(R, {});

            function D() {
                let e = (0, r.Z)(["\n  position: fixed;\n  bottom: 24px;\n  right: 24px;\n  width: 60px;\n  height: 30px;\n"]);
                return D = function() {
                    return e
                }, e
            }

            function k() {
                let e = (0, r.Z)(["\n  position: absolute;\n  display: block;\n  width: auto;\n  right: 60px;\n  white-space: nowrap;\n  top: 0;\n  font-size: 14px;\n  line-height: 30px;\n  color: #b6b6b6;\n  letter-spacing: 0.05em;\n  text-transform: uppercase;\n"]);
                return k = function() {
                    return e
                }, e
            }

            function U() {
                let e = (0, r.Z)(["\n  0%  {transform: scale(0)}\n  100% {transform: scale(1.0)}\n"]);
                return U = function() {
                    return e
                }, e
            }

            function O() {
                let e = (0, r.Z)(["\n  0%  {opacity: 1}\n  100% {opacity: 0}\n"]);
                return O = function() {
                    return e
                }, e
            }

            function F() {
                let e = (0, r.Z)(["\n  width: 30px;\n  height: 30px;\n  position: absolute;\n  border-radius: 50%;\n  animation: ", ", ", ";\n  border: thick solid #0e0e0e;\n  border-radius: 50%;\n  opacity: 1;\n  top: 0;\n  left: 20px;\n  animation-fill-mode: both;\n  animation-duration: 2s;\n  animation-iteration-count: infinite;\n  animation-timing-function: cubic-bezier(0.165, 0.84, 0.44, 1),\n    cubic-bezier(0.3, 0.61, 0.355, 1);\n  animation-delay: ", ";\n"]);
                return F = function() {
                    return e
                }, e
            }
            let N = (0, v.ZP)(y.a.div).withConfig({
                    componentId: "sc-142f4656-0"
                })(D()),
                B = (0, v.ZP)(y.a.div).withConfig({
                    componentId: "sc-142f4656-1"
                })(k()),
                z = [(0, v.F4)(U()), (0, v.F4)(O())],
                G = (0, v.ZP)(y.a.div).withConfig({
                    componentId: "sc-142f4656-2"
                })(F(), z[0], z[1], e => e.primary ? "-1s" : "0s"),
                V = () => {
                    let [e, t, n] = (0, _.U2)(e => [e.fetching, e.fetchingText, e.active]), r = (0, y.useTransition)(e && !n, {
                        from: {
                            opacity: 0
                        },
                        enter: {
                            opacity: 1
                        },
                        leave: {
                            opacity: 0
                        },
                        config: y.config.gentle
                    });
                    return r((e, n) => n && (0, i.jsx)(N, {
                        style: e,
                        children: (0, i.jsxs)("div", {
                            children: [(0, i.jsx)(B, {
                                children: t || "FETCHING DATA"
                            }), (0, i.jsxs)("div", {
                                children: [(0, i.jsx)(G, {
                                    primary: "true"
                                }), (0, i.jsx)(G, {})]
                            })]
                        })
                    }))
                },
                W = () => (0, i.jsx)(V, {});
            var H = n(5678),
                j = n(6486),
                q = n(4298),
                X = n.n(q);

            function Z() {
                let e = (0, r.Z)(["\n    html,\n    body,\n    #__next {\n      width: 100%;\n      height: 100%;\n      margin: 0;\n      padding: 0;\n      top: 0;\n      left: 0;\n      overflow: hidden;\n      background-color: #ffffff;\n    }\n    canvas {\n      position: fixed;\n      background-color: #ffffff;\n    }\n  "]);
                return Z = function() {
                    return e
                }, e
            }
            let Y = m()(() => Promise.all([n.e(444), n.e(839), n.e(609), n.e(672), n.e(673), n.e(152)]).then(n.bind(n, 9152)), {
                    loadableGenerated: {
                        webpack: () => [9152]
                    },
                    ssr: !1
                }),
                $ = null;
            $ = g.nI ? m()(() => Promise.all([n.e(839), n.e(955)]).then(n.bind(n, 4955)), {
                loadableGenerated: {
                    webpack: () => [4955]
                },
                ssr: !0
            }) : m()(() => n.e(687).then(n.bind(n, 7687)), {
                loadableGenerated: {
                    webpack: () => [7687]
                },
                ssr: !0
            });
            let J = "";
            J = (0, v.vJ)(Z());
            let K = () => (0, i.jsxs)("div", {
                    children: [(0, i.jsx)(X(), {
                        strategy: "lazyOnload",
                        src: "https://www.googletagmanager.com/gtag/js?id=G-SPQY5ELRRW"
                    }), (0, i.jsx)(X(), {
                        strategy: "lazyOnload",
                        id: "gtagscratapromo",
                        children: "\n        window.dataLayer = window.dataLayer || [];\n        function gtag(){dataLayer.push(arguments);}\n        gtag('js', new Date());\n        gtag('config', 'G-SPQY5ELRRW');\n    "
                    })]
                }),
                Q = e => {
                    let {
                        child: t,
                        props: n
                    } = e, [r, a] = (0, j.partition)(t, e => !0 === e.props.r3f), s = (0, o.useRef)();
                    return (0, i.jsxs)(i.Fragment, {
                        children: [(0, i.jsx)($, {
                            refCanvasState: s,
                            children: (0, i.jsxs)(v.f6, {
                                theme: H.r,
                                children: [a, (0, i.jsx)(J, {})]
                            })
                        }), (0, i.jsx)(Y, {
                            refCanvasState: s,
                            serverLocation: n.serverLocation,
                            children: r
                        }), (0, i.jsx)(L, {}), (0, i.jsx)(W, {})]
                    })
                };
            var ee = function(e) {
                let {
                    Component: t,
                    pageProps: n = {
                        title: "index"
                    }
                } = e, r = (0, a.useRouter)();
                (0, o.useEffect)(() => {
                    let {
                        query: e
                    } = r;
                    e.s && ((0, _.N1)({
                        skipIntro: !0,
                        startJourney: !0
                    }), (0, _.nZ)().hideLoader()), (0, s.IW)({
                        router: r
                    })
                }, [r]);
                let l = t(n).props.children;
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(K, {}), (0, i.jsx)(f, {
                        title: n.title
                    }), l && l.length > 1 ? (0, i.jsx)(Q, {
                        child: t(n).props.children,
                        props: n
                    }) : (0, i.jsx)(t, { ...n
                    })]
                })
            }
        },
        4661: function(e, t, n) {
            "use strict";
            n.d(t, {
                A8: function() {
                    return c
                },
                K5: function() {
                    return u
                },
                Th: function() {
                    return h
                }
            });
            var r = n(9477),
                i = n(5518),
                a = n(4671),
                s = n(374),
                o = n(7430);
            let l = (0, a.Z)((e, t) => ({
                    attached: !0,
                    resetCamera: !1,
                    inverseAxis: !1,
                    lockRotation: i.nI,
                    firstPerson: !1,
                    isDragging: !1,
                    playingAnimation: !1,
                    dragAmplitude: new r.Vector2(.25, .15),
                    dragDamp: 16,
                    preventDrag: !1,
                    yFlyBackTrigger: -120,
                    yFlyBackCameraOffset: 30,
                    yCameraLowerLimit: -90,
                    dragDelta: new r.Vector2(0, 0),
                    absoluteDelta: new r.Vector3(0, 0, 0),
                    targetOffset: new r.Vector3(-1, 3.5, 1),
                    cameraOffset: new r.Vector3(-1, 2.5, -6.5),
                    defaultFov: 50,
                    defaultTargetOffset: new r.Vector3(0, 3.5, 1),
                    defaultCameraOffset: new r.Vector3(-1, 2.5, -6.5),
                    firstPersonTargetOffset: new r.Vector3(0, 3.4, .1),
                    firstPersonCameraOffset: new r.Vector3(0, 3.4, -.1),
                    disableCameraPositionLerp: !1,
                    disableCameraRotationLerp: !1,
                    cameraRotationAroundTarget: 0,
                    refCamera: null,
                    noIdleZone: !1,
                    cinematicMode: !1,
                    dialogMode: !1,
                    cinematicDamp: 1,
                    cinematicPositionTo: new r.Vector3,
                    cinematicQuaternionTo: new r.Quaternion,
                    cinematicFov: 50,
                    interruptCinematic: !1,
                    setNextCameraMode: () => {
                        e(e => e.lockRotation && !e.firstPerson ? {
                            lockRotation: !1
                        } : e.lockRotation || e.firstPerson ? e.firstPerson ? {
                            firstPerson: !1,
                            lockRotation: !0,
                            disableCameraPositionLerp: !1,
                            disableCameraRotationLerp: !1
                        } : void 0 : {
                            firstPerson: !0,
                            lockRotation: !0,
                            disableCameraPositionLerp: !0,
                            disableCameraRotationLerp: !0
                        }), (0, o.Kn)("resetOffsetCamera"), t().firstPerson ? (0, o.Kn)("hideModel", {
                            hide: !0
                        }) : (0, o.Kn)("hideModel", {
                            hide: !1
                        })
                    }
                })),
                u = e => l(e, s.Z);
            Object.assign(u, l);
            let {
                getState: c,
                setState: h
            } = l
        },
        5678: function(e, t, n) {
            "use strict";
            n.d(t, {
                r: function() {
                    return r
                }
            });
            let r = {
                defaultColor: "#0e0e0e",
                mainColor: "red",
                highlightColor: "#1616a1",
                lightTextColor: "#999",
                whiteColor: "#fff",
                highlightFont: "font-family: Rubik, Open Sans, Helvetica, Arial, Hiragino Kaku Gothic ProN,  ProN W3, Hiragino Kaku Gothic Pro,  Pro W3, Noto Sans JP, Meiryo, , sans-serif;",
                headline1: "font-size: 48px; line-height: 48px;",
                headline2: "font-size: 42px; line-height: 42px;",
                headline3: "font-size: 32px; line-height: 32px;",
                headline4: "font-size: 28px; line-height: 28px;",
                headline5: "font-size: 24px; line-height: 24px;",
                headline6: "font-size: 18px; line-height: 18px;",
                bodyText1: "font-size: 16px; line-height: 24px;",
                bodyText2: "font-size: 16px; line-height: 22px;",
                bodyText3: "font-size: 14px; line-height: 18px;",
                bodyText4: "font-size: 14px; line-height: 18px;",
                bodyText5: "font-size: 12px; line-height: 16px;",
                bodyText6: "font-size: 12px; line-height: 16px;",
                buttonRadius: "border-radius: 4px;"
            }
        },
        7112: function() {},
        5152: function(e, t, n) {
            e.exports = n(7645)
        },
        9008: function(e, t, n) {
            e.exports = n(3121)
        },
        1163: function(e, t, n) {
            e.exports = n(880)
        },
        4298: function(e, t, n) {
            e.exports = n(3573)
        },
        4155: function(e) {
            var t, n, r, i = e.exports = {};

            function a() {
                throw Error("setTimeout has not been defined")
            }

            function s() {
                throw Error("clearTimeout has not been defined")
            }

            function o(e) {
                if (t === setTimeout) return setTimeout(e, 0);
                if ((t === a || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);
                try {
                    return t(e, 0)
                } catch (r) {
                    try {
                        return t.call(null, e, 0)
                    } catch (n) {
                        return t.call(this, e, 0)
                    }
                }
            }! function() {
                try {
                    t = "function" == typeof setTimeout ? setTimeout : a
                } catch (e) {
                    t = a
                }
                try {
                    n = "function" == typeof clearTimeout ? clearTimeout : s
                } catch (r) {
                    n = s
                }
            }();
            var l = [],
                u = !1,
                c = -1;

            function h() {
                u && r && (u = !1, r.length ? l = r.concat(l) : c = -1, l.length && d())
            }

            function d() {
                if (!u) {
                    var e = o(h);
                    u = !0;
                    for (var t = l.length; t;) {
                        for (r = l, l = []; ++c < t;) r && r[c].run();
                        c = -1, t = l.length
                    }
                    r = null, u = !1,
                        function(e) {
                            if (n === clearTimeout) return clearTimeout(e);
                            if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e);
                            try {
                                n(e)
                            } catch (r) {
                                try {
                                    return n.call(null, e)
                                } catch (t) {
                                    return n.call(this, e)
                                }
                            }
                        }(e)
                }
            }

            function f(e, t) {
                this.fun = e, this.array = t
            }

            function p() {}
            i.nextTick = function(e) {
                var t = Array(arguments.length - 1);
                if (arguments.length > 1)
                    for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
                l.push(new f(e, t)), 1 !== l.length || u || o(d)
            }, f.prototype.run = function() {
                this.fun.apply(null, this.array)
            }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = p, i.addListener = p, i.once = p, i.off = p, i.removeListener = p, i.removeAllListeners = p, i.emit = p, i.prependListener = p, i.prependOnceListener = p, i.listeners = function(e) {
                return []
            }, i.binding = function(e) {
                throw Error("process.binding is not supported")
            }, i.cwd = function() {
                return "/"
            }, i.chdir = function(e) {
                throw Error("process.chdir is not supported")
            }, i.umask = function() {
                return 0
            }
        },
        5518: function(e, t, n) {
            "use strict";
            var r, i, a, s, o, l, u = n(7294);
            u && "object" == typeof u && "default" in u && u.default;
            var c = n(3451),
                h = new c,
                d = h.getBrowser(),
                f = h.getCPU(),
                p = h.getDevice(),
                m = h.getEngine(),
                g = h.getOS(),
                v = h.getUA(),
                _ = {
                    Mobile: "mobile",
                    Tablet: "tablet",
                    SmartTv: "smarttv",
                    Console: "console",
                    Wearable: "wearable",
                    Embedded: "embedded",
                    Browser: void 0
                },
                y = {
                    Chrome: "Chrome",
                    Firefox: "Firefox",
                    Opera: "Opera",
                    Yandex: "Yandex",
                    Safari: "Safari",
                    InternetExplorer: "Internet Explorer",
                    Edge: "Edge",
                    Chromium: "Chromium",
                    Ie: "IE",
                    MobileSafari: "Mobile Safari",
                    EdgeChromium: "Edge Chromium",
                    MIUI: "MIUI Browser",
                    SamsungBrowser: "Samsung Browser"
                },
                x = {
                    IOS: "iOS",
                    Android: "Android",
                    WindowsPhone: "Windows Phone",
                    Windows: "Windows",
                    MAC_OS: "Mac OS"
                },
                b = function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "none";
                    return e || t
                },
                w = function() {
                    return !!("undefined" != typeof window && (window.navigator || navigator)) && (window.navigator || navigator)
                },
                S = function(e) {
                    var t = w();
                    return t && t.platform && (-1 !== t.platform.indexOf(e) || "MacIntel" === t.platform && t.maxTouchPoints > 1 && !window.MSStream)
                },
                M = function(e) {
                    return e.type === _.Browser
                },
                T = function(e) {
                    return e.name === y.Edge
                },
                A = function(e) {
                    return "string" == typeof e && -1 !== e.indexOf("Edg/")
                },
                E = function() {
                    return S("iPad")
                };
            p.type, _.SmartTv, p.type, _.Console, p.type, _.Wearable, p.type, _.Embedded, d.name === y.MobileSafari || E(), d.name, y.Chromium;
            var C = (r = p.type) === _.Mobile || r === _.Tablet || E(),
                I = p.type === _.Mobile,
                P = (p.type === _.Tablet || E(), M(p), M(p)),
                R = (g.name, x.Android, g.name, x.WindowsPhone, g.name === x.IOS || E());
            d.name, y.Chrome;
            var L = d.name === y.Firefox,
                D = (i = d.name) === y.Safari || i === y.MobileSafari;
            d.name, y.Opera, (a = d.name) === y.InternetExplorer || y.Ie, b(g.version), b(g.name), b(d.version), b(d.major), b(d.name), b(p.vendor), b(p.model), b(m.name), b(m.version), b(v), T(d) || A(v), d.name, y.Yandex, b(p.type, "browser"), (s = w()) && (/iPad|iPhone|iPod/.test(s.platform) || "MacIntel" === s.platform && s.maxTouchPoints > 1) && window.MSStream, E(), S("iPhone"), S("iPod"), "string" == typeof(l = (o = w()) && o.userAgent && o.userAgent.toLowerCase()) && /electron/.test(l), A(v), T(d) && A(v);
            var k = g.name === x.Windows;
            g.name, x.MAC_OS, d.name, y.MIUI, d.name, y.SamsungBrowser, t.nI = P, t.vU = L, t.gn = R, t.tq = C, t.UA = I, t.G6 = D, t.ED = k
        },
        9921: function(e, t) {
            "use strict";
            /** @license React v16.13.1
             * react-is.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            var n = "function" == typeof Symbol && Symbol.for,
                r = n ? Symbol.for("react.element") : 60103,
                i = n ? Symbol.for("react.portal") : 60106,
                a = n ? Symbol.for("react.fragment") : 60107,
                s = n ? Symbol.for("react.strict_mode") : 60108,
                o = n ? Symbol.for("react.profiler") : 60114,
                l = n ? Symbol.for("react.provider") : 60109,
                u = n ? Symbol.for("react.context") : 60110,
                c = n ? Symbol.for("react.async_mode") : 60111,
                h = n ? Symbol.for("react.concurrent_mode") : 60111,
                d = n ? Symbol.for("react.forward_ref") : 60112,
                f = n ? Symbol.for("react.suspense") : 60113,
                p = n ? Symbol.for("react.suspense_list") : 60120,
                m = n ? Symbol.for("react.memo") : 60115,
                g = n ? Symbol.for("react.lazy") : 60116,
                v = n ? Symbol.for("react.block") : 60121,
                _ = n ? Symbol.for("react.fundamental") : 60117,
                y = n ? Symbol.for("react.responder") : 60118,
                x = n ? Symbol.for("react.scope") : 60119;

            function b(e) {
                if ("object" == typeof e && null !== e) {
                    var t = e.$$typeof;
                    switch (t) {
                        case r:
                            switch (e = e.type) {
                                case c:
                                case h:
                                case a:
                                case o:
                                case s:
                                case f:
                                    return e;
                                default:
                                    switch (e = e && e.$$typeof) {
                                        case u:
                                        case d:
                                        case g:
                                        case m:
                                        case l:
                                            return e;
                                        default:
                                            return t
                                    }
                            }
                        case i:
                            return t
                    }
                }
            }

            function w(e) {
                return b(e) === h
            }
            t.AsyncMode = c, t.ConcurrentMode = h, t.ContextConsumer = u, t.ContextProvider = l, t.Element = r, t.ForwardRef = d, t.Fragment = a, t.Lazy = g, t.Memo = m, t.Portal = i, t.Profiler = o, t.StrictMode = s, t.Suspense = f, t.isAsyncMode = function(e) {
                return w(e) || b(e) === c
            }, t.isConcurrentMode = w, t.isContextConsumer = function(e) {
                return b(e) === u
            }, t.isContextProvider = function(e) {
                return b(e) === l
            }, t.isElement = function(e) {
                return "object" == typeof e && null !== e && e.$$typeof === r
            }, t.isForwardRef = function(e) {
                return b(e) === d
            }, t.isFragment = function(e) {
                return b(e) === a
            }, t.isLazy = function(e) {
                return b(e) === g
            }, t.isMemo = function(e) {
                return b(e) === m
            }, t.isPortal = function(e) {
                return b(e) === i
            }, t.isProfiler = function(e) {
                return b(e) === o
            }, t.isStrictMode = function(e) {
                return b(e) === s
            }, t.isSuspense = function(e) {
                return b(e) === f
            }, t.isValidElementType = function(e) {
                return "string" == typeof e || "function" == typeof e || e === a || e === h || e === o || e === s || e === f || e === p || "object" == typeof e && null !== e && (e.$$typeof === g || e.$$typeof === m || e.$$typeof === l || e.$$typeof === u || e.$$typeof === d || e.$$typeof === _ || e.$$typeof === y || e.$$typeof === x || e.$$typeof === v)
            }, t.typeOf = b
        },
        9864: function(e, t, n) {
            "use strict";
            e.exports = n(9921)
        },
        6774: function(e) {
            e.exports = function(e, t, n, r) {
                var i = n ? n.call(r, e, t) : void 0;
                if (void 0 !== i) return !!i;
                if (e === t) return !0;
                if ("object" != typeof e || !e || "object" != typeof t || !t) return !1;
                var a = Object.keys(e),
                    s = Object.keys(t);
                if (a.length !== s.length) return !1;
                for (var o = Object.prototype.hasOwnProperty.bind(t), l = 0; l < a.length; l++) {
                    var u = a[l];
                    if (!o(u)) return !1;
                    var c = e[u],
                        h = t[u];
                    if (!1 === (i = n ? n.call(r, c, h, u) : void 0) || void 0 === i && c !== h) return !1
                }
                return !0
            }
        },
        7379: function(e, t, n) {
            "use strict";
            n.d(t, {
                f6: function() {
                    return eI
                },
                vJ: function() {
                    return eD
                },
                iv: function() {
                    return ex
                },
                ZP: function() {
                    return eU
                },
                F4: function() {
                    return ek
                }
            });
            var r, i, a = n(9864),
                s = n(7294),
                o = n(6774),
                l = n.n(o),
                u = function(e) {
                    function t(e, t, r) {
                        var i = t.trim().split(p);
                        t = i;
                        var a = i.length,
                            s = e.length;
                        switch (s) {
                            case 0:
                            case 1:
                                var o = 0;
                                for (e = 0 === s ? "" : e[0] + " "; o < a; ++o) t[o] = n(e, t[o], r).trim();
                                break;
                            default:
                                var l = o = 0;
                                for (t = []; o < a; ++o)
                                    for (var u = 0; u < s; ++u) t[l++] = n(e[u] + " ", i[o], r).trim()
                        }
                        return t
                    }

                    function n(e, t, n) {
                        var r = t.charCodeAt(0);
                        switch (33 > r && (r = (t = t.trim()).charCodeAt(0)), r) {
                            case 38:
                                return t.replace(m, "$1" + e.trim());
                            case 58:
                                return e.trim() + t.replace(m, "$1" + e.trim());
                            default:
                                if (0 < 1 * n && 0 < t.indexOf("\f")) return t.replace(m, (58 === e.charCodeAt(0) ? "" : "$1") + e.trim())
                        }
                        return e + t
                    }

                    function r(e, t, n, a) {
                        var s = e + ";",
                            o = 2 * t + 3 * n + 4 * a;
                        if (944 === o) {
                            e = s.indexOf(":", 9) + 1;
                            var l = s.substring(e, s.length - 1).trim();
                            return l = s.substring(0, e).trim() + l + ";", 1 === I || 2 === I && i(l, 1) ? "-webkit-" + l + l : l
                        }
                        if (0 === I || 2 === I && !i(s, 1)) return s;
                        switch (o) {
                            case 1015:
                                return 97 === s.charCodeAt(10) ? "-webkit-" + s + s : s;
                            case 951:
                                return 116 === s.charCodeAt(3) ? "-webkit-" + s + s : s;
                            case 963:
                                return 110 === s.charCodeAt(5) ? "-webkit-" + s + s : s;
                            case 1009:
                                if (100 !== s.charCodeAt(4)) break;
                            case 969:
                            case 942:
                                return "-webkit-" + s + s;
                            case 978:
                                return "-webkit-" + s + "-moz-" + s + s;
                            case 1019:
                            case 983:
                                return "-webkit-" + s + "-moz-" + s + "-ms-" + s + s;
                            case 883:
                                if (45 === s.charCodeAt(8)) return "-webkit-" + s + s;
                                if (0 < s.indexOf("image-set(", 11)) return s.replace(T, "$1-webkit-$2") + s;
                                break;
                            case 932:
                                if (45 === s.charCodeAt(4)) switch (s.charCodeAt(5)) {
                                    case 103:
                                        return "-webkit-box-" + s.replace("-grow", "") + "-webkit-" + s + "-ms-" + s.replace("grow", "positive") + s;
                                    case 115:
                                        return "-webkit-" + s + "-ms-" + s.replace("shrink", "negative") + s;
                                    case 98:
                                        return "-webkit-" + s + "-ms-" + s.replace("basis", "preferred-size") + s
                                }
                                return "-webkit-" + s + "-ms-" + s + s;
                            case 964:
                                return "-webkit-" + s + "-ms-flex-" + s + s;
                            case 1023:
                                if (99 !== s.charCodeAt(8)) break;
                                return "-webkit-box-pack" + (l = s.substring(s.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify")) + "-webkit-" + s + "-ms-flex-pack" + l + s;
                            case 1005:
                                return d.test(s) ? s.replace(h, ":-webkit-") + s.replace(h, ":-moz-") + s : s;
                            case 1e3:
                                switch (t = (l = s.substring(13).trim()).indexOf("-") + 1, l.charCodeAt(0) + l.charCodeAt(t)) {
                                    case 226:
                                        l = s.replace(y, "tb");
                                        break;
                                    case 232:
                                        l = s.replace(y, "tb-rl");
                                        break;
                                    case 220:
                                        l = s.replace(y, "lr");
                                        break;
                                    default:
                                        return s
                                }
                                return "-webkit-" + s + "-ms-" + l + s;
                            case 1017:
                                if (-1 === s.indexOf("sticky", 9)) break;
                            case 975:
                                switch (t = (s = e).length - 10, o = (l = (33 === s.charCodeAt(t) ? s.substring(0, t) : s).substring(e.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | l.charCodeAt(7))) {
                                    case 203:
                                        if (111 > l.charCodeAt(8)) break;
                                    case 115:
                                        s = s.replace(l, "-webkit-" + l) + ";" + s;
                                        break;
                                    case 207:
                                    case 102:
                                        s = s.replace(l, "-webkit-" + (102 < o ? "inline-" : "") + "box") + ";" + s.replace(l, "-webkit-" + l) + ";" + s.replace(l, "-ms-" + l + "box") + ";" + s
                                }
                                return s + ";";
                            case 938:
                                if (45 === s.charCodeAt(5)) switch (s.charCodeAt(6)) {
                                    case 105:
                                        return l = s.replace("-items", ""), "-webkit-" + s + "-webkit-box-" + l + "-ms-flex-" + l + s;
                                    case 115:
                                        return "-webkit-" + s + "-ms-flex-item-" + s.replace(w, "") + s;
                                    default:
                                        return "-webkit-" + s + "-ms-flex-line-pack" + s.replace("align-content", "").replace(w, "") + s
                                }
                                break;
                            case 973:
                            case 989:
                                if (45 !== s.charCodeAt(3) || 122 === s.charCodeAt(4)) break;
                            case 931:
                            case 953:
                                if (!0 === M.test(e)) return 115 === (l = e.substring(e.indexOf(":") + 1)).charCodeAt(0) ? r(e.replace("stretch", "fill-available"), t, n, a).replace(":fill-available", ":stretch") : s.replace(l, "-webkit-" + l) + s.replace(l, "-moz-" + l.replace("fill-", "")) + s;
                                break;
                            case 962:
                                if (s = "-webkit-" + s + (102 === s.charCodeAt(5) ? "-ms-" + s : "") + s, 211 === n + a && 105 === s.charCodeAt(13) && 0 < s.indexOf("transform", 10)) return s.substring(0, s.indexOf(";", 27) + 1).replace(f, "$1-webkit-$2") + s
                        }
                        return s
                    }

                    function i(e, t) {
                        var n = e.indexOf(1 === t ? ":" : "{"),
                            r = e.substring(0, 3 !== t ? n : 10);
                        return n = e.substring(n + 1, e.length - 1), D(2 !== t ? r : r.replace(S, "$1"), n, t)
                    }

                    function a(e, t) {
                        var n = r(t, t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2));
                        return n !== t + ";" ? n.replace(b, " or ($1)").substring(4) : "(" + t + ")"
                    }

                    function s(e, t, n, r, i, a, s, o, u, c) {
                        for (var h, d = 0, f = t; d < L; ++d) switch (h = R[d].call(l, e, f, n, r, i, a, s, o, u, c)) {
                            case void 0:
                            case !1:
                            case !0:
                            case null:
                                break;
                            default:
                                f = h
                        }
                        if (f !== t) return f
                    }

                    function o(e) {
                        return void 0 !== (e = e.prefix) && (D = null, e ? "function" != typeof e ? I = 1 : (I = 2, D = e) : I = 0), o
                    }

                    function l(e, n) {
                        var o = e;
                        if (33 > o.charCodeAt(0) && (o = o.trim()), o = [o], 0 < L) {
                            var l = s(-1, n, o, o, E, A, 0, 0, 0, 0);
                            void 0 !== l && "string" == typeof l && (n = l)
                        }
                        var h = function e(n, o, l, h, d) {
                            for (var f, p, m, y, b, w = 0, S = 0, M = 0, T = 0, R = 0, D = 0, U = m = f = 0, O = 0, F = 0, N = 0, B = 0, z = l.length, G = z - 1, V = "", W = "", H = "", j = ""; O < z;) {
                                if (p = l.charCodeAt(O), O === G && 0 !== S + T + M + w && (0 !== S && (p = 47 === S ? 10 : 47), T = M = w = 0, z++, G++), 0 === S + T + M + w) {
                                    if (O === G && (0 < F && (V = V.replace(c, "")), 0 < V.trim().length)) {
                                        switch (p) {
                                            case 32:
                                            case 9:
                                            case 59:
                                            case 13:
                                            case 10:
                                                break;
                                            default:
                                                V += l.charAt(O)
                                        }
                                        p = 59
                                    }
                                    switch (p) {
                                        case 123:
                                            for (f = (V = V.trim()).charCodeAt(0), m = 1, B = ++O; O < z;) {
                                                switch (p = l.charCodeAt(O)) {
                                                    case 123:
                                                        m++;
                                                        break;
                                                    case 125:
                                                        m--;
                                                        break;
                                                    case 47:
                                                        switch (p = l.charCodeAt(O + 1)) {
                                                            case 42:
                                                            case 47:
                                                                t: {
                                                                    for (U = O + 1; U < G; ++U) switch (l.charCodeAt(U)) {
                                                                        case 47:
                                                                            if (42 === p && 42 === l.charCodeAt(U - 1) && O + 2 !== U) {
                                                                                O = U + 1;
                                                                                break t
                                                                            }
                                                                            break;
                                                                        case 10:
                                                                            if (47 === p) {
                                                                                O = U + 1;
                                                                                break t
                                                                            }
                                                                    }
                                                                    O = U
                                                                }
                                                        }
                                                        break;
                                                    case 91:
                                                        p++;
                                                    case 40:
                                                        p++;
                                                    case 34:
                                                    case 39:
                                                        for (; O++ < G && l.charCodeAt(O) !== p;);
                                                }
                                                if (0 === m) break;
                                                O++
                                            }
                                            if (m = l.substring(B, O), 0 === f && (f = (V = V.replace(u, "").trim()).charCodeAt(0)), 64 === f) {
                                                switch (0 < F && (V = V.replace(c, "")), p = V.charCodeAt(1)) {
                                                    case 100:
                                                    case 109:
                                                    case 115:
                                                    case 45:
                                                        F = o;
                                                        break;
                                                    default:
                                                        F = P
                                                }
                                                if (B = (m = e(o, F, m, p, d + 1)).length, 0 < L && (F = t(P, V, N), b = s(3, m, F, o, E, A, B, p, d, h), V = F.join(""), void 0 !== b && 0 === (B = (m = b.trim()).length) && (p = 0, m = "")), 0 < B) switch (p) {
                                                    case 115:
                                                        V = V.replace(x, a);
                                                    case 100:
                                                    case 109:
                                                    case 45:
                                                        m = V + "{" + m + "}";
                                                        break;
                                                    case 107:
                                                        m = (V = V.replace(g, "$1 $2")) + "{" + m + "}", m = 1 === I || 2 === I && i("@" + m, 3) ? "@-webkit-" + m + "@" + m : "@" + m;
                                                        break;
                                                    default:
                                                        m = V + m, 112 === h && (W += m, m = "")
                                                } else m = ""
                                            } else m = e(o, t(o, V, N), m, h, d + 1);
                                            H += m, m = N = F = U = f = 0, V = "", p = l.charCodeAt(++O);
                                            break;
                                        case 125:
                                        case 59:
                                            if (1 < (B = (V = (0 < F ? V.replace(c, "") : V).trim()).length)) switch (0 === U && (45 === (f = V.charCodeAt(0)) || 96 < f && 123 > f) && (B = (V = V.replace(" ", ":")).length), 0 < L && void 0 !== (b = s(1, V, o, n, E, A, W.length, h, d, h)) && 0 === (B = (V = b.trim()).length) && (V = "\0\0"), f = V.charCodeAt(0), p = V.charCodeAt(1), f) {
                                                case 0:
                                                    break;
                                                case 64:
                                                    if (105 === p || 99 === p) {
                                                        j += V + l.charAt(O);
                                                        break
                                                    }
                                                default:
                                                    58 !== V.charCodeAt(B - 1) && (W += r(V, f, p, V.charCodeAt(2)))
                                            }
                                            N = F = U = f = 0, V = "", p = l.charCodeAt(++O)
                                    }
                                }
                                switch (p) {
                                    case 13:
                                    case 10:
                                        47 === S ? S = 0 : 0 === 1 + f && 107 !== h && 0 < V.length && (F = 1, V += "\0"), 0 < L * k && s(0, V, o, n, E, A, W.length, h, d, h), A = 1, E++;
                                        break;
                                    case 59:
                                    case 125:
                                        if (0 === S + T + M + w) {
                                            A++;
                                            break
                                        }
                                    default:
                                        switch (A++, y = l.charAt(O), p) {
                                            case 9:
                                            case 32:
                                                if (0 === T + w + S) switch (R) {
                                                    case 44:
                                                    case 58:
                                                    case 9:
                                                    case 32:
                                                        y = "";
                                                        break;
                                                    default:
                                                        32 !== p && (y = " ")
                                                }
                                                break;
                                            case 0:
                                                y = "\\0";
                                                break;
                                            case 12:
                                                y = "\\f";
                                                break;
                                            case 11:
                                                y = "\\v";
                                                break;
                                            case 38:
                                                0 === T + S + w && (F = N = 1, y = "\f" + y);
                                                break;
                                            case 108:
                                                if (0 === T + S + w + C && 0 < U) switch (O - U) {
                                                    case 2:
                                                        112 === R && 58 === l.charCodeAt(O - 3) && (C = R);
                                                    case 8:
                                                        111 === D && (C = D)
                                                }
                                                break;
                                            case 58:
                                                0 === T + S + w && (U = O);
                                                break;
                                            case 44:
                                                0 === S + M + T + w && (F = 1, y += "\r");
                                                break;
                                            case 34:
                                            case 39:
                                                0 === S && (T = T === p ? 0 : 0 === T ? p : T);
                                                break;
                                            case 91:
                                                0 === T + S + M && w++;
                                                break;
                                            case 93:
                                                0 === T + S + M && w--;
                                                break;
                                            case 41:
                                                0 === T + S + w && M--;
                                                break;
                                            case 40:
                                                0 === T + S + w && (0 === f && (2 * R + 3 * D == 533 || (f = 1)), M++);
                                                break;
                                            case 64:
                                                0 === S + M + T + w + U + m && (m = 1);
                                                break;
                                            case 42:
                                            case 47:
                                                if (!(0 < T + w + M)) switch (S) {
                                                    case 0:
                                                        switch (2 * p + 3 * l.charCodeAt(O + 1)) {
                                                            case 235:
                                                                S = 47;
                                                                break;
                                                            case 220:
                                                                B = O, S = 42
                                                        }
                                                        break;
                                                    case 42:
                                                        47 === p && 42 === R && B + 2 !== O && (33 === l.charCodeAt(B + 2) && (W += l.substring(B, O + 1)), y = "", S = 0)
                                                }
                                        }
                                        0 === S && (V += y)
                                }
                                D = R, R = p, O++
                            }
                            if (0 < (B = W.length)) {
                                if (F = o, 0 < L && void 0 !== (b = s(2, W, F, n, E, A, B, h, d, h)) && 0 === (W = b).length) return j + W + H;
                                if (W = F.join(",") + "{" + W + "}", 0 != I * C) {
                                    switch (2 !== I || i(W, 2) || (C = 0), C) {
                                        case 111:
                                            W = W.replace(_, ":-moz-$1") + W;
                                            break;
                                        case 112:
                                            W = W.replace(v, "::-webkit-input-$1") + W.replace(v, "::-moz-$1") + W.replace(v, ":-ms-input-$1") + W
                                    }
                                    C = 0
                                }
                            }
                            return j + W + H
                        }(P, o, n, 0, 0);
                        return 0 < L && void 0 !== (l = s(-2, h, o, o, E, A, h.length, 0, 0, 0)) && (h = l), C = 0, A = E = 1, h
                    }
                    var u = /^\0+/g,
                        c = /[\0\r\f]/g,
                        h = /: */g,
                        d = /zoo|gra/,
                        f = /([,: ])(transform)/g,
                        p = /,\r+?/g,
                        m = /([\t\r\n ])*\f?&/g,
                        g = /@(k\w+)\s*(\S*)\s*/,
                        v = /::(place)/g,
                        _ = /:(read-only)/g,
                        y = /[svh]\w+-[tblr]{2}/,
                        x = /\(\s*(.*)\s*\)/g,
                        b = /([\s\S]*?);/g,
                        w = /-self|flex-/g,
                        S = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
                        M = /stretch|:\s*\w+\-(?:conte|avail)/,
                        T = /([^-])(image-set\()/,
                        A = 1,
                        E = 1,
                        C = 0,
                        I = 1,
                        P = [],
                        R = [],
                        L = 0,
                        D = null,
                        k = 0;
                    return l.use = function e(t) {
                        switch (t) {
                            case void 0:
                            case null:
                                L = R.length = 0;
                                break;
                            default:
                                if ("function" == typeof t) R[L++] = t;
                                else if ("object" == typeof t)
                                    for (var n = 0, r = t.length; n < r; ++n) e(t[n]);
                                else k = 0 | !!t
                        }
                        return e
                    }, l.set = o, void 0 !== e && o(e), l
                },
                c = {
                    animationIterationCount: 1,
                    borderImageOutset: 1,
                    borderImageSlice: 1,
                    borderImageWidth: 1,
                    boxFlex: 1,
                    boxFlexGroup: 1,
                    boxOrdinalGroup: 1,
                    columnCount: 1,
                    columns: 1,
                    flex: 1,
                    flexGrow: 1,
                    flexPositive: 1,
                    flexShrink: 1,
                    flexNegative: 1,
                    flexOrder: 1,
                    gridRow: 1,
                    gridRowEnd: 1,
                    gridRowSpan: 1,
                    gridRowStart: 1,
                    gridColumn: 1,
                    gridColumnEnd: 1,
                    gridColumnSpan: 1,
                    gridColumnStart: 1,
                    msGridRow: 1,
                    msGridRowSpan: 1,
                    msGridColumn: 1,
                    msGridColumnSpan: 1,
                    fontWeight: 1,
                    lineHeight: 1,
                    opacity: 1,
                    order: 1,
                    orphans: 1,
                    tabSize: 1,
                    widows: 1,
                    zIndex: 1,
                    zoom: 1,
                    WebkitLineClamp: 1,
                    fillOpacity: 1,
                    floodOpacity: 1,
                    stopOpacity: 1,
                    strokeDasharray: 1,
                    strokeDashoffset: 1,
                    strokeMiterlimit: 1,
                    strokeOpacity: 1,
                    strokeWidth: 1
                },
                h = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
                d = (r = {}, function(e) {
                    return void 0 === r[e] && (r[e] = h.test(e) || 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && 91 > e.charCodeAt(2)), r[e]
                }),
                f = n(8679),
                p = n.n(f),
                m = n(4155);

            function g() {
                return (g = Object.assign || function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }).apply(this, arguments)
            }
            var v = function(e, t) {
                    for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1) n.push(t[r], e[r + 1]);
                    return n
                },
                _ = function(e) {
                    return null !== e && "object" == typeof e && "[object Object]" === (e.toString ? e.toString() : Object.prototype.toString.call(e)) && !(0, a.typeOf)(e)
                },
                y = Object.freeze([]),
                x = Object.freeze({});

            function b(e) {
                return "function" == typeof e
            }

            function w(e) {
                return e.displayName || e.name || "Component"
            }

            function S(e) {
                return e && "string" == typeof e.styledComponentId
            }
            var M = void 0 !== m && (m.env.REACT_APP_SC_ATTR || m.env.SC_ATTR) || "data-styled",
                T = "undefined" != typeof window && "HTMLElement" in window,
                A = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : void 0 !== m && void 0 !== m.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== m.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== m.env.REACT_APP_SC_DISABLE_SPEEDY && m.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== m && void 0 !== m.env.SC_DISABLE_SPEEDY && "" !== m.env.SC_DISABLE_SPEEDY && "false" !== m.env.SC_DISABLE_SPEEDY && m.env.SC_DISABLE_SPEEDY),
                E = {};

            function C(e) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                throw Error("An error occurred. See https://git.io/JUIaE#" + e + " for more information." + (n.length > 0 ? " Args: " + n.join(", ") : ""))
            }
            var I = function() {
                    function e(e) {
                        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e
                    }
                    var t = e.prototype;
                    return t.indexOfGroup = function(e) {
                        for (var t = 0, n = 0; n < e; n++) t += this.groupSizes[n];
                        return t
                    }, t.insertRules = function(e, t) {
                        if (e >= this.groupSizes.length) {
                            for (var n = this.groupSizes, r = n.length, i = r; e >= i;)(i <<= 1) < 0 && C(16, "" + e);
                            this.groupSizes = new Uint32Array(i), this.groupSizes.set(n), this.length = i;
                            for (var a = r; a < i; a++) this.groupSizes[a] = 0
                        }
                        for (var s = this.indexOfGroup(e + 1), o = 0, l = t.length; o < l; o++) this.tag.insertRule(s, t[o]) && (this.groupSizes[e]++, s++)
                    }, t.clearGroup = function(e) {
                        if (e < this.length) {
                            var t = this.groupSizes[e],
                                n = this.indexOfGroup(e),
                                r = n + t;
                            this.groupSizes[e] = 0;
                            for (var i = n; i < r; i++) this.tag.deleteRule(n)
                        }
                    }, t.getGroup = function(e) {
                        var t = "";
                        if (e >= this.length || 0 === this.groupSizes[e]) return t;
                        for (var n = this.groupSizes[e], r = this.indexOfGroup(e), i = r + n, a = r; a < i; a++) t += this.tag.getRule(a) + "/*!sc*/\n";
                        return t
                    }, e
                }(),
                P = new Map,
                R = new Map,
                L = 1,
                D = function(e) {
                    if (P.has(e)) return P.get(e);
                    for (; R.has(L);) L++;
                    var t = L++;
                    return P.set(e, t), R.set(t, e), t
                },
                k = function(e, t) {
                    t >= L && (L = t + 1), P.set(e, t), R.set(t, e)
                },
                U = "style[" + M + '][data-styled-version="5.3.3"]',
                O = RegExp("^" + M + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),
                F = function(e, t, n) {
                    for (var r, i = n.split(","), a = 0, s = i.length; a < s; a++)(r = i[a]) && e.registerName(t, r)
                },
                N = function(e, t) {
                    for (var n = (t.textContent || "").split("/*!sc*/\n"), r = [], i = 0, a = n.length; i < a; i++) {
                        var s = n[i].trim();
                        if (s) {
                            var o = s.match(O);
                            if (o) {
                                var l = 0 | parseInt(o[1], 10),
                                    u = o[2];
                                0 !== l && (k(u, l), F(e, u, o[3]), e.getTag().insertRules(l, r)), r.length = 0
                            } else r.push(s)
                        }
                    }
                },
                B = function() {
                    return "undefined" != typeof window && void 0 !== window.__webpack_nonce__ ? window.__webpack_nonce__ : null
                },
                z = function(e) {
                    var t = document.head,
                        n = e || t,
                        r = document.createElement("style"),
                        i = function(e) {
                            for (var t = e.childNodes, n = t.length; n >= 0; n--) {
                                var r = t[n];
                                if (r && 1 === r.nodeType && r.hasAttribute(M)) return r
                            }
                        }(n),
                        a = void 0 !== i ? i.nextSibling : null;
                    r.setAttribute(M, "active"), r.setAttribute("data-styled-version", "5.3.3");
                    var s = B();
                    return s && r.setAttribute("nonce", s), n.insertBefore(r, a), r
                },
                G = function() {
                    function e(e) {
                        var t = this.element = z(e);
                        t.appendChild(document.createTextNode("")), this.sheet = function(e) {
                            if (e.sheet) return e.sheet;
                            for (var t = document.styleSheets, n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                if (i.ownerNode === e) return i
                            }
                            C(17)
                        }(t), this.length = 0
                    }
                    var t = e.prototype;
                    return t.insertRule = function(e, t) {
                        try {
                            return this.sheet.insertRule(t, e), this.length++, !0
                        } catch (n) {
                            return !1
                        }
                    }, t.deleteRule = function(e) {
                        this.sheet.deleteRule(e), this.length--
                    }, t.getRule = function(e) {
                        var t = this.sheet.cssRules[e];
                        return void 0 !== t && "string" == typeof t.cssText ? t.cssText : ""
                    }, e
                }(),
                V = function() {
                    function e(e) {
                        var t = this.element = z(e);
                        this.nodes = t.childNodes, this.length = 0
                    }
                    var t = e.prototype;
                    return t.insertRule = function(e, t) {
                        if (e <= this.length && e >= 0) {
                            var n = document.createTextNode(t),
                                r = this.nodes[e];
                            return this.element.insertBefore(n, r || null), this.length++, !0
                        }
                        return !1
                    }, t.deleteRule = function(e) {
                        this.element.removeChild(this.nodes[e]), this.length--
                    }, t.getRule = function(e) {
                        return e < this.length ? this.nodes[e].textContent : ""
                    }, e
                }(),
                W = function() {
                    function e(e) {
                        this.rules = [], this.length = 0
                    }
                    var t = e.prototype;
                    return t.insertRule = function(e, t) {
                        return e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0)
                    }, t.deleteRule = function(e) {
                        this.rules.splice(e, 1), this.length--
                    }, t.getRule = function(e) {
                        return e < this.length ? this.rules[e] : ""
                    }, e
                }(),
                H = T,
                j = {
                    isServer: !T,
                    useCSSOMInjection: !A
                },
                q = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = x), void 0 === t && (t = {}), this.options = g({}, j, {}, e), this.gs = t, this.names = new Map(n), this.server = !!e.isServer, !this.server && T && H && (H = !1, function(e) {
                            for (var t = document.querySelectorAll(U), n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i && "active" !== i.getAttribute(M) && (N(e, i), i.parentNode && i.parentNode.removeChild(i))
                            }
                        }(this))
                    }
                    e.registerId = function(e) {
                        return D(e)
                    };
                    var t = e.prototype;
                    return t.reconstructWithOptions = function(t, n) {
                        return void 0 === n && (n = !0), new e(g({}, this.options, {}, t), this.gs, n && this.names || void 0)
                    }, t.allocateGSInstance = function(e) {
                        return this.gs[e] = (this.gs[e] || 0) + 1
                    }, t.getTag = function() {
                        var e, t, n, r, i;
                        return this.tag || (this.tag = (n = (t = this.options).isServer, r = t.useCSSOMInjection, i = t.target, e = n ? new W(i) : r ? new G(i) : new V(i), new I(e)))
                    }, t.hasNameForId = function(e, t) {
                        return this.names.has(e) && this.names.get(e).has(t)
                    }, t.registerName = function(e, t) {
                        if (D(e), this.names.has(e)) this.names.get(e).add(t);
                        else {
                            var n = new Set;
                            n.add(t), this.names.set(e, n)
                        }
                    }, t.insertRules = function(e, t, n) {
                        this.registerName(e, t), this.getTag().insertRules(D(e), n)
                    }, t.clearNames = function(e) {
                        this.names.has(e) && this.names.get(e).clear()
                    }, t.clearRules = function(e) {
                        this.getTag().clearGroup(D(e)), this.clearNames(e)
                    }, t.clearTag = function() {
                        this.tag = void 0
                    }, t.toString = function() {
                        return function(e) {
                            for (var t = e.getTag(), n = t.length, r = "", i = 0; i < n; i++) {
                                var a, s = (a = i, R.get(a));
                                if (void 0 !== s) {
                                    var o = e.names.get(s),
                                        l = t.getGroup(i);
                                    if (o && l && o.size) {
                                        var u = M + ".g" + i + '[id="' + s + '"]',
                                            c = "";
                                        void 0 !== o && o.forEach(function(e) {
                                            e.length > 0 && (c += e + ",")
                                        }), r += "" + l + u + '{content:"' + c + '"}/*!sc*/\n'
                                    }
                                }
                            }
                            return r
                        }(this)
                    }, e
                }(),
                X = /(a)(d)/gi,
                Z = function(e) {
                    return String.fromCharCode(e + (e > 25 ? 39 : 97))
                };

            function Y(e) {
                var t, n = "";
                for (t = Math.abs(e); t > 52; t = t / 52 | 0) n = Z(t % 52) + n;
                return (Z(t % 52) + n).replace(X, "$1-$2")
            }
            var $ = function(e, t) {
                    for (var n = t.length; n;) e = 33 * e ^ t.charCodeAt(--n);
                    return e
                },
                J = function(e) {
                    return $(5381, e)
                };

            function K(e) {
                for (var t = 0; t < e.length; t += 1) {
                    var n = e[t];
                    if (b(n) && !S(n)) return !1
                }
                return !0
            }
            var Q = J("5.3.3"),
                ee = function() {
                    function e(e, t, n) {
                        this.rules = e, this.staticRulesId = "", this.isStatic = (void 0 === n || n.isStatic) && K(e), this.componentId = t, this.baseHash = $(Q, t), this.baseStyle = n, q.registerId(t)
                    }
                    return e.prototype.generateAndInjectStyles = function(e, t, n) {
                        var r = this.componentId,
                            i = [];
                        if (this.baseStyle && i.push(this.baseStyle.generateAndInjectStyles(e, t, n)), this.isStatic && !n.hash) {
                            if (this.staticRulesId && t.hasNameForId(r, this.staticRulesId)) i.push(this.staticRulesId);
                            else {
                                var a = e_(this.rules, e, t, n).join(""),
                                    s = Y($(this.baseHash, a) >>> 0);
                                if (!t.hasNameForId(r, s)) {
                                    var o = n(a, "." + s, void 0, r);
                                    t.insertRules(r, s, o)
                                }
                                i.push(s), this.staticRulesId = s
                            }
                        } else {
                            for (var l = this.rules.length, u = $(this.baseHash, n.hash), c = "", h = 0; h < l; h++) {
                                var d = this.rules[h];
                                if ("string" == typeof d) c += d;
                                else if (d) {
                                    var f = e_(d, e, t, n),
                                        p = Array.isArray(f) ? f.join("") : f;
                                    u = $(u, p + h), c += p
                                }
                            }
                            if (c) {
                                var m = Y(u >>> 0);
                                if (!t.hasNameForId(r, m)) {
                                    var g = n(c, "." + m, void 0, r);
                                    t.insertRules(r, m, g)
                                }
                                i.push(m)
                            }
                        }
                        return i.join(" ")
                    }, e
                }(),
                et = /^\s*\/\/.*$/gm,
                en = [":", "[", ".", "#"];

            function er(e) {
                var t, n, r, i, a = void 0 === e ? x : e,
                    s = a.options,
                    o = a.plugins,
                    l = void 0 === o ? y : o,
                    c = new u(void 0 === s ? x : s),
                    h = [],
                    d = function(e) {
                        function t(t) {
                            if (t) try {
                                e(t + "}")
                            } catch (n) {}
                        }
                        return function(n, r, i, a, s, o, l, u, c, h) {
                            switch (n) {
                                case 1:
                                    if (0 === c && 64 === r.charCodeAt(0)) return e(r + ";"), "";
                                    break;
                                case 2:
                                    if (0 === u) return r + "/*|*/";
                                    break;
                                case 3:
                                    switch (u) {
                                        case 102:
                                        case 112:
                                            return e(i[0] + r), "";
                                        default:
                                            return r + (0 === h ? "/*|*/" : "")
                                    }
                                case -2:
                                    r.split("/*|*/}").forEach(t)
                            }
                        }
                    }(function(e) {
                        h.push(e)
                    }),
                    f = function(e, r, a) {
                        return 0 === r && -1 !== en.indexOf(a[n.length]) || a.match(i) ? e : "." + t
                    };

                function p(e, a, s, o) {
                    void 0 === o && (o = "&");
                    var l = e.replace(et, "");
                    return t = o, r = RegExp("\\" + (n = a) + "\\b", "g"), i = RegExp("(\\" + n + "\\b){2,}"), c(s || !a ? "" : a, a && s ? s + " " + a + " { " + l + " }" : l)
                }
                return c.use([].concat(l, [function(e, t, i) {
                    2 === e && i.length && i[0].lastIndexOf(n) > 0 && (i[0] = i[0].replace(r, f))
                }, d, function(e) {
                    if (-2 === e) {
                        var t = h;
                        return h = [], t
                    }
                }])), p.hash = l.length ? l.reduce(function(e, t) {
                    return t.name || C(15), $(e, t.name)
                }, 5381).toString() : "", p
            }
            var ei = s.createContext(),
                ea = (ei.Consumer, s.createContext()),
                es = (ea.Consumer, new q),
                eo = er();

            function el() {
                return (0, s.useContext)(ei) || es
            }

            function eu() {
                return (0, s.useContext)(ea) || eo
            }

            function ec(e) {
                var t = (0, s.useState)(e.stylisPlugins),
                    n = t[0],
                    r = t[1],
                    i = el(),
                    a = (0, s.useMemo)(function() {
                        var t = i;
                        return e.sheet ? t = e.sheet : e.target && (t = t.reconstructWithOptions({
                            target: e.target
                        }, !1)), e.disableCSSOMInjection && (t = t.reconstructWithOptions({
                            useCSSOMInjection: !1
                        })), t
                    }, [e.disableCSSOMInjection, e.sheet, e.target]),
                    o = (0, s.useMemo)(function() {
                        return er({
                            options: {
                                prefix: !e.disableVendorPrefixes
                            },
                            plugins: n
                        })
                    }, [e.disableVendorPrefixes, n]);
                return (0, s.useEffect)(function() {
                    l()(n, e.stylisPlugins) || r(e.stylisPlugins)
                }, [e.stylisPlugins]), s.createElement(ei.Provider, {
                    value: a
                }, s.createElement(ea.Provider, {
                    value: o
                }, e.children))
            }
            var eh = function() {
                    function e(e, t) {
                        var n = this;
                        this.inject = function(e, t) {
                            void 0 === t && (t = eo);
                            var r = n.name + t.hash;
                            e.hasNameForId(n.id, r) || e.insertRules(n.id, r, t(n.rules, r, "@keyframes"))
                        }, this.toString = function() {
                            return C(12, String(n.name))
                        }, this.name = e, this.id = "sc-keyframes-" + e, this.rules = t
                    }
                    return e.prototype.getName = function(e) {
                        return void 0 === e && (e = eo), this.name + e.hash
                    }, e
                }(),
                ed = /([A-Z])/,
                ef = /([A-Z])/g,
                ep = /^ms-/,
                em = function(e) {
                    return "-" + e.toLowerCase()
                };

            function eg(e) {
                return ed.test(e) ? e.replace(ef, em).replace(ep, "-ms-") : e
            }
            var ev = function(e) {
                return null == e || !1 === e || "" === e
            };

            function e_(e, t, n, r) {
                if (Array.isArray(e)) {
                    for (var i, a = [], s = 0, o = e.length; s < o; s += 1) "" !== (i = e_(e[s], t, n, r)) && (Array.isArray(i) ? a.push.apply(a, i) : a.push(i));
                    return a
                }
                return ev(e) ? "" : S(e) ? "." + e.styledComponentId : b(e) ? "function" != typeof e || e.prototype && e.prototype.isReactComponent || !t ? e : e_(e(t), t, n, r) : e instanceof eh ? n ? (e.inject(n, r), e.getName(r)) : e : _(e) ? function e(t, n) {
                    var r, i, a = [];
                    for (var s in t) t.hasOwnProperty(s) && !ev(t[s]) && (Array.isArray(t[s]) && t[s].isCss || b(t[s]) ? a.push(eg(s) + ":", t[s], ";") : _(t[s]) ? a.push.apply(a, e(t[s], s)) : a.push(eg(s) + ": " + (r = s, null == (i = t[s]) || "boolean" == typeof i || "" === i ? "" : "number" != typeof i || 0 === i || r in c ? String(i).trim() : i + "px") + ";"));
                    return n ? [n + " {"].concat(a, ["}"]) : a
                }(e) : e.toString()
            }
            var ey = function(e) {
                return Array.isArray(e) && (e.isCss = !0), e
            };

            function ex(e) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                return b(e) || _(e) ? ey(e_(v(y, [e].concat(n)))) : 0 === n.length && 1 === e.length && "string" == typeof e[0] ? e : ey(e_(v(e, n)))
            }
            var eb = function(e, t, n) {
                    return void 0 === n && (n = x), e.theme !== n.theme && e.theme || t || n.theme
                },
                ew = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
                eS = /(^-|-$)/g;

            function eM(e) {
                return e.replace(ew, "-").replace(eS, "")
            }
            var eT = function(e) {
                return Y(J(e) >>> 0)
            };

            function eA(e) {
                return "string" == typeof e
            }
            var eE = function(e) {
                    return "function" == typeof e || "object" == typeof e && null !== e && !Array.isArray(e)
                },
                eC = s.createContext();

            function eI(e) {
                var t = (0, s.useContext)(eC),
                    n = (0, s.useMemo)(function() {
                        var n;
                        return (n = e.theme) ? b(n) ? n(t) : Array.isArray(n) || "object" != typeof n ? C(8) : t ? g({}, t, {}, n) : n : C(14)
                    }, [e.theme, t]);
                return e.children ? s.createElement(eC.Provider, {
                    value: n
                }, e.children) : null
            }
            eC.Consumer;
            var eP = {},
                eR = function(e) {
                    return function e(t, n, r) {
                        if (void 0 === r && (r = x), !(0, a.isValidElementType)(n)) return C(1, String(n));
                        var i = function() {
                            return t(n, r, ex.apply(void 0, arguments))
                        };
                        return i.withConfig = function(i) {
                            return e(t, n, g({}, r, {}, i))
                        }, i.attrs = function(i) {
                            return e(t, n, g({}, r, {
                                attrs: Array.prototype.concat(r.attrs, i).filter(Boolean)
                            }))
                        }, i
                    }(function e(t, n, r) {
                        var i = S(t),
                            a = !eA(t),
                            o = n.attrs,
                            l = void 0 === o ? y : o,
                            u = n.componentId,
                            c = void 0 === u ? (M = n.displayName, T = n.parentComponentId, eP[A = "string" != typeof M ? "sc" : eM(M)] = (eP[A] || 0) + 1, E = A + "-" + eT("5.3.3" + A + eP[A]), T ? T + "-" + E : E) : u,
                            h = n.displayName,
                            f = void 0 === h ? eA(t) ? "styled." + t : "Styled(" + w(t) + ")" : h,
                            m = n.displayName && n.componentId ? eM(n.displayName) + "-" + n.componentId : n.componentId || c,
                            v = i && t.attrs ? Array.prototype.concat(t.attrs, l).filter(Boolean) : l,
                            _ = n.shouldForwardProp;
                        i && t.shouldForwardProp && (_ = n.shouldForwardProp ? function(e, r, i) {
                            return t.shouldForwardProp(e, r, i) && n.shouldForwardProp(e, r, i)
                        } : t.shouldForwardProp);
                        var M, T, A, E, C, I = new ee(r, m, i ? t.componentStyle : void 0),
                            P = I.isStatic && 0 === l.length,
                            R = function(e, t) {
                                return function(e, t, n, r) {
                                    var i, a, o, l, u, c = e.attrs,
                                        h = e.componentStyle,
                                        f = e.defaultProps,
                                        p = e.foldedComponentIds,
                                        m = e.shouldForwardProp,
                                        v = e.styledComponentId,
                                        _ = e.target,
                                        y = (void 0 === (i = eb(t, (0, s.useContext)(eC), f) || x) && (i = x), a = g({}, t, {
                                            theme: i
                                        }), o = {}, c.forEach(function(e) {
                                            var t, n, r, i = e;
                                            for (t in b(i) && (i = i(a)), i) a[t] = o[t] = "className" === t ? (n = o[t], r = i[t], n && r ? n + " " + r : n || r) : i[t]
                                        }), [a, o]),
                                        w = y[0],
                                        S = y[1],
                                        M = (l = el(), u = eu(), r ? h.generateAndInjectStyles(x, l, u) : h.generateAndInjectStyles(w, l, u)),
                                        T = S.$as || t.$as || S.as || t.as || _,
                                        A = eA(T),
                                        E = S !== t ? g({}, t, {}, S) : t,
                                        C = {};
                                    for (var I in E) "$" !== I[0] && "as" !== I && ("forwardedAs" === I ? C.as = E[I] : (m ? m(I, d, T) : !A || d(I)) && (C[I] = E[I]));
                                    return t.style && S.style !== t.style && (C.style = g({}, t.style, {}, S.style)), C.className = Array.prototype.concat(p, v, M !== v ? M : null, t.className, S.className).filter(Boolean).join(" "), C.ref = n, (0, s.createElement)(T, C)
                                }(C, e, t, P)
                            };
                        return R.displayName = f, (C = s.forwardRef(R)).attrs = v, C.componentStyle = I, C.displayName = f, C.shouldForwardProp = _, C.foldedComponentIds = i ? Array.prototype.concat(t.foldedComponentIds, t.styledComponentId) : y, C.styledComponentId = m, C.target = i ? t.target : t, C.withComponent = function(t) {
                            var i = n.componentId,
                                a = function(e, t) {
                                    if (null == e) return {};
                                    var n, r, i = {},
                                        a = Object.keys(e);
                                    for (r = 0; r < a.length; r++) t.indexOf(n = a[r]) >= 0 || (i[n] = e[n]);
                                    return i
                                }(n, ["componentId"]),
                                s = i && i + "-" + (eA(t) ? t : eM(w(t)));
                            return e(t, g({}, a, {
                                attrs: v,
                                componentId: s
                            }), r)
                        }, Object.defineProperty(C, "defaultProps", {
                            get: function() {
                                return this._foldedDefaultProps
                            },
                            set: function(e) {
                                this._foldedDefaultProps = i ? function e(t) {
                                    for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                                    for (var a = 0; a < r.length; a++) {
                                        var s, o = r[a];
                                        if (eE(o))
                                            for (var l in o) "__proto__" !== (s = l) && "constructor" !== s && "prototype" !== s && function(t, n, r) {
                                                var i = t[r];
                                                eE(n) && eE(i) ? e(i, n) : t[r] = n
                                            }(t, o[l], l)
                                    }
                                    return t
                                }({}, t.defaultProps, e) : e
                            }
                        }), C.toString = function() {
                            return "." + C.styledComponentId
                        }, a && p()(C, t, {
                            attrs: !0,
                            componentStyle: !0,
                            displayName: !0,
                            foldedComponentIds: !0,
                            shouldForwardProp: !0,
                            styledComponentId: !0,
                            target: !0,
                            withComponent: !0
                        }), C
                    }, e)
                };
            ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e) {
                eR[e] = eR(e)
            });
            var eL = function() {
                function e(e, t) {
                    this.rules = e, this.componentId = t, this.isStatic = K(e), q.registerId(this.componentId + 1)
                }
                var t = e.prototype;
                return t.createStyles = function(e, t, n, r) {
                    var i = r(e_(this.rules, t, n, r).join(""), ""),
                        a = this.componentId + e;
                    n.insertRules(a, a, i)
                }, t.removeStyles = function(e, t) {
                    t.clearRules(this.componentId + e)
                }, t.renderStyles = function(e, t, n, r) {
                    e > 2 && q.registerId(this.componentId + e), this.removeStyles(e, n), this.createStyles(e, t, n, r)
                }, e
            }();

            function eD(e) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                var i = ex.apply(void 0, [e].concat(n)),
                    a = "sc-global-" + eT(JSON.stringify(i)),
                    o = new eL(i, a);

                function l(e) {
                    var t = el(),
                        n = eu(),
                        r = (0, s.useContext)(eC),
                        i = (0, s.useRef)(t.allocateGSInstance(a)).current;
                    return t.server && u(i, e, t, r, n), (0, s.useLayoutEffect)(function() {
                        if (!t.server) return u(i, e, t, r, n),
                            function() {
                                return o.removeStyles(i, t)
                            }
                    }, [i, e, t, r, n]), null
                }

                function u(e, t, n, r, i) {
                    if (o.isStatic) o.renderStyles(e, E, n, i);
                    else {
                        var a = g({}, t, {
                            theme: eb(t, r, l.defaultProps)
                        });
                        o.renderStyles(e, a, n, i)
                    }
                }
                return s.memo(l)
            }

            function ek(e) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                var i = ex.apply(void 0, [e].concat(n)).join(""),
                    a = eT(i);
                return new eh(a, i)
            }(i = (function() {
                var e = this;
                this._emitSheetCSS = function() {
                    var t = e.instance.toString();
                    if (!t) return "";
                    var n = B();
                    return "<style " + [n && 'nonce="' + n + '"', M + '="true"', 'data-styled-version="5.3.3"'].filter(Boolean).join(" ") + ">" + t + "</style>"
                }, this.getStyleTags = function() {
                    return e.sealed ? C(2) : e._emitSheetCSS()
                }, this.getStyleElement = function() {
                    if (e.sealed) return C(2);
                    var t, n = ((t = {})[M] = "", t["data-styled-version"] = "5.3.3", t.dangerouslySetInnerHTML = {
                            __html: e.instance.toString()
                        }, t),
                        r = B();
                    return r && (n.nonce = r), [s.createElement("style", g({}, n, {
                        key: "sc-0-0"
                    }))]
                }, this.seal = function() {
                    e.sealed = !0
                }, this.instance = new q({
                    isServer: !0
                }), this.sealed = !1
            }).prototype).collectStyles = function(e) {
                return this.sealed ? C(2) : s.createElement(ec, {
                    sheet: this.instance
                }, e)
            }, i.interleaveWithNodeStream = function(e) {
                return C(3)
            };
            var eU = eR
        },
        9240: function(e, t, n) {
            "use strict";
            let r, i;
            n.d(t, {
                xv: function() {
                    return ex
                },
                C5: function() {
                    return Z
                }
            });
            var a = n(9477);

            function s() {
                var e = Object.create(null);

                function t(e, t) {
                    var n = void 0;
                    self.troikaDefine = function(e) {
                        return n = e
                    };
                    var r = URL.createObjectURL(new Blob(["/** " + e.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + t + "\n)"], {
                        type: "application/javascript"
                    }));
                    try {
                        importScripts(r)
                    } catch (i) {
                        console.error(i)
                    }
                    return URL.revokeObjectURL(r), delete self.troikaDefine, n
                }
                self.addEventListener("message", function(n) {
                    var r = n.data,
                        i = r.messageId,
                        a = r.action,
                        s = r.data;
                    try {
                        "registerModule" === a && function n(r, i) {
                            var a = r.id,
                                s = r.name,
                                o = r.dependencies;
                            void 0 === o && (o = []);
                            var l = r.init;
                            void 0 === l && (l = function() {});
                            var u = r.getTransferables;
                            if (void 0 === u && (u = null), !e[a]) try {
                                o = o.map(function(t) {
                                    return t && t.isWorkerModule && (n(t, function(e) {
                                        if (e instanceof Error) throw e
                                    }), t = e[t.id].value), t
                                }), l = t("<" + s + ">.init", l), u && (u = t("<" + s + ">.getTransferables", u));
                                var c = null;
                                "function" == typeof l ? c = l.apply(void 0, o) : console.error("worker module init function failed to rehydrate"), e[a] = {
                                    id: a,
                                    value: c,
                                    getTransferables: u
                                }, i(c)
                            } catch (h) {
                                h && h.noLog || console.error(h), i(h)
                            }
                        }(s, function(e) {
                            e instanceof Error ? postMessage({
                                messageId: i,
                                success: !1,
                                error: e.message
                            }) : postMessage({
                                messageId: i,
                                success: !0,
                                result: {
                                    isCallable: "function" == typeof e
                                }
                            })
                        }), "callModule" === a && function(t, n) {
                            var r, i = t.id,
                                a = t.args;
                            e[i] && "function" == typeof e[i].value || n(Error("Worker module " + i + ": not found or its 'init' did not return a function"));
                            try {
                                var s = (r = e[i]).value.apply(r, a);
                                s && "function" == typeof s.then ? s.then(l, function(e) {
                                    return n(e instanceof Error ? e : Error("" + e))
                                }) : l(s)
                            } catch (o) {
                                n(o)
                            }

                            function l(t) {
                                try {
                                    var r = e[i].getTransferables && e[i].getTransferables(t);
                                    r && Array.isArray(r) && r.length || (r = void 0), n(t, r)
                                } catch (a) {
                                    console.error(a), n(a)
                                }
                            }
                        }(s, function(e, t) {
                            e instanceof Error ? postMessage({
                                messageId: i,
                                success: !1,
                                error: e.message
                            }) : postMessage({
                                messageId: i,
                                success: !0,
                                result: e
                            }, t || void 0)
                        })
                    } catch (o) {
                        postMessage({
                            messageId: i,
                            success: !1,
                            error: o.stack
                        })
                    }
                })
            }
            n(4155);
            var o = function() {
                    var e = !1;
                    if ("undefined" != typeof window && void 0 !== window.document) try {
                        new Worker(URL.createObjectURL(new Blob([""], {
                            type: "application/javascript"
                        }))).terminate(), e = !0
                    } catch (t) {
                        console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]")
                    }
                    return o = function() {
                        return e
                    }, e
                },
                l = 0,
                u = 0,
                c = !1,
                h = Object.create(null),
                d = Object.create(null),
                f = Object.create(null);

            function p(e) {
                if ((!e || "function" != typeof e.init) && !c) throw Error("requires `options.init` function");
                var t, n = e.dependencies,
                    r = e.init,
                    i = e.getTransferables,
                    a = e.workerId;
                if (!o()) return (t = function() {
                    for (var e = [], n = arguments.length; n--;) e[n] = arguments[n];
                    return t._getInitResult().then(function(t) {
                        if ("function" == typeof t) return t.apply(void 0, e);
                        throw Error("Worker module function was called but `init` did not return a callable function")
                    })
                })._getInitResult = function() {
                    var n = e.dependencies,
                        r = e.init,
                        i = Promise.all(n = Array.isArray(n) ? n.map(function(e) {
                            return e && e._getInitResult ? e._getInitResult() : e
                        }) : []).then(function(e) {
                            return r.apply(null, e)
                        });
                    return t._getInitResult = function() {
                        return i
                    }, i
                }, t;
                null == a && (a = "#default");
                var s = "workerModule" + ++l,
                    u = e.name || s,
                    h = null;

                function f() {
                    for (var e = [], t = arguments.length; t--;) e[t] = arguments[t];
                    if (!h) {
                        h = g(a, "registerModule", f.workerModuleData);
                        var n = function() {
                            h = null, d[a].delete(n)
                        };
                        (d[a] || (d[a] = new Set)).add(n)
                    }
                    return h.then(function(t) {
                        if (t.isCallable) return g(a, "callModule", {
                            id: s,
                            args: e
                        });
                        throw Error("Worker module function was called but `init` did not return a callable function")
                    })
                }
                return n = n && n.map(function(e) {
                    return "function" != typeof e || e.workerModuleData || (c = !0, e = p({
                        workerId: a,
                        name: "<" + u + "> function dependency: " + e.name,
                        init: "function(){return (\n" + m(e) + "\n)}"
                    }), c = !1), e && e.workerModuleData && (e = e.workerModuleData), e
                }), f.workerModuleData = {
                    isWorkerModule: !0,
                    id: s,
                    name: u,
                    dependencies: n,
                    init: m(r),
                    getTransferables: i && m(i)
                }, f
            }

            function m(e) {
                var t = e.toString();
                return !/^function/.test(t) && /^\w+\s*\(/.test(t) && (t = "function " + t), t
            }

            function g(e, t, n) {
                return new Promise(function(r, i) {
                    var a = ++u;
                    f[a] = function(e) {
                        e.success ? r(e.result) : i(Error("Error in worker " + t + " call: " + e.error))
                    }, (function(e) {
                        var t = h[e];
                        if (!t) {
                            var n = m(s);
                            (t = h[e] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + e.replace(/\*/g, "") + " **/\n\n;(" + n + ")()"], {
                                type: "application/javascript"
                            })))).onmessage = function(e) {
                                var t = e.data,
                                    n = t.messageId,
                                    r = f[n];
                                if (!r) throw Error("WorkerModule response with empty or unknown messageId");
                                delete f[n], r(t)
                            }
                        }
                        return t
                    })(e).postMessage({
                        messageId: a,
                        action: t,
                        data: n
                    })
                })
            }

            function v() {
                return function(e) {
                    function t(e, t) {
                        for (var n, r, i, a, s, o = /([MLQCZ])([^MLQCZ]*)/g; n = o.exec(e);) {
                            var l = n[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(e) {
                                return parseFloat(e)
                            });
                            switch (n[1]) {
                                case "M":
                                    a = r = l[0], s = i = l[1];
                                    break;
                                case "L":
                                    (l[0] !== a || l[1] !== s) && t("L", a, s, a = l[0], s = l[1]);
                                    break;
                                case "Q":
                                    t("Q", a, s, a = l[2], s = l[3], l[0], l[1]);
                                    break;
                                case "C":
                                    t("C", a, s, a = l[4], s = l[5], l[0], l[1], l[2], l[3]);
                                    break;
                                case "Z":
                                    (a !== r || s !== i) && t("L", a, s, r, i)
                            }
                        }
                    }

                    function n(e, n, r) {
                        void 0 === r && (r = 16);
                        var i = {
                            x: 0,
                            y: 0
                        };
                        t(e, function(e, t, a, s, o, l, u, c, h) {
                            switch (e) {
                                case "L":
                                    n(t, a, s, o);
                                    break;
                                case "Q":
                                    for (var d = t, f = a, p = 1; p < r; p++) ! function(e, t, n, r, i, a, s, o) {
                                        var l = 1 - s;
                                        o.x = l * l * e + 2 * l * s * n + s * s * i, o.y = l * l * t + 2 * l * s * r + s * s * a
                                    }(t, a, l, u, s, o, p / (r - 1), i), n(d, f, i.x, i.y), d = i.x, f = i.y;
                                    break;
                                case "C":
                                    for (var m = t, g = a, v = 1; v < r; v++) ! function(e, t, n, r, i, a, s, o, l, u) {
                                        var c = 1 - l;
                                        u.x = c * c * c * e + 3 * c * c * l * n + 3 * c * l * l * i + l * l * l * s, u.y = c * c * c * t + 3 * c * c * l * r + 3 * c * l * l * a + l * l * l * o
                                    }(t, a, l, u, c, h, s, o, v / (r - 1), i), n(m, g, i.x, i.y), m = i.x, g = i.y
                            }
                        })
                    }
                    var r = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
                        i = new WeakMap,
                        a = {
                            premultipliedAlpha: !1,
                            preserveDrawingBuffer: !0,
                            antialias: !1,
                            depth: !1
                        };

                    function s(e, t) {
                        var n = e.getContext ? e.getContext("webgl", a) : e,
                            r = i.get(n);
                        if (!r) {
                            var s = "undefined" != typeof WebGL2RenderingContext && n instanceof WebGL2RenderingContext,
                                o = {},
                                l = {},
                                u = {},
                                c = -1,
                                h = [];

                            function d(e) {
                                var t = o[e];
                                if (!t && !(t = o[e] = n.getExtension(e))) throw Error(e + " not supported");
                                return t
                            }

                            function f(e, t) {
                                var r = n.createShader(t);
                                return n.shaderSource(r, e), n.compileShader(r), r
                            }

                            function p() {
                                o = {}, l = {}, u = {}, c = -1, h.length = 0
                            }
                            n.canvas.addEventListener("webglcontextlost", function(e) {
                                p(), e.preventDefault()
                            }, !1), i.set(n, r = {
                                gl: n,
                                isWebGL2: s,
                                getExtension: d,
                                withProgram: function(e, t, r, i) {
                                    if (!l[e]) {
                                        var a = {},
                                            o = {},
                                            u = n.createProgram();
                                        n.attachShader(u, f(t, n.VERTEX_SHADER)), n.attachShader(u, f(r, n.FRAGMENT_SHADER)), n.linkProgram(u), l[e] = {
                                            program: u,
                                            transaction: function(e) {
                                                n.useProgram(u), e({
                                                    setUniform: function(e, t) {
                                                        for (var r = [], i = arguments.length - 2; i-- > 0;) r[i] = arguments[i + 2];
                                                        var a = o[t] || (o[t] = n.getUniformLocation(u, t));
                                                        n["uniform" + e].apply(n, [a].concat(r))
                                                    },
                                                    setAttribute: function(e, t, r, i, o) {
                                                        var l = a[e];
                                                        l || (l = a[e] = {
                                                            buf: n.createBuffer(),
                                                            loc: n.getAttribLocation(u, e),
                                                            data: null
                                                        }), n.bindBuffer(n.ARRAY_BUFFER, l.buf), n.vertexAttribPointer(l.loc, t, n.FLOAT, !1, 0, 0), n.enableVertexAttribArray(l.loc), s ? n.vertexAttribDivisor(l.loc, i) : d("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(l.loc, i), o !== l.data && (n.bufferData(n.ARRAY_BUFFER, o, r), l.data = o)
                                                    }
                                                })
                                            }
                                        }
                                    }
                                    l[e].transaction(i)
                                },
                                withTexture: function(e, t) {
                                    c++;
                                    try {
                                        n.activeTexture(n.TEXTURE0 + c);
                                        var r = u[e];
                                        r || (r = u[e] = n.createTexture(), n.bindTexture(n.TEXTURE_2D, r), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST)), n.bindTexture(n.TEXTURE_2D, r), t(r, c)
                                    } finally {
                                        c--
                                    }
                                },
                                withTextureFramebuffer: function(e, t, r) {
                                    var i = n.createFramebuffer();
                                    h.push(i), n.bindFramebuffer(n.FRAMEBUFFER, i), n.activeTexture(n.TEXTURE0 + t), n.bindTexture(n.TEXTURE_2D, e), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0);
                                    try {
                                        r(i)
                                    } finally {
                                        n.deleteFramebuffer(i), n.bindFramebuffer(n.FRAMEBUFFER, h[--h.length - 1] || null)
                                    }
                                },
                                handleContextLoss: p
                            })
                        }
                        t(r)
                    }

                    function o(e, t, n, i, a, o, l, u) {
                        void 0 === l && (l = 15), void 0 === u && (u = null), s(e, function(e) {
                            var s = e.gl,
                                c = e.withProgram;
                            (0, e.withTexture)("copy", function(e, h) {
                                s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, a, o, 0, s.RGBA, s.UNSIGNED_BYTE, t), c("copy", r, "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", function(e) {
                                    var t = e.setUniform;
                                    (0, e.setAttribute)("aUV", 2, s.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), t("1i", "image", h), s.bindFramebuffer(s.FRAMEBUFFER, u || null), s.disable(s.BLEND), s.colorMask(8 & l, 4 & l, 2 & l, 1 & l), s.viewport(n, i, a, o), s.scissor(n, i, a, o), s.drawArrays(s.TRIANGLES, 0, 3)
                                })
                            })
                        })
                    }
                    var l = Object.freeze({
                        __proto__: null,
                        withWebGLContext: s,
                        renderImageData: o,
                        resizeWebGLCanvasWithoutClearing: function(e, t, n) {
                            var r = e.width,
                                i = e.height;
                            s(e, function(a) {
                                var s = a.gl,
                                    l = new Uint8Array(r * i * 4);
                                s.readPixels(0, 0, r, i, s.RGBA, s.UNSIGNED_BYTE, l), e.width = t, e.height = n, o(s, l, 0, 0, r, i)
                            })
                        }
                    });

                    function u(e, t, r, i, a, s) {
                        void 0 === s && (s = 1);
                        var o = new Uint8Array(e * t),
                            l = i[2] - i[0],
                            u = i[3] - i[1],
                            c = [];
                        n(r, function(e, t, n, r) {
                            c.push({
                                x1: e,
                                y1: t,
                                x2: n,
                                y2: r,
                                minX: Math.min(e, n),
                                minY: Math.min(t, r),
                                maxX: Math.max(e, n),
                                maxY: Math.max(t, r)
                            })
                        }), c.sort(function(e, t) {
                            return e.maxX - t.maxX
                        });
                        for (var h = 0; h < e; h++)
                            for (var d = 0; d < t; d++) {
                                var f = function(e, t) {
                                        for (var n = 1 / 0, r = 1 / 0, i = c.length; i--;) {
                                            var a = c[i];
                                            if (a.maxX + r <= e) break;
                                            if (e + r > a.minX && t - r < a.maxY && t + r > a.minY) {
                                                var s = function(e, t, n, r, i, a) {
                                                    var s = i - n,
                                                        o = a - r,
                                                        l = s * s + o * o,
                                                        u = l ? Math.max(0, Math.min(1, ((e - n) * s + (t - r) * o) / l)) : 0,
                                                        c = e - (n + u * s),
                                                        h = t - (r + u * o);
                                                    return c * c + h * h
                                                }(e, t, a.x1, a.y1, a.x2, a.y2);
                                                s < n && (r = Math.sqrt(n = s))
                                            }
                                        }
                                        return function(e, t) {
                                            for (var n = 0, r = c.length; r--;) {
                                                var i = c[r];
                                                if (i.maxX <= e) break;
                                                i.y1 > t != i.y2 > t && e < (i.x2 - i.x1) * (t - i.y1) / (i.y2 - i.y1) + i.x1 && (n += i.y1 < i.y2 ? 1 : -1)
                                            }
                                            return 0 !== n
                                        }(e, t) && (r = -r), r
                                    }(i[0] + l * (h + .5) / e, i[1] + u * (d + .5) / t),
                                    p = Math.pow(1 - Math.abs(f) / a, s) / 2;
                                f < 0 && (p = 1 - p), p = Math.max(0, Math.min(255, Math.round(255 * p))), o[d * e + h] = p
                            }
                        return o
                    }

                    function c(e, t, n, r, i, a, s, o, l, u) {
                        void 0 === a && (a = 1), void 0 === o && (o = 0), void 0 === l && (l = 0), void 0 === u && (u = 0), h(e, t, n, r, i, a, s, null, o, l, u)
                    }

                    function h(e, t, n, r, i, a, s, l, c, h, d) {
                        void 0 === a && (a = 1), void 0 === c && (c = 0), void 0 === h && (h = 0), void 0 === d && (d = 0);
                        for (var f = u(e, t, n, r, i, a), p = new Uint8Array(4 * f.length), m = 0; m < f.length; m++) p[4 * m + d] = f[m];
                        o(s, p, c, h, e, t, 1 << 3 - d, l)
                    }
                    var d = Object.freeze({
                            __proto__: null,
                            generate: u,
                            generateIntoCanvas: c,
                            generateIntoFramebuffer: h
                        }),
                        f = new Float32Array([0, 0, 2, 0, 0, 2]),
                        p = null,
                        m = !1,
                        g = {},
                        v = new WeakMap;

                    function _(e) {
                        if (!m && !w(e)) throw Error("WebGL generation not supported")
                    }

                    function y(e, t, n, r, i, a, o) {
                        if (void 0 === a && (a = 1), void 0 === o && (o = null), !o && !(o = p)) {
                            var l = "function" == typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : "undefined" != typeof document ? document.createElement("canvas") : null;
                            if (!l) throw Error("OffscreenCanvas or DOM canvas not supported");
                            o = p = l.getContext("webgl", {
                                depth: !1
                            })
                        }
                        _(o);
                        var u = new Uint8Array(e * t * 4);
                        s(o, function(s) {
                            var o = s.gl,
                                l = s.withTexture,
                                c = s.withTextureFramebuffer;
                            l("readable", function(s, l) {
                                o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, e, t, 0, o.RGBA, o.UNSIGNED_BYTE, null), c(s, l, function(s) {
                                    b(e, t, n, r, i, a, o, s, 0, 0, 0), o.readPixels(0, 0, e, t, o.RGBA, o.UNSIGNED_BYTE, u)
                                })
                            })
                        });
                        for (var c = new Uint8Array(e * t), h = 0, d = 0; h < u.length; h += 4) c[d++] = u[h];
                        return c
                    }

                    function x(e, t, n, r, i, a, s, o, l, u) {
                        void 0 === a && (a = 1), void 0 === o && (o = 0), void 0 === l && (l = 0), void 0 === u && (u = 0), b(e, t, n, r, i, a, s, null, o, l, u)
                    }

                    function b(e, t, i, a, o, l, u, c, h, d, p) {
                        void 0 === l && (l = 1), void 0 === h && (h = 0), void 0 === d && (d = 0), void 0 === p && (p = 0), _(u);
                        var m = [];
                        n(i, function(e, t, n, r) {
                            m.push(e, t, n, r)
                        }), m = new Float32Array(m), s(u, function(n) {
                            var i = n.gl,
                                s = n.isWebGL2,
                                u = n.getExtension,
                                g = n.withProgram,
                                v = n.withTexture,
                                _ = n.withTextureFramebuffer,
                                y = n.handleContextLoss;
                            if (v("rawDistances", function(n, v) {
                                    (e !== n._lastWidth || t !== n._lastHeight) && i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, n._lastWidth = e, n._lastHeight = t, 0, i.RGBA, i.UNSIGNED_BYTE, null), g("main", "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", function(r) {
                                        var c = r.setAttribute,
                                            h = r.setUniform,
                                            d = !s && u("ANGLE_instanced_arrays"),
                                            p = !s && u("EXT_blend_minmax");
                                        c("aUV", 2, i.STATIC_DRAW, 0, f), c("aLineSegment", 4, i.DYNAMIC_DRAW, 1, m), h.apply(void 0, ["4f", "uGlyphBounds"].concat(a)), h("1f", "uMaxDistance", o), h("1f", "uExponent", l), _(n, v, function(n) {
                                            i.enable(i.BLEND), i.colorMask(!0, !0, !0, !0), i.viewport(0, 0, e, t), i.scissor(0, 0, e, t), i.blendFunc(i.ONE, i.ONE), i.blendEquationSeparate(i.FUNC_ADD, s ? i.MAX : p.MAX_EXT), i.clear(i.COLOR_BUFFER_BIT), s ? i.drawArraysInstanced(i.TRIANGLES, 0, 3, m.length / 4) : d.drawArraysInstancedANGLE(i.TRIANGLES, 0, 3, m.length / 4)
                                        })
                                    }), g("post", r, "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", function(n) {
                                        n.setAttribute("aUV", 2, i.STATIC_DRAW, 0, f), n.setUniform("1i", "tex", v), i.bindFramebuffer(i.FRAMEBUFFER, c), i.disable(i.BLEND), i.colorMask(0 === p, 1 === p, 2 === p, 3 === p), i.viewport(h, d, e, t), i.scissor(h, d, e, t), i.drawArrays(i.TRIANGLES, 0, 3)
                                    })
                                }), i.isContextLost()) throw y(), Error("webgl context lost")
                        })
                    }

                    function w(e) {
                        var t = e && e !== p ? e.canvas || e : g,
                            n = v.get(t);
                        if (void 0 === n) {
                            m = !0;
                            var r = null;
                            try {
                                var i = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97],
                                    a = y(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, e);
                                (n = a && i.length === a.length && a.every(function(e, t) {
                                    return e === i[t]
                                })) || (r = "bad trial run results", console.info(i, a))
                            } catch (s) {
                                n = !1, r = s.message
                            }
                            r && console.warn("WebGL SDF generation not supported:", r), m = !1, v.set(t, n)
                        }
                        return n
                    }
                    var S = Object.freeze({
                        __proto__: null,
                        generate: y,
                        generateIntoCanvas: x,
                        generateIntoFramebuffer: b,
                        isSupported: w
                    });
                    return e.forEachPathCommand = t, e.generate = function(e, t, n, r, i, a) {
                        void 0 === i && (i = Math.max(r[2] - r[0], r[3] - r[1]) / 2), void 0 === a && (a = 1);
                        try {
                            return y.apply(S, arguments)
                        } catch (s) {
                            return console.info("WebGL SDF generation failed, falling back to JS", s), u.apply(d, arguments)
                        }
                    }, e.generateIntoCanvas = function(e, t, n, r, i, a, s, o, l, u) {
                        void 0 === i && (i = Math.max(r[2] - r[0], r[3] - r[1]) / 2), void 0 === a && (a = 1), void 0 === o && (o = 0), void 0 === l && (l = 0), void 0 === u && (u = 0);
                        try {
                            return x.apply(S, arguments)
                        } catch (h) {
                            return console.info("WebGL SDF generation failed, falling back to JS", h), c.apply(d, arguments)
                        }
                    }, e.javascript = d, e.pathToLineSegments = n, e.webgl = S, e.webglUtils = l, Object.defineProperty(e, "__esModule", {
                        value: !0
                    }), e
                }({})
            }
            let _ = /\bvoid\s+main\s*\(\s*\)\s*{/g;

            function y(e) {
                return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, t) {
                    let n = a.ShaderChunk[t];
                    return n ? y(n) : e
                })
            }
            let x = [];
            for (let b = 0; b < 256; b++) x[b] = (b < 16 ? "0" : "") + b.toString(16);
            let w = Object.assign || function() {
                    let e = arguments[0];
                    for (let t = 1, n = arguments.length; t < n; t++) {
                        let r = arguments[t];
                        if (r)
                            for (let i in r) r.hasOwnProperty(i) && (e[i] = r[i])
                    }
                    return e
                },
                S = Date.now(),
                M = new WeakMap,
                T = new Map,
                A = 1e10;

            function E(e, t, n, r, i) {
                return (r || i || n) && (e = e.replace(_, `
${n}
void troikaOrigMain${t}() {`) + `
void main() {
  ${r}
  troikaOrigMain${t}();
  ${i}
}`), e
            }

            function C(e, t) {
                return "uniforms" === e ? void 0 : "function" == typeof t ? t.toString() : t
            }
            let I = 0,
                P = new Map;
            a.DoubleSide;
            let R = () => (self.performance || Date).now(),
                L = v(),
                D = [],
                k = 0;

            function U() {
                let e = R();
                for (; D.length && R() - e < 5;) D.shift()();
                k = D.length ? setTimeout(U, 0) : 0
            }
            let O = (...e) => new Promise((t, n) => {
                    D.push(() => {
                        let r = R();
                        try {
                            L.webgl.generateIntoCanvas(...e), t({
                                timing: R() - r
                            })
                        } catch (i) {
                            n(i)
                        }
                    }), k || (k = setTimeout(U, 0))
                }),
                F = {},
                N = 0;

            function B(e, t, n, r, i, a, s, o, l, u) {
                let c = "TroikaTextSDFGenerator_JS_" + N++ % 4,
                    f = F[c];
                return f || (f = F[c] = {
                    workerModule: p({
                        name: c,
                        workerId: c,
                        dependencies: [v, R],
                        init(e, t) {
                            let n = e().javascript.generate;
                            return function(...e) {
                                let r = t(),
                                    i = n(...e);
                                return {
                                    textureData: i,
                                    timing: t() - r
                                }
                            }
                        },
                        getTransferables: e => [e.textureData.buffer]
                    }),
                    requests: 0,
                    idleTimer: null
                }), f.requests++, clearTimeout(f.idleTimer), f.workerModule(e, t, n, r, i, a).then(({
                    textureData: n,
                    timing: r
                }) => {
                    let i = R(),
                        a = new Uint8Array(4 * n.length);
                    for (let p = 0; p < n.length; p++) a[4 * p + u] = n[p];
                    return L.webglUtils.renderImageData(s, a, o, l, e, t, 1 << 3 - u), r += R() - i, 0 == --f.requests && (f.idleTimer = setTimeout(() => {
                        d[c] && d[c].forEach(function(e) {
                            e()
                        }), h[c] && (h[c].terminate(), delete h[c])
                    }, 2e3)), {
                        timing: r
                    }
                })
            }
            let z = L.webglUtils.resizeWebGLCanvasWithoutClearing,
                G = p({
                    name: "Typr Font Parser",
                    dependencies: [
                        /*!
                        Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
                        Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
                        */
                        function() {
                            var e, t, n;
                            return "undefined" == typeof window && (self.window = self), (e = {}, (t = {
                                parse: function(e) {
                                    var n = t._bin,
                                        r = new Uint8Array(e);
                                    if ("ttcf" == n.readASCII(r, 0, 4)) {
                                        var i = 4;
                                        n.readUshort(r, i), i += 2, n.readUshort(r, i), i += 2;
                                        var a = n.readUint(r, i);
                                        i += 4;
                                        for (var s = [], o = 0; o < a; o++) {
                                            var l = n.readUint(r, i);
                                            i += 4, s.push(t._readFont(r, l))
                                        }
                                        return s
                                    }
                                    return [t._readFont(r, 0)]
                                },
                                _readFont: function(e, n) {
                                    var r = t._bin,
                                        i = n;
                                    r.readFixed(e, n), n += 4;
                                    var a = r.readUshort(e, n);
                                    n += 2, r.readUshort(e, n), n += 2, r.readUshort(e, n), n += 2, r.readUshort(e, n), n += 2;
                                    for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], o = {
                                            _data: e,
                                            _offset: i
                                        }, l = {}, u = 0; u < a; u++) {
                                        var c = r.readASCII(e, n, 4);
                                        n += 4, r.readUint(e, n), n += 4;
                                        var h = r.readUint(e, n);
                                        n += 4;
                                        var d = r.readUint(e, n);
                                        n += 4, l[c] = {
                                            offset: h,
                                            length: d
                                        }
                                    }
                                    for (u = 0; u < s.length; u++) {
                                        var f = s[u];
                                        l[f] && (o[f.trim()] = t[f.trim()].parse(e, l[f].offset, l[f].length, o))
                                    }
                                    return o
                                },
                                _tabOffset: function(e, n, r) {
                                    for (var i = t._bin, a = i.readUshort(e, r + 4), s = r + 12, o = 0; o < a; o++) {
                                        var l = i.readASCII(e, s, 4);
                                        s += 4, i.readUint(e, s), s += 4;
                                        var u = i.readUint(e, s);
                                        if (s += 4, i.readUint(e, s), s += 4, l == n) return u
                                    }
                                    return 0
                                }
                            })._bin = {
                                readFixed: function(e, t) {
                                    return (e[t] << 8 | e[t + 1]) + (e[t + 2] << 8 | e[t + 3]) / 65540
                                },
                                readF2dot14: function(e, n) {
                                    return t._bin.readShort(e, n) / 16384
                                },
                                readInt: function(e, n) {
                                    return t._bin._view(e).getInt32(n)
                                },
                                readInt8: function(e, n) {
                                    return t._bin._view(e).getInt8(n)
                                },
                                readShort: function(e, n) {
                                    return t._bin._view(e).getInt16(n)
                                },
                                readUshort: function(e, n) {
                                    return t._bin._view(e).getUint16(n)
                                },
                                readUshorts: function(e, n, r) {
                                    for (var i = [], a = 0; a < r; a++) i.push(t._bin.readUshort(e, n + 2 * a));
                                    return i
                                },
                                readUint: function(e, n) {
                                    return t._bin._view(e).getUint32(n)
                                },
                                readUint64: function(e, n) {
                                    return 4294967296 * t._bin.readUint(e, n) + t._bin.readUint(e, n + 4)
                                },
                                readASCII: function(e, t, n) {
                                    for (var r = "", i = 0; i < n; i++) r += String.fromCharCode(e[t + i]);
                                    return r
                                },
                                readUnicode: function(e, t, n) {
                                    for (var r = "", i = 0; i < n; i++) r += String.fromCharCode(e[t++] << 8 | e[t++]);
                                    return r
                                },
                                _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder : null,
                                readUTF8: function(e, n, r) {
                                    var i = t._bin._tdec;
                                    return i && 0 == n && r == e.length ? i.decode(e) : t._bin.readASCII(e, n, r)
                                },
                                readBytes: function(e, t, n) {
                                    for (var r = [], i = 0; i < n; i++) r.push(e[t + i]);
                                    return r
                                },
                                readASCIIArray: function(e, t, n) {
                                    for (var r = [], i = 0; i < n; i++) r.push(String.fromCharCode(e[t + i]));
                                    return r
                                },
                                _view: function(e) {
                                    return e._dataView || (e._dataView = e.buffer ? new DataView(e.buffer, e.byteOffset, e.byteLength) : new DataView(new Uint8Array(e).buffer))
                                }
                            }, t._lctf = {}, t._lctf.parse = function(e, n, r, i, a) {
                                var s = t._bin,
                                    o = {},
                                    l = n;
                                s.readFixed(e, n), n += 4;
                                var u = s.readUshort(e, n);
                                n += 2;
                                var c = s.readUshort(e, n);
                                n += 2;
                                var h = s.readUshort(e, n);
                                return n += 2, o.scriptList = t._lctf.readScriptList(e, l + u), o.featureList = t._lctf.readFeatureList(e, l + c), o.lookupList = t._lctf.readLookupList(e, l + h, a), o
                            }, t._lctf.readLookupList = function(e, n, r) {
                                var i = t._bin,
                                    a = n,
                                    s = [],
                                    o = i.readUshort(e, n);
                                n += 2;
                                for (var l = 0; l < o; l++) {
                                    var u = i.readUshort(e, n);
                                    n += 2;
                                    var c = t._lctf.readLookupTable(e, a + u, r);
                                    s.push(c)
                                }
                                return s
                            }, t._lctf.readLookupTable = function(e, n, r) {
                                var i = t._bin,
                                    a = n,
                                    s = {
                                        tabs: []
                                    };
                                s.ltype = i.readUshort(e, n), n += 2, s.flag = i.readUshort(e, n), n += 2;
                                var o = i.readUshort(e, n);
                                n += 2;
                                for (var l = s.ltype, u = 0; u < o; u++) {
                                    var c = i.readUshort(e, n);
                                    n += 2;
                                    var h = r(e, l, a + c, s);
                                    s.tabs.push(h)
                                }
                                return s
                            }, t._lctf.numOfOnes = function(e) {
                                for (var t = 0, n = 0; n < 32; n++) 0 != (e >>> n & 1) && t++;
                                return t
                            }, t._lctf.readClassDef = function(e, n) {
                                var r = t._bin,
                                    i = [],
                                    a = r.readUshort(e, n);
                                if (n += 2, 1 == a) {
                                    var s = r.readUshort(e, n);
                                    n += 2;
                                    var o = r.readUshort(e, n);
                                    n += 2;
                                    for (var l = 0; l < o; l++) i.push(s + l), i.push(s + l), i.push(r.readUshort(e, n)), n += 2
                                }
                                if (2 == a) {
                                    var u = r.readUshort(e, n);
                                    for (n += 2, l = 0; l < u; l++) i.push(r.readUshort(e, n)), n += 2, i.push(r.readUshort(e, n)), n += 2, i.push(r.readUshort(e, n)), n += 2
                                }
                                return i
                            }, t._lctf.getInterval = function(e, t) {
                                for (var n = 0; n < e.length; n += 3) {
                                    var r = e[n],
                                        i = e[n + 1];
                                    if (e[n + 2], r <= t && t <= i) return n
                                }
                                return -1
                            }, t._lctf.readCoverage = function(e, n) {
                                var r = t._bin,
                                    i = {};
                                i.fmt = r.readUshort(e, n), n += 2;
                                var a = r.readUshort(e, n);
                                return n += 2, 1 == i.fmt && (i.tab = r.readUshorts(e, n, a)), 2 == i.fmt && (i.tab = r.readUshorts(e, n, 3 * a)), i
                            }, t._lctf.coverageIndex = function(e, n) {
                                var r = e.tab;
                                if (1 == e.fmt) return r.indexOf(n);
                                if (2 == e.fmt) {
                                    var i = t._lctf.getInterval(r, n);
                                    if (-1 != i) return r[i + 2] + (n - r[i])
                                }
                                return -1
                            }, t._lctf.readFeatureList = function(e, n) {
                                var r = t._bin,
                                    i = n,
                                    a = [],
                                    s = r.readUshort(e, n);
                                n += 2;
                                for (var o = 0; o < s; o++) {
                                    var l = r.readASCII(e, n, 4);
                                    n += 4;
                                    var u = r.readUshort(e, n);
                                    n += 2;
                                    var c = t._lctf.readFeatureTable(e, i + u);
                                    c.tag = l.trim(), a.push(c)
                                }
                                return a
                            }, t._lctf.readFeatureTable = function(e, n) {
                                var r = t._bin,
                                    i = n,
                                    a = {},
                                    s = r.readUshort(e, n);
                                n += 2, s > 0 && (a.featureParams = i + s);
                                var o = r.readUshort(e, n);
                                n += 2, a.tab = [];
                                for (var l = 0; l < o; l++) a.tab.push(r.readUshort(e, n + 2 * l));
                                return a
                            }, t._lctf.readScriptList = function(e, n) {
                                var r = t._bin,
                                    i = n,
                                    a = {},
                                    s = r.readUshort(e, n);
                                n += 2;
                                for (var o = 0; o < s; o++) {
                                    var l = r.readASCII(e, n, 4);
                                    n += 4;
                                    var u = r.readUshort(e, n);
                                    n += 2, a[l.trim()] = t._lctf.readScriptTable(e, i + u)
                                }
                                return a
                            }, t._lctf.readScriptTable = function(e, n) {
                                var r = t._bin,
                                    i = n,
                                    a = {},
                                    s = r.readUshort(e, n);
                                n += 2, a.default = t._lctf.readLangSysTable(e, i + s);
                                var o = r.readUshort(e, n);
                                n += 2;
                                for (var l = 0; l < o; l++) {
                                    var u = r.readASCII(e, n, 4);
                                    n += 4;
                                    var c = r.readUshort(e, n);
                                    n += 2, a[u.trim()] = t._lctf.readLangSysTable(e, i + c)
                                }
                                return a
                            }, t._lctf.readLangSysTable = function(e, n) {
                                var r = t._bin,
                                    i = {};
                                r.readUshort(e, n), n += 2, i.reqFeature = r.readUshort(e, n), n += 2;
                                var a = r.readUshort(e, n);
                                return n += 2, i.features = r.readUshorts(e, n, a), i
                            }, t.CFF = {}, t.CFF.parse = function(e, n, r) {
                                var i = t._bin;
                                (e = new Uint8Array(e.buffer, n, r))[n = 0], e[++n], e[++n], e[++n], n++;
                                var a = [];
                                n = t.CFF.readIndex(e, n, a);
                                for (var s = [], o = 0; o < a.length - 1; o++) s.push(i.readASCII(e, n + a[o], a[o + 1] - a[o]));
                                n += a[a.length - 1];
                                var l = [];
                                n = t.CFF.readIndex(e, n, l);
                                var u = [];
                                for (o = 0; o < l.length - 1; o++) u.push(t.CFF.readDict(e, n + l[o], n + l[o + 1]));
                                n += l[l.length - 1];
                                var c = u[0],
                                    h = [];
                                n = t.CFF.readIndex(e, n, h);
                                var d = [];
                                for (o = 0; o < h.length - 1; o++) d.push(i.readASCII(e, n + h[o], h[o + 1] - h[o]));
                                if (n += h[h.length - 1], t.CFF.readSubrs(e, n, c), c.CharStrings) {
                                    n = c.CharStrings, h = [], n = t.CFF.readIndex(e, n, h);
                                    var f = [];
                                    for (o = 0; o < h.length - 1; o++) f.push(i.readBytes(e, n + h[o], h[o + 1] - h[o]));
                                    c.CharStrings = f
                                }
                                if (c.ROS) {
                                    n = c.FDArray;
                                    var p = [];
                                    for (n = t.CFF.readIndex(e, n, p), c.FDArray = [], o = 0; o < p.length - 1; o++) {
                                        var m = t.CFF.readDict(e, n + p[o], n + p[o + 1]);
                                        t.CFF._readFDict(e, m, d), c.FDArray.push(m)
                                    }
                                    n += p[p.length - 1], n = c.FDSelect, c.FDSelect = [];
                                    var g = e[n];
                                    if (n++, 3 != g) throw g;
                                    var v = i.readUshort(e, n);
                                    for (n += 2, o = 0; o < v + 1; o++) c.FDSelect.push(i.readUshort(e, n), e[n + 2]), n += 3
                                }
                                return c.Encoding && (c.Encoding = t.CFF.readEncoding(e, c.Encoding, c.CharStrings.length)), c.charset && (c.charset = t.CFF.readCharset(e, c.charset, c.CharStrings.length)), t.CFF._readFDict(e, c, d), c
                            }, t.CFF._readFDict = function(e, n, r) {
                                var i;
                                for (var a in n.Private && (i = n.Private[1], n.Private = t.CFF.readDict(e, i, i + n.Private[0]), n.Private.Subrs && t.CFF.readSubrs(e, i + n.Private.Subrs, n.Private)), n) - 1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) && (n[a] = r[n[a] - 426 + 35])
                            }, t.CFF.readSubrs = function(e, n, r) {
                                var i = t._bin,
                                    a = [];
                                n = t.CFF.readIndex(e, n, a);
                                var s = a.length;
                                r.Bias = s < 1240 ? 107 : s < 33900 ? 1131 : 32768, r.Subrs = [];
                                for (var o = 0; o < a.length - 1; o++) r.Subrs.push(i.readBytes(e, n + a[o], a[o + 1] - a[o]))
                            }, t.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], t.CFF.glyphByUnicode = function(e, t) {
                                for (var n = 0; n < e.charset.length; n++)
                                    if (e.charset[n] == t) return n;
                                return -1
                            }, t.CFF.glyphBySE = function(e, n) {
                                return n < 0 || n > 255 ? -1 : t.CFF.glyphByUnicode(e, t.CFF.tableSE[n])
                            }, t.CFF.readEncoding = function(e, n, r) {
                                t._bin;
                                var i = [".notdef"],
                                    a = e[n];
                                if (n++, 0 != a) throw "error: unknown encoding format: " + a;
                                var s = e[n];
                                n++;
                                for (var o = 0; o < s; o++) i.push(e[n + o]);
                                return i
                            }, t.CFF.readCharset = function(e, n, r) {
                                var i = t._bin,
                                    a = [".notdef"],
                                    s = e[n];
                                if (n++, 0 == s)
                                    for (var o = 0; o < r; o++) {
                                        var l = i.readUshort(e, n);
                                        n += 2, a.push(l)
                                    } else {
                                        if (1 != s && 2 != s) throw "error: format: " + s;
                                        for (; a.length < r;) {
                                            l = i.readUshort(e, n), n += 2;
                                            var u = 0;
                                            for (1 == s ? (u = e[n], n++) : (u = i.readUshort(e, n), n += 2), o = 0; o <= u; o++) a.push(l), l++
                                        }
                                    }
                                return a
                            }, t.CFF.readIndex = function(e, n, r) {
                                var i = t._bin,
                                    a = i.readUshort(e, n) + 1,
                                    s = e[n += 2];
                                if (n++, 1 == s)
                                    for (var o = 0; o < a; o++) r.push(e[n + o]);
                                else if (2 == s)
                                    for (o = 0; o < a; o++) r.push(i.readUshort(e, n + 2 * o));
                                else if (3 == s)
                                    for (o = 0; o < a; o++) r.push(16777215 & i.readUint(e, n + 3 * o - 1));
                                else if (1 != a) throw "unsupported offset size: " + s + ", count: " + a;
                                return (n += a * s) - 1
                            }, t.CFF.getCharString = function(e, n, r) {
                                var i = t._bin,
                                    a = e[n],
                                    s = e[n + 1];
                                e[n + 2], e[n + 3], e[n + 4];
                                var o = 1,
                                    l = null,
                                    u = null;
                                a <= 20 && (l = a, o = 1), 12 == a && (l = 100 * a + s, o = 2), 21 <= a && a <= 27 && (l = a, o = 1), 28 == a && (u = i.readShort(e, n + 1), o = 3), 29 <= a && a <= 31 && (l = a, o = 1), 32 <= a && a <= 246 && (u = a - 139, o = 1), 247 <= a && a <= 250 && (u = 256 * (a - 247) + s + 108, o = 2), 251 <= a && a <= 254 && (u = -(256 * (a - 251)) - s - 108, o = 2), 255 == a && (u = i.readInt(e, n + 1) / 65535, o = 5), r.val = null != u ? u : "o" + l, r.size = o
                            }, t.CFF.readCharString = function(e, n, r) {
                                for (var i = n + r, a = t._bin, s = []; n < i;) {
                                    var o = e[n],
                                        l = e[n + 1];
                                    e[n + 2], e[n + 3], e[n + 4];
                                    var u = 1,
                                        c = null,
                                        h = null;
                                    o <= 20 && (c = o, u = 1), 12 == o && (c = 100 * o + l, u = 2), 19 != o && 20 != o || (c = o, u = 2), 21 <= o && o <= 27 && (c = o, u = 1), 28 == o && (h = a.readShort(e, n + 1), u = 3), 29 <= o && o <= 31 && (c = o, u = 1), 32 <= o && o <= 246 && (h = o - 139, u = 1), 247 <= o && o <= 250 && (h = 256 * (o - 247) + l + 108, u = 2), 251 <= o && o <= 254 && (h = -(256 * (o - 251)) - l - 108, u = 2), 255 == o && (h = a.readInt(e, n + 1) / 65535, u = 5), s.push(null != h ? h : "o" + c), n += u
                                }
                                return s
                            }, t.CFF.readDict = function(e, n, r) {
                                for (var i = t._bin, a = {}, s = []; n < r;) {
                                    var o = e[n],
                                        l = e[n + 1];
                                    e[n + 2], e[n + 3], e[n + 4];
                                    var u = 1,
                                        c = null,
                                        h = null;
                                    if (28 == o && (h = i.readShort(e, n + 1), u = 3), 29 == o && (h = i.readInt(e, n + 1), u = 5), 32 <= o && o <= 246 && (h = o - 139, u = 1), 247 <= o && o <= 250 && (h = 256 * (o - 247) + l + 108, u = 2), 251 <= o && o <= 254 && (h = -(256 * (o - 251)) - l - 108, u = 2), 255 == o) throw h = i.readInt(e, n + 1) / 65535, u = 5, "unknown number";
                                    if (30 == o) {
                                        var d = [];
                                        for (u = 1;;) {
                                            var f = e[n + u];
                                            u++;
                                            var p = f >> 4,
                                                m = 15 & f;
                                            if (15 != p && d.push(p), 15 != m && d.push(m), 15 == m) break
                                        }
                                        for (var g = "", v = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], _ = 0; _ < d.length; _++) g += v[d[_]];
                                        h = parseFloat(g)
                                    }
                                    o <= 21 && (c = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][o], u = 1, 12 == o && (c = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][l], u = 2)), null != c ? (a[c] = 1 == s.length ? s[0] : s, s = []) : s.push(h), n += u
                                }
                                return a
                            }, t.cmap = {}, t.cmap.parse = function(e, n, r) {
                                e = new Uint8Array(e.buffer, n, r), n = 0;
                                var i = t._bin,
                                    a = {};
                                i.readUshort(e, n), n += 2;
                                var s = i.readUshort(e, n);
                                n += 2;
                                var o = [];
                                a.tables = [];
                                for (var l = 0; l < s; l++) {
                                    var u = i.readUshort(e, n);
                                    n += 2;
                                    var c = i.readUshort(e, n);
                                    n += 2;
                                    var h = i.readUint(e, n);
                                    n += 4;
                                    var d = "p" + u + "e" + c,
                                        f = o.indexOf(h);
                                    if (-1 == f) {
                                        f = a.tables.length, o.push(h);
                                        var p, m = i.readUshort(e, h);
                                        0 == m ? p = t.cmap.parse0(e, h) : 4 == m ? p = t.cmap.parse4(e, h) : 6 == m ? p = t.cmap.parse6(e, h) : 12 == m ? p = t.cmap.parse12(e, h) : console.debug("unknown format: " + m, u, c, h), a.tables.push(p)
                                    }
                                    if (null != a[d]) throw "multiple tables for one platform+encoding";
                                    a[d] = f
                                }
                                return a
                            }, t.cmap.parse0 = function(e, n) {
                                var r = t._bin,
                                    i = {};
                                i.format = r.readUshort(e, n), n += 2;
                                var a = r.readUshort(e, n);
                                n += 2, r.readUshort(e, n), n += 2, i.map = [];
                                for (var s = 0; s < a - 6; s++) i.map.push(e[n + s]);
                                return i
                            }, t.cmap.parse4 = function(e, n) {
                                var r = t._bin,
                                    i = n,
                                    a = {};
                                a.format = r.readUshort(e, n), n += 2;
                                var s = r.readUshort(e, n);
                                n += 2, r.readUshort(e, n), n += 2;
                                var o = r.readUshort(e, n);
                                n += 2;
                                var l = o / 2;
                                a.searchRange = r.readUshort(e, n), n += 2, a.entrySelector = r.readUshort(e, n), n += 2, a.rangeShift = r.readUshort(e, n), n += 2, a.endCount = r.readUshorts(e, n, l), n += 2 * l + 2, a.startCount = r.readUshorts(e, n, l), n += 2 * l, a.idDelta = [];
                                for (var u = 0; u < l; u++) a.idDelta.push(r.readShort(e, n)), n += 2;
                                for (a.idRangeOffset = r.readUshorts(e, n, l), n += 2 * l, a.glyphIdArray = []; n < i + s;) a.glyphIdArray.push(r.readUshort(e, n)), n += 2;
                                return a
                            }, t.cmap.parse6 = function(e, n) {
                                var r = t._bin,
                                    i = {};
                                i.format = r.readUshort(e, n), n += 2, r.readUshort(e, n), n += 2, r.readUshort(e, n), n += 2, i.firstCode = r.readUshort(e, n), n += 2;
                                var a = r.readUshort(e, n);
                                n += 2, i.glyphIdArray = [];
                                for (var s = 0; s < a; s++) i.glyphIdArray.push(r.readUshort(e, n)), n += 2;
                                return i
                            }, t.cmap.parse12 = function(e, n) {
                                var r = t._bin,
                                    i = {};
                                i.format = r.readUshort(e, n), n += 4, r.readUint(e, n), n += 4, r.readUint(e, n), n += 4;
                                var a = r.readUint(e, n);
                                n += 4, i.groups = [];
                                for (var s = 0; s < a; s++) {
                                    var o = n + 12 * s,
                                        l = r.readUint(e, o + 0),
                                        u = r.readUint(e, o + 4),
                                        c = r.readUint(e, o + 8);
                                    i.groups.push([l, u, c])
                                }
                                return i
                            }, t.glyf = {}, t.glyf.parse = function(e, t, n, r) {
                                for (var i = [], a = 0; a < r.maxp.numGlyphs; a++) i.push(null);
                                return i
                            }, t.glyf._parseGlyf = function(e, n) {
                                var r, i = t._bin,
                                    a = e._data,
                                    s = t._tabOffset(a, "glyf", e._offset) + e.loca[n];
                                if (e.loca[n] == e.loca[n + 1]) return null;
                                var o = {};
                                if (o.noc = i.readShort(a, s), s += 2, o.xMin = i.readShort(a, s), s += 2, o.yMin = i.readShort(a, s), s += 2, o.xMax = i.readShort(a, s), s += 2, o.yMax = i.readShort(a, s), s += 2, o.xMin >= o.xMax || o.yMin >= o.yMax) return null;
                                if (o.noc > 0) {
                                    o.endPts = [];
                                    for (var l = 0; l < o.noc; l++) o.endPts.push(i.readUshort(a, s)), s += 2;
                                    var u = i.readUshort(a, s);
                                    if (s += 2, a.length - s < u) return null;
                                    o.instructions = i.readBytes(a, s, u), s += u;
                                    var c = o.endPts[o.noc - 1] + 1;
                                    for (l = 0, o.flags = []; l < c; l++) {
                                        var h = a[s];
                                        if (s++, o.flags.push(h), 0 != (8 & h)) {
                                            var d = a[s];
                                            s++;
                                            for (var f = 0; f < d; f++) o.flags.push(h), l++
                                        }
                                    }
                                    for (l = 0, o.xs = []; l < c; l++) {
                                        var p = 0 != (2 & o.flags[l]),
                                            m = 0 != (16 & o.flags[l]);
                                        p ? (o.xs.push(m ? a[s] : -a[s]), s++) : m ? o.xs.push(0) : (o.xs.push(i.readShort(a, s)), s += 2)
                                    }
                                    for (l = 0, o.ys = []; l < c; l++) p = 0 != (4 & o.flags[l]), m = 0 != (32 & o.flags[l]), p ? (o.ys.push(m ? a[s] : -a[s]), s++) : m ? o.ys.push(0) : (o.ys.push(i.readShort(a, s)), s += 2);
                                    var g = 0,
                                        v = 0;
                                    for (l = 0; l < c; l++) g += o.xs[l], v += o.ys[l], o.xs[l] = g, o.ys[l] = v
                                } else {
                                    o.parts = [];
                                    do {
                                        r = i.readUshort(a, s), s += 2;
                                        var _ = {
                                            m: {
                                                a: 1,
                                                b: 0,
                                                c: 0,
                                                d: 1,
                                                tx: 0,
                                                ty: 0
                                            },
                                            p1: -1,
                                            p2: -1
                                        };
                                        if (o.parts.push(_), _.glyphIndex = i.readUshort(a, s), s += 2, 1 & r) {
                                            var y = i.readShort(a, s);
                                            s += 2;
                                            var x = i.readShort(a, s);
                                            s += 2
                                        } else y = i.readInt8(a, s), s++, x = i.readInt8(a, s), s++;
                                        2 & r ? (_.m.tx = y, _.m.ty = x) : (_.p1 = y, _.p2 = x), 8 & r ? (_.m.a = _.m.d = i.readF2dot14(a, s), s += 2) : 64 & r ? (_.m.a = i.readF2dot14(a, s), s += 2, _.m.d = i.readF2dot14(a, s), s += 2) : 128 & r && (_.m.a = i.readF2dot14(a, s), s += 2, _.m.b = i.readF2dot14(a, s), s += 2, _.m.c = i.readF2dot14(a, s), s += 2, _.m.d = i.readF2dot14(a, s), s += 2)
                                    } while (32 & r);
                                    if (256 & r) {
                                        var b = i.readUshort(a, s);
                                        for (s += 2, o.instr = [], l = 0; l < b; l++) o.instr.push(a[s]), s++
                                    }
                                }
                                return o
                            }, t.GPOS = {}, t.GPOS.parse = function(e, n, r, i) {
                                return t._lctf.parse(e, n, r, i, t.GPOS.subt)
                            }, t.GPOS.subt = function(e, n, r, i) {
                                var a = t._bin,
                                    s = r,
                                    o = {};
                                if (o.fmt = a.readUshort(e, r), r += 2, 1 == n || 2 == n || 3 == n || 7 == n || 8 == n && o.fmt <= 2) {
                                    var l = a.readUshort(e, r);
                                    r += 2, o.coverage = t._lctf.readCoverage(e, l + s)
                                }
                                if (1 == n && 1 == o.fmt) {
                                    var u = a.readUshort(e, r);
                                    r += 2;
                                    var c = t._lctf.numOfOnes(u);
                                    0 != u && (o.pos = t.GPOS.readValueRecord(e, r, u))
                                } else if (2 == n && o.fmt >= 1 && o.fmt <= 2) {
                                    u = a.readUshort(e, r), r += 2;
                                    var h = a.readUshort(e, r);
                                    r += 2, c = t._lctf.numOfOnes(u);
                                    var d = t._lctf.numOfOnes(h);
                                    if (1 == o.fmt) {
                                        o.pairsets = [];
                                        var f = a.readUshort(e, r);
                                        r += 2;
                                        for (var p = 0; p < f; p++) {
                                            var m = s + a.readUshort(e, r);
                                            r += 2;
                                            var g = a.readUshort(e, m);
                                            m += 2;
                                            for (var v = [], _ = 0; _ < g; _++) {
                                                var y = a.readUshort(e, m);
                                                m += 2, 0 != u && (T = t.GPOS.readValueRecord(e, m, u), m += 2 * c), 0 != h && (A = t.GPOS.readValueRecord(e, m, h), m += 2 * d), v.push({
                                                    gid2: y,
                                                    val1: T,
                                                    val2: A
                                                })
                                            }
                                            o.pairsets.push(v)
                                        }
                                    }
                                    if (2 == o.fmt) {
                                        var x = a.readUshort(e, r);
                                        r += 2;
                                        var b = a.readUshort(e, r);
                                        r += 2;
                                        var w = a.readUshort(e, r);
                                        r += 2;
                                        var S = a.readUshort(e, r);
                                        for (r += 2, o.classDef1 = t._lctf.readClassDef(e, s + x), o.classDef2 = t._lctf.readClassDef(e, s + b), o.matrix = [], p = 0; p < w; p++) {
                                            var M = [];
                                            for (_ = 0; _ < S; _++) {
                                                var T = null,
                                                    A = null;
                                                0 != u && (T = t.GPOS.readValueRecord(e, r, u), r += 2 * c), 0 != h && (A = t.GPOS.readValueRecord(e, r, h), r += 2 * d), M.push({
                                                    val1: T,
                                                    val2: A
                                                })
                                            }
                                            o.matrix.push(M)
                                        }
                                    }
                                } else {
                                    if (9 == n && 1 == o.fmt) {
                                        var E = a.readUshort(e, r);
                                        r += 2;
                                        var C = a.readUint(e, r);
                                        if (r += 4, 9 == i.ltype) i.ltype = E;
                                        else if (i.ltype != E) throw "invalid extension substitution";
                                        return t.GPOS.subt(e, i.ltype, s + C)
                                    }
                                    console.debug("unsupported GPOS table LookupType", n, "format", o.fmt)
                                }
                                return o
                            }, t.GPOS.readValueRecord = function(e, n, r) {
                                var i = t._bin,
                                    a = [];
                                return a.push(1 & r ? i.readShort(e, n) : 0), n += 1 & r ? 2 : 0, a.push(2 & r ? i.readShort(e, n) : 0), n += 2 & r ? 2 : 0, a.push(4 & r ? i.readShort(e, n) : 0), n += 4 & r ? 2 : 0, a.push(8 & r ? i.readShort(e, n) : 0), n += 8 & r ? 2 : 0, a
                            }, t.GSUB = {}, t.GSUB.parse = function(e, n, r, i) {
                                return t._lctf.parse(e, n, r, i, t.GSUB.subt)
                            }, t.GSUB.subt = function(e, n, r, i) {
                                var a = t._bin,
                                    s = r,
                                    o = {};
                                if (o.fmt = a.readUshort(e, r), r += 2, 1 != n && 4 != n && 5 != n && 6 != n) return null;
                                if (1 == n || 4 == n || 5 == n && o.fmt <= 2 || 6 == n && o.fmt <= 2) {
                                    var l = a.readUshort(e, r);
                                    r += 2, o.coverage = t._lctf.readCoverage(e, s + l)
                                }
                                if (1 == n && o.fmt >= 1 && o.fmt <= 2) {
                                    if (1 == o.fmt) o.delta = a.readShort(e, r), r += 2;
                                    else if (2 == o.fmt) {
                                        var u = a.readUshort(e, r);
                                        r += 2, o.newg = a.readUshorts(e, r, u), r += 2 * o.newg.length
                                    }
                                } else if (4 == n) {
                                    o.vals = [], u = a.readUshort(e, r), r += 2;
                                    for (var c = 0; c < u; c++) {
                                        var h = a.readUshort(e, r);
                                        r += 2, o.vals.push(t.GSUB.readLigatureSet(e, s + h))
                                    }
                                } else if (5 == n && 2 == o.fmt) {
                                    if (2 == o.fmt) {
                                        var d = a.readUshort(e, r);
                                        r += 2, o.cDef = t._lctf.readClassDef(e, s + d), o.scset = [];
                                        var f = a.readUshort(e, r);
                                        for (r += 2, c = 0; c < f; c++) {
                                            var p = a.readUshort(e, r);
                                            r += 2, o.scset.push(0 == p ? null : t.GSUB.readSubClassSet(e, s + p))
                                        }
                                    }
                                } else if (6 == n && 3 == o.fmt) {
                                    if (3 == o.fmt) {
                                        for (c = 0; c < 3; c++) {
                                            u = a.readUshort(e, r), r += 2;
                                            for (var m = [], g = 0; g < u; g++) m.push(t._lctf.readCoverage(e, s + a.readUshort(e, r + 2 * g)));
                                            r += 2 * u, 0 == c && (o.backCvg = m), 1 == c && (o.inptCvg = m), 2 == c && (o.ahedCvg = m)
                                        }
                                        u = a.readUshort(e, r), r += 2, o.lookupRec = t.GSUB.readSubstLookupRecords(e, r, u)
                                    }
                                } else {
                                    if (7 == n && 1 == o.fmt) {
                                        var v = a.readUshort(e, r);
                                        r += 2;
                                        var _ = a.readUint(e, r);
                                        if (r += 4, 9 == i.ltype) i.ltype = v;
                                        else if (i.ltype != v) throw "invalid extension substitution";
                                        return t.GSUB.subt(e, i.ltype, s + _)
                                    }
                                    console.debug("unsupported GSUB table LookupType", n, "format", o.fmt)
                                }
                                return o
                            }, t.GSUB.readSubClassSet = function(e, n) {
                                var r = t._bin.readUshort,
                                    i = n,
                                    a = [],
                                    s = r(e, n);
                                n += 2;
                                for (var o = 0; o < s; o++) {
                                    var l = r(e, n);
                                    n += 2, a.push(t.GSUB.readSubClassRule(e, i + l))
                                }
                                return a
                            }, t.GSUB.readSubClassRule = function(e, n) {
                                var r = t._bin.readUshort,
                                    i = {},
                                    a = r(e, n),
                                    s = r(e, n += 2);
                                n += 2, i.input = [];
                                for (var o = 0; o < a - 1; o++) i.input.push(r(e, n)), n += 2;
                                return i.substLookupRecords = t.GSUB.readSubstLookupRecords(e, n, s), i
                            }, t.GSUB.readSubstLookupRecords = function(e, n, r) {
                                for (var i = t._bin.readUshort, a = [], s = 0; s < r; s++) a.push(i(e, n), i(e, n + 2)), n += 4;
                                return a
                            }, t.GSUB.readChainSubClassSet = function(e, n) {
                                var r = t._bin,
                                    i = n,
                                    a = [],
                                    s = r.readUshort(e, n);
                                n += 2;
                                for (var o = 0; o < s; o++) {
                                    var l = r.readUshort(e, n);
                                    n += 2, a.push(t.GSUB.readChainSubClassRule(e, i + l))
                                }
                                return a
                            }, t.GSUB.readChainSubClassRule = function(e, n) {
                                for (var r = t._bin, i = {}, a = ["backtrack", "input", "lookahead"], s = 0; s < a.length; s++) {
                                    var o = r.readUshort(e, n);
                                    n += 2, 1 == s && o--, i[a[s]] = r.readUshorts(e, n, o), n += 2 * i[a[s]].length
                                }
                                return o = r.readUshort(e, n), n += 2, i.subst = r.readUshorts(e, n, 2 * o), n += 2 * i.subst.length, i
                            }, t.GSUB.readLigatureSet = function(e, n) {
                                var r = t._bin,
                                    i = n,
                                    a = [],
                                    s = r.readUshort(e, n);
                                n += 2;
                                for (var o = 0; o < s; o++) {
                                    var l = r.readUshort(e, n);
                                    n += 2, a.push(t.GSUB.readLigature(e, i + l))
                                }
                                return a
                            }, t.GSUB.readLigature = function(e, n) {
                                var r = t._bin,
                                    i = {
                                        chain: []
                                    };
                                i.nglyph = r.readUshort(e, n), n += 2;
                                var a = r.readUshort(e, n);
                                n += 2;
                                for (var s = 0; s < a - 1; s++) i.chain.push(r.readUshort(e, n)), n += 2;
                                return i
                            }, t.head = {}, t.head.parse = function(e, n, r) {
                                var i = t._bin,
                                    a = {};
                                return i.readFixed(e, n), n += 4, a.fontRevision = i.readFixed(e, n), n += 4, i.readUint(e, n), n += 4, i.readUint(e, n), n += 4, a.flags = i.readUshort(e, n), n += 2, a.unitsPerEm = i.readUshort(e, n), n += 2, a.created = i.readUint64(e, n), n += 8, a.modified = i.readUint64(e, n), n += 8, a.xMin = i.readShort(e, n), n += 2, a.yMin = i.readShort(e, n), n += 2, a.xMax = i.readShort(e, n), n += 2, a.yMax = i.readShort(e, n), n += 2, a.macStyle = i.readUshort(e, n), n += 2, a.lowestRecPPEM = i.readUshort(e, n), n += 2, a.fontDirectionHint = i.readShort(e, n), n += 2, a.indexToLocFormat = i.readShort(e, n), n += 2, a.glyphDataFormat = i.readShort(e, n), n += 2, a
                            }, t.hhea = {}, t.hhea.parse = function(e, n, r) {
                                var i = t._bin,
                                    a = {};
                                return i.readFixed(e, n), n += 4, a.ascender = i.readShort(e, n), n += 2, a.descender = i.readShort(e, n), n += 2, a.lineGap = i.readShort(e, n), n += 2, a.advanceWidthMax = i.readUshort(e, n), n += 2, a.minLeftSideBearing = i.readShort(e, n), n += 2, a.minRightSideBearing = i.readShort(e, n), n += 2, a.xMaxExtent = i.readShort(e, n), n += 2, a.caretSlopeRise = i.readShort(e, n), n += 2, a.caretSlopeRun = i.readShort(e, n), n += 2, a.caretOffset = i.readShort(e, n), n += 10, a.metricDataFormat = i.readShort(e, n), n += 2, a.numberOfHMetrics = i.readUshort(e, n), n += 2, a
                            }, t.hmtx = {}, t.hmtx.parse = function(e, n, r, i) {
                                for (var a = t._bin, s = {
                                        aWidth: [],
                                        lsBearing: []
                                    }, o = 0, l = 0, u = 0; u < i.maxp.numGlyphs; u++) u < i.hhea.numberOfHMetrics && (o = a.readUshort(e, n), n += 2, l = a.readShort(e, n), n += 2), s.aWidth.push(o), s.lsBearing.push(l);
                                return s
                            }, t.kern = {}, t.kern.parse = function(e, n, r, i) {
                                var a = t._bin,
                                    s = a.readUshort(e, n);
                                if (n += 2, 1 == s) return t.kern.parseV1(e, n - 2, r, i);
                                var o = a.readUshort(e, n);
                                n += 2;
                                for (var l = {
                                        glyph1: [],
                                        rval: []
                                    }, u = 0; u < o; u++) {
                                    n += 2, r = a.readUshort(e, n), n += 2;
                                    var c = a.readUshort(e, n);
                                    n += 2;
                                    var h = c >>> 8;
                                    if (0 != (h &= 15)) throw "unknown kern table format: " + h;
                                    n = t.kern.readFormat0(e, n, l)
                                }
                                return l
                            }, t.kern.parseV1 = function(e, n, r, i) {
                                var a = t._bin;
                                a.readFixed(e, n), n += 4;
                                var s = a.readUint(e, n);
                                n += 4;
                                for (var o = {
                                        glyph1: [],
                                        rval: []
                                    }, l = 0; l < s; l++) {
                                    a.readUint(e, n), n += 4;
                                    var u = a.readUshort(e, n);
                                    n += 2, a.readUshort(e, n), n += 2;
                                    var c = u >>> 8;
                                    if (0 != (c &= 15)) throw "unknown kern table format: " + c;
                                    n = t.kern.readFormat0(e, n, o)
                                }
                                return o
                            }, t.kern.readFormat0 = function(e, n, r) {
                                var i = t._bin,
                                    a = -1,
                                    s = i.readUshort(e, n);
                                n += 2, i.readUshort(e, n), n += 2, i.readUshort(e, n), n += 2, i.readUshort(e, n), n += 2;
                                for (var o = 0; o < s; o++) {
                                    var l = i.readUshort(e, n);
                                    n += 2;
                                    var u = i.readUshort(e, n);
                                    n += 2;
                                    var c = i.readShort(e, n);
                                    n += 2, l != a && (r.glyph1.push(l), r.rval.push({
                                        glyph2: [],
                                        vals: []
                                    }));
                                    var h = r.rval[r.rval.length - 1];
                                    h.glyph2.push(u), h.vals.push(c), a = l
                                }
                                return n
                            }, t.loca = {}, t.loca.parse = function(e, n, r, i) {
                                var a = t._bin,
                                    s = [],
                                    o = i.head.indexToLocFormat,
                                    l = i.maxp.numGlyphs + 1;
                                if (0 == o)
                                    for (var u = 0; u < l; u++) s.push(a.readUshort(e, n + (u << 1)) << 1);
                                if (1 == o)
                                    for (u = 0; u < l; u++) s.push(a.readUint(e, n + (u << 2)));
                                return s
                            }, t.maxp = {}, t.maxp.parse = function(e, n, r) {
                                var i = t._bin,
                                    a = {},
                                    s = i.readUint(e, n);
                                return n += 4, a.numGlyphs = i.readUshort(e, n), n += 2, 65536 == s && (a.maxPoints = i.readUshort(e, n), n += 2, a.maxContours = i.readUshort(e, n), n += 2, a.maxCompositePoints = i.readUshort(e, n), n += 2, a.maxCompositeContours = i.readUshort(e, n), n += 2, a.maxZones = i.readUshort(e, n), n += 2, a.maxTwilightPoints = i.readUshort(e, n), n += 2, a.maxStorage = i.readUshort(e, n), n += 2, a.maxFunctionDefs = i.readUshort(e, n), n += 2, a.maxInstructionDefs = i.readUshort(e, n), n += 2, a.maxStackElements = i.readUshort(e, n), n += 2, a.maxSizeOfInstructions = i.readUshort(e, n), n += 2, a.maxComponentElements = i.readUshort(e, n), n += 2, a.maxComponentDepth = i.readUshort(e, n), n += 2), a
                            }, t.name = {}, t.name.parse = function(e, n, r) {
                                var i = t._bin,
                                    a = {};
                                i.readUshort(e, n), n += 2;
                                var s = i.readUshort(e, n);
                                n += 2, i.readUshort(e, n);
                                for (var o, l = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], u = n += 2, c = 0; c < s; c++) {
                                    var h = i.readUshort(e, n);
                                    n += 2;
                                    var d = i.readUshort(e, n);
                                    n += 2;
                                    var f = i.readUshort(e, n);
                                    n += 2;
                                    var p = i.readUshort(e, n);
                                    n += 2;
                                    var m = i.readUshort(e, n);
                                    n += 2;
                                    var g = i.readUshort(e, n);
                                    n += 2;
                                    var v, _ = l[p],
                                        y = u + 12 * s + g;
                                    if (0 == h) v = i.readUnicode(e, y, m / 2);
                                    else if (3 == h && 0 == d) v = i.readUnicode(e, y, m / 2);
                                    else if (0 == d) v = i.readASCII(e, y, m);
                                    else if (1 == d) v = i.readUnicode(e, y, m / 2);
                                    else if (3 == d) v = i.readUnicode(e, y, m / 2);
                                    else {
                                        if (1 != h) throw "unknown encoding " + d + ", platformID: " + h;
                                        v = i.readASCII(e, y, m), console.debug("reading unknown MAC encoding " + d + " as ASCII")
                                    }
                                    var x = "p" + h + "," + f.toString(16);
                                    null == a[x] && (a[x] = {}), a[x][void 0 !== _ ? _ : p] = v, a[x]._lang = f
                                }
                                for (var b in a)
                                    if (null != a[b].postScriptName && 1033 == a[b]._lang) return a[b];
                                for (var b in a)
                                    if (null != a[b].postScriptName && 0 == a[b]._lang) return a[b];
                                for (var b in a)
                                    if (null != a[b].postScriptName && 3084 == a[b]._lang) return a[b];
                                for (var b in a)
                                    if (null != a[b].postScriptName) return a[b];
                                for (var b in a) {
                                    o = b;
                                    break
                                }
                                return console.debug("returning name table with languageID " + a[o]._lang), a[o]
                            }, t["OS/2"] = {}, t["OS/2"].parse = function(e, n, r) {
                                var i = t._bin.readUshort(e, n);
                                n += 2;
                                var a = {};
                                if (0 == i) t["OS/2"].version0(e, n, a);
                                else if (1 == i) t["OS/2"].version1(e, n, a);
                                else if (2 == i || 3 == i || 4 == i) t["OS/2"].version2(e, n, a);
                                else {
                                    if (5 != i) throw "unknown OS/2 table version: " + i;
                                    t["OS/2"].version5(e, n, a)
                                }
                                return a
                            }, t["OS/2"].version0 = function(e, n, r) {
                                var i = t._bin;
                                return r.xAvgCharWidth = i.readShort(e, n), n += 2, r.usWeightClass = i.readUshort(e, n), n += 2, r.usWidthClass = i.readUshort(e, n), n += 2, r.fsType = i.readUshort(e, n), n += 2, r.ySubscriptXSize = i.readShort(e, n), n += 2, r.ySubscriptYSize = i.readShort(e, n), n += 2, r.ySubscriptXOffset = i.readShort(e, n), n += 2, r.ySubscriptYOffset = i.readShort(e, n), n += 2, r.ySuperscriptXSize = i.readShort(e, n), n += 2, r.ySuperscriptYSize = i.readShort(e, n), n += 2, r.ySuperscriptXOffset = i.readShort(e, n), n += 2, r.ySuperscriptYOffset = i.readShort(e, n), n += 2, r.yStrikeoutSize = i.readShort(e, n), n += 2, r.yStrikeoutPosition = i.readShort(e, n), n += 2, r.sFamilyClass = i.readShort(e, n), n += 2, r.panose = i.readBytes(e, n, 10), n += 10, r.ulUnicodeRange1 = i.readUint(e, n), n += 4, r.ulUnicodeRange2 = i.readUint(e, n), n += 4, r.ulUnicodeRange3 = i.readUint(e, n), n += 4, r.ulUnicodeRange4 = i.readUint(e, n), n += 4, r.achVendID = [i.readInt8(e, n), i.readInt8(e, n + 1), i.readInt8(e, n + 2), i.readInt8(e, n + 3)], n += 4, r.fsSelection = i.readUshort(e, n), n += 2, r.usFirstCharIndex = i.readUshort(e, n), n += 2, r.usLastCharIndex = i.readUshort(e, n), n += 2, r.sTypoAscender = i.readShort(e, n), n += 2, r.sTypoDescender = i.readShort(e, n), n += 2, r.sTypoLineGap = i.readShort(e, n), n += 2, r.usWinAscent = i.readUshort(e, n), n += 2, r.usWinDescent = i.readUshort(e, n), n += 2
                            }, t["OS/2"].version1 = function(e, n, r) {
                                var i = t._bin;
                                return n = t["OS/2"].version0(e, n, r), r.ulCodePageRange1 = i.readUint(e, n), n += 4, r.ulCodePageRange2 = i.readUint(e, n), n += 4
                            }, t["OS/2"].version2 = function(e, n, r) {
                                var i = t._bin;
                                return n = t["OS/2"].version1(e, n, r), r.sxHeight = i.readShort(e, n), n += 2, r.sCapHeight = i.readShort(e, n), n += 2, r.usDefault = i.readUshort(e, n), n += 2, r.usBreak = i.readUshort(e, n), n += 2, r.usMaxContext = i.readUshort(e, n), n += 2
                            }, t["OS/2"].version5 = function(e, n, r) {
                                var i = t._bin;
                                return n = t["OS/2"].version2(e, n, r), r.usLowerOpticalPointSize = i.readUshort(e, n), n += 2, r.usUpperOpticalPointSize = i.readUshort(e, n), n += 2
                            }, t.post = {}, t.post.parse = function(e, n, r) {
                                var i = t._bin,
                                    a = {};
                                return a.version = i.readFixed(e, n), n += 4, a.italicAngle = i.readFixed(e, n), n += 4, a.underlinePosition = i.readShort(e, n), n += 2, a.underlineThickness = i.readShort(e, n), n += 2, a
                            }, null == t && (t = {}), null == t.U && (t.U = {}), t.U.codeToGlyph = function(e, t) {
                                var n = e.cmap,
                                    r = -1;
                                if (null != n.p0e4 ? r = n.p0e4 : null != n.p3e1 ? r = n.p3e1 : null != n.p1e0 ? r = n.p1e0 : null != n.p0e3 && (r = n.p0e3), -1 == r) throw "no familiar platform and encoding!";
                                var i = n.tables[r];
                                if (0 == i.format) return t >= i.map.length ? 0 : i.map[t];
                                if (4 == i.format) {
                                    for (var a = -1, s = 0; s < i.endCount.length; s++)
                                        if (t <= i.endCount[s]) {
                                            a = s;
                                            break
                                        }
                                    return -1 == a || i.startCount[a] > t ? 0 : 65535 & (0 != i.idRangeOffset[a] ? i.glyphIdArray[t - i.startCount[a] + (i.idRangeOffset[a] >> 1) - (i.idRangeOffset.length - a)] : t + i.idDelta[a])
                                }
                                if (12 == i.format) {
                                    if (t > i.groups[i.groups.length - 1][1]) return 0;
                                    for (s = 0; s < i.groups.length; s++) {
                                        var o = i.groups[s];
                                        if (o[0] <= t && t <= o[1]) return o[2] + (t - o[0])
                                    }
                                    return 0
                                }
                                throw "unknown cmap table format " + i.format
                            }, t.U.glyphToPath = function(e, n) {
                                var r = {
                                    cmds: [],
                                    crds: []
                                };
                                if (e.SVG && e.SVG.entries[n]) {
                                    var i = e.SVG.entries[n];
                                    return null == i ? r : ("string" == typeof i && (i = t.SVG.toPath(i), e.SVG.entries[n] = i), i)
                                }
                                if (e.CFF) {
                                    var a = {
                                            x: 0,
                                            y: 0,
                                            stack: [],
                                            nStems: 0,
                                            haveWidth: !1,
                                            width: e.CFF.Private ? e.CFF.Private.defaultWidthX : 0,
                                            open: !1
                                        },
                                        s = e.CFF,
                                        o = e.CFF.Private;
                                    if (s.ROS) {
                                        for (var l = 0; s.FDSelect[l + 2] <= n;) l += 2;
                                        o = s.FDArray[s.FDSelect[l + 1]].Private
                                    }
                                    t.U._drawCFF(e.CFF.CharStrings[n], a, s, o, r)
                                } else e.glyf && t.U._drawGlyf(n, e, r);
                                return r
                            }, t.U._drawGlyf = function(e, n, r) {
                                var i = n.glyf[e];
                                null == i && (i = n.glyf[e] = t.glyf._parseGlyf(n, e)), null != i && (i.noc > -1 ? t.U._simpleGlyph(i, r) : t.U._compoGlyph(i, n, r))
                            }, t.U._simpleGlyph = function(e, n) {
                                for (var r = 0; r < e.noc; r++) {
                                    for (var i = 0 == r ? 0 : e.endPts[r - 1] + 1, a = e.endPts[r], s = i; s <= a; s++) {
                                        var o = s == i ? a : s - 1,
                                            l = s == a ? i : s + 1,
                                            u = 1 & e.flags[s],
                                            c = 1 & e.flags[o],
                                            h = 1 & e.flags[l],
                                            d = e.xs[s],
                                            f = e.ys[s];
                                        if (s == i) {
                                            if (u) {
                                                if (!c) {
                                                    t.U.P.moveTo(n, d, f);
                                                    continue
                                                }
                                                t.U.P.moveTo(n, e.xs[o], e.ys[o])
                                            } else c ? t.U.P.moveTo(n, e.xs[o], e.ys[o]) : t.U.P.moveTo(n, (e.xs[o] + d) / 2, (e.ys[o] + f) / 2)
                                        }
                                        u ? c && t.U.P.lineTo(n, d, f) : h ? t.U.P.qcurveTo(n, d, f, e.xs[l], e.ys[l]) : t.U.P.qcurveTo(n, d, f, (d + e.xs[l]) / 2, (f + e.ys[l]) / 2)
                                    }
                                    t.U.P.closePath(n)
                                }
                            }, t.U._compoGlyph = function(e, n, r) {
                                for (var i = 0; i < e.parts.length; i++) {
                                    var a = {
                                            cmds: [],
                                            crds: []
                                        },
                                        s = e.parts[i];
                                    t.U._drawGlyf(s.glyphIndex, n, a);
                                    for (var o = s.m, l = 0; l < a.crds.length; l += 2) {
                                        var u = a.crds[l],
                                            c = a.crds[l + 1];
                                        r.crds.push(u * o.a + c * o.b + o.tx), r.crds.push(u * o.c + c * o.d + o.ty)
                                    }
                                    for (l = 0; l < a.cmds.length; l++) r.cmds.push(a.cmds[l])
                                }
                            }, t.U._getGlyphClass = function(e, n) {
                                var r = t._lctf.getInterval(n, e);
                                return -1 == r ? 0 : n[r + 2]
                            }, t.U.getPairAdjustment = function(e, n, r) {
                                var i = !1;
                                if (e.GPOS)
                                    for (var a = e.GPOS, s = a.lookupList, o = a.featureList, l = [], u = 0; u < o.length; u++) {
                                        var c = o[u];
                                        if ("kern" == c.tag) {
                                            i = !0;
                                            for (var h = 0; h < c.tab.length; h++)
                                                if (!l[c.tab[h]]) {
                                                    l[c.tab[h]] = !0;
                                                    for (var d = s[c.tab[h]], f = 0; f < d.tabs.length; f++)
                                                        if (null != d.tabs[f]) {
                                                            var p, m = d.tabs[f];
                                                            if (!m.coverage || -1 != (p = t._lctf.coverageIndex(m.coverage, n))) {
                                                                if (1 == d.ltype);
                                                                else if (2 == d.ltype) {
                                                                    var g = null;
                                                                    if (1 == m.fmt) {
                                                                        var v = m.pairsets[p];
                                                                        for (u = 0; u < v.length; u++) v[u].gid2 == r && (g = v[u])
                                                                    } else if (2 == m.fmt) {
                                                                        var _ = t.U._getGlyphClass(n, m.classDef1),
                                                                            y = t.U._getGlyphClass(r, m.classDef2);
                                                                        g = m.matrix[_][y]
                                                                    }
                                                                    if (g) {
                                                                        var x = 0;
                                                                        return g.val1 && g.val1[2] && (x += g.val1[2]), g.val2 && g.val2[0] && (x += g.val2[0]), x
                                                                    }
                                                                }
                                                            }
                                                        }
                                                }
                                        }
                                    }
                                if (e.kern && !i) {
                                    var b = e.kern.glyph1.indexOf(n);
                                    if (-1 != b) {
                                        var w = e.kern.rval[b].glyph2.indexOf(r);
                                        if (-1 != w) return e.kern.rval[b].vals[w]
                                    }
                                }
                                return 0
                            }, t.U._applySubs = function(e, n, r, i) {
                                for (var a = e.length - n - 1, s = 0; s < r.tabs.length; s++)
                                    if (null != r.tabs[s]) {
                                        var o, l = r.tabs[s];
                                        if (!l.coverage || -1 != (o = t._lctf.coverageIndex(l.coverage, e[n]))) {
                                            if (1 == r.ltype) e[n], 1 == l.fmt ? e[n] = e[n] + l.delta : e[n] = l.newg[o];
                                            else if (4 == r.ltype)
                                                for (var u = l.vals[o], c = 0; c < u.length; c++) {
                                                    var h = u[c],
                                                        d = h.chain.length;
                                                    if (!(d > a)) {
                                                        for (var f = !0, p = 0, m = 0; m < d; m++) {
                                                            for (; - 1 == e[n + p + (1 + m)];) p++;
                                                            h.chain[m] != e[n + p + (1 + m)] && (f = !1)
                                                        }
                                                        if (f) {
                                                            for (m = 0, e[n] = h.nglyph; m < d + p; m++) e[n + m + 1] = -1;
                                                            break
                                                        }
                                                    }
                                                } else if (5 == r.ltype && 2 == l.fmt)
                                                    for (var g = t._lctf.getInterval(l.cDef, e[n]), v = l.cDef[g + 2], _ = l.scset[v], y = 0; y < _.length; y++) {
                                                        var x = _[y],
                                                            b = x.input;
                                                        if (!(b.length > a)) {
                                                            for (f = !0, m = 0; m < b.length; m++) {
                                                                var w = t._lctf.getInterval(l.cDef, e[n + 1 + m]);
                                                                if (-1 == g && l.cDef[w + 2] != b[m]) {
                                                                    f = !1;
                                                                    break
                                                                }
                                                            }
                                                            if (f) {
                                                                var S = x.substLookupRecords;
                                                                for (c = 0; c < S.length; c += 2) S[c], S[c + 1]
                                                            }
                                                        }
                                                    } else if (6 == r.ltype && 3 == l.fmt) {
                                                        if (!t.U._glsCovered(e, l.backCvg, n - l.backCvg.length) || !t.U._glsCovered(e, l.inptCvg, n) || !t.U._glsCovered(e, l.ahedCvg, n + l.inptCvg.length)) continue;
                                                        var M = l.lookupRec;
                                                        for (y = 0; y < M.length; y += 2) {
                                                            g = M[y];
                                                            var T = i[M[y + 1]];
                                                            t.U._applySubs(e, n + g, T, i)
                                                        }
                                                    }
                                        }
                                    }
                            }, t.U._glsCovered = function(e, n, r) {
                                for (var i = 0; i < n.length; i++)
                                    if (-1 == t._lctf.coverageIndex(n[i], e[r + i])) return !1;
                                return !0
                            }, t.U.glyphsToPath = function(e, n, r) {
                                for (var i = {
                                        cmds: [],
                                        crds: []
                                    }, a = 0, s = 0; s < n.length; s++) {
                                    var o = n[s];
                                    if (-1 != o) {
                                        for (var l = s < n.length - 1 && -1 != n[s + 1] ? n[s + 1] : 0, u = t.U.glyphToPath(e, o), c = 0; c < u.crds.length; c += 2) i.crds.push(u.crds[c] + a), i.crds.push(u.crds[c + 1]);
                                        for (r && i.cmds.push(r), c = 0; c < u.cmds.length; c++) i.cmds.push(u.cmds[c]);
                                        r && i.cmds.push("X"), a += e.hmtx.aWidth[o], s < n.length - 1 && (a += t.U.getPairAdjustment(e, o, l))
                                    }
                                }
                                return i
                            }, t.U.P = {}, t.U.P.moveTo = function(e, t, n) {
                                e.cmds.push("M"), e.crds.push(t, n)
                            }, t.U.P.lineTo = function(e, t, n) {
                                e.cmds.push("L"), e.crds.push(t, n)
                            }, t.U.P.curveTo = function(e, t, n, r, i, a, s) {
                                e.cmds.push("C"), e.crds.push(t, n, r, i, a, s)
                            }, t.U.P.qcurveTo = function(e, t, n, r, i) {
                                e.cmds.push("Q"), e.crds.push(t, n, r, i)
                            }, t.U.P.closePath = function(e) {
                                e.cmds.push("Z")
                            }, t.U._drawCFF = function(e, n, r, i, a) {
                                for (var s = n.stack, o = n.nStems, l = n.haveWidth, u = n.width, c = n.open, h = 0, d = n.x, f = n.y, p = 0, m = 0, g = 0, v = 0, _ = 0, y = 0, x = 0, b = 0, w = 0, S = 0, M = {
                                        val: 0,
                                        size: 0
                                    }; h < e.length;) {
                                    t.CFF.getCharString(e, h, M);
                                    var T = M.val;
                                    if (h += M.size, "o1" == T || "o18" == T) s.length % 2 == 0 || l || (u = s.shift() + i.nominalWidthX), o += s.length >> 1, s.length = 0, l = !0;
                                    else if ("o3" == T || "o23" == T) s.length % 2 == 0 || l || (u = s.shift() + i.nominalWidthX), o += s.length >> 1, s.length = 0, l = !0;
                                    else if ("o4" == T) s.length > 1 && !l && (u = s.shift() + i.nominalWidthX, l = !0), c && t.U.P.closePath(a), f += s.pop(), t.U.P.moveTo(a, d, f), c = !0;
                                    else if ("o5" == T)
                                        for (; s.length > 0;) d += s.shift(), f += s.shift(), t.U.P.lineTo(a, d, f);
                                    else if ("o6" == T || "o7" == T)
                                        for (var A = s.length, E = "o6" == T, C = 0; C < A; C++) {
                                            var I = s.shift();
                                            E ? d += I : f += I, E = !E, t.U.P.lineTo(a, d, f)
                                        } else if ("o8" == T || "o24" == T) {
                                            A = s.length;
                                            for (var P = 0; P + 6 <= A;) p = d + s.shift(), m = f + s.shift(), g = p + s.shift(), v = m + s.shift(), d = g + s.shift(), f = v + s.shift(), t.U.P.curveTo(a, p, m, g, v, d, f), P += 6;
                                            "o24" == T && (d += s.shift(), f += s.shift(), t.U.P.lineTo(a, d, f))
                                        } else {
                                            if ("o11" == T) break;
                                            if ("o1234" == T || "o1235" == T || "o1236" == T || "o1237" == T) "o1234" == T && (m = f, g = (p = d + s.shift()) + s.shift(), S = v = m + s.shift(), y = v, b = f, d = (x = (_ = (w = g + s.shift()) + s.shift()) + s.shift()) + s.shift(), t.U.P.curveTo(a, p, m, g, v, w, S), t.U.P.curveTo(a, _, y, x, b, d, f)), "o1235" == T && (p = d + s.shift(), m = f + s.shift(), g = p + s.shift(), v = m + s.shift(), w = g + s.shift(), S = v + s.shift(), _ = w + s.shift(), y = S + s.shift(), x = _ + s.shift(), b = y + s.shift(), d = x + s.shift(), f = b + s.shift(), s.shift(), t.U.P.curveTo(a, p, m, g, v, w, S), t.U.P.curveTo(a, _, y, x, b, d, f)), "o1236" == T && (p = d + s.shift(), m = f + s.shift(), g = p + s.shift(), S = v = m + s.shift(), y = v, x = (_ = (w = g + s.shift()) + s.shift()) + s.shift(), b = y + s.shift(), d = x + s.shift(), t.U.P.curveTo(a, p, m, g, v, w, S), t.U.P.curveTo(a, _, y, x, b, d, f)), "o1237" == T && (p = d + s.shift(), m = f + s.shift(), g = p + s.shift(), v = m + s.shift(), w = g + s.shift(), S = v + s.shift(), _ = w + s.shift(), y = S + s.shift(), Math.abs((x = _ + s.shift()) - d) > Math.abs((b = y + s.shift()) - f) ? d = x + s.shift() : f = b + s.shift(), t.U.P.curveTo(a, p, m, g, v, w, S), t.U.P.curveTo(a, _, y, x, b, d, f));
                                            else if ("o14" == T) {
                                                if (s.length > 0 && !l && (u = s.shift() + r.nominalWidthX, l = !0), 4 == s.length) {
                                                    var R = s.shift(),
                                                        L = s.shift(),
                                                        D = s.shift(),
                                                        k = s.shift(),
                                                        U = t.CFF.glyphBySE(r, D),
                                                        O = t.CFF.glyphBySE(r, k);
                                                    t.U._drawCFF(r.CharStrings[U], n, r, i, a), n.x = R, n.y = L, t.U._drawCFF(r.CharStrings[O], n, r, i, a)
                                                }
                                                c && (t.U.P.closePath(a), c = !1)
                                            } else if ("o19" == T || "o20" == T) s.length % 2 == 0 || l || (u = s.shift() + i.nominalWidthX), o += s.length >> 1, s.length = 0, l = !0, h += o + 7 >> 3;
                                            else if ("o21" == T) s.length > 2 && !l && (u = s.shift() + i.nominalWidthX, l = !0), f += s.pop(), d += s.pop(), c && t.U.P.closePath(a), t.U.P.moveTo(a, d, f), c = !0;
                                            else if ("o22" == T) s.length > 1 && !l && (u = s.shift() + i.nominalWidthX, l = !0), d += s.pop(), c && t.U.P.closePath(a), t.U.P.moveTo(a, d, f), c = !0;
                                            else if ("o25" == T) {
                                                for (; s.length > 6;) d += s.shift(), f += s.shift(), t.U.P.lineTo(a, d, f);
                                                p = d + s.shift(), m = f + s.shift(), g = p + s.shift(), v = m + s.shift(), d = g + s.shift(), f = v + s.shift(), t.U.P.curveTo(a, p, m, g, v, d, f)
                                            } else if ("o26" == T)
                                                for (s.length % 2 && (d += s.shift()); s.length > 0;) p = d, m = f + s.shift(), d = g = p + s.shift(), f = (v = m + s.shift()) + s.shift(), t.U.P.curveTo(a, p, m, g, v, d, f);
                                            else if ("o27" == T)
                                                for (s.length % 2 && (f += s.shift()); s.length > 0;) m = f, g = (p = d + s.shift()) + s.shift(), v = m + s.shift(), d = g + s.shift(), f = v, t.U.P.curveTo(a, p, m, g, v, d, f);
                                            else if ("o10" == T || "o29" == T) {
                                                var F = "o10" == T ? i : r;
                                                if (0 == s.length) console.debug("error: empty stack");
                                                else {
                                                    var N = s.pop(),
                                                        B = F.Subrs[N + F.Bias];
                                                    n.x = d, n.y = f, n.nStems = o, n.haveWidth = l, n.width = u, n.open = c, t.U._drawCFF(B, n, r, i, a), d = n.x, f = n.y, o = n.nStems, l = n.haveWidth, u = n.width, c = n.open
                                                }
                                            } else if ("o30" == T || "o31" == T) {
                                                var z = s.length,
                                                    G = (P = 0, "o31" == T);
                                                for (P += z - (A = -3 & z); P < A;) G ? (m = f, g = (p = d + s.shift()) + s.shift(), f = (v = m + s.shift()) + s.shift(), A - P == 5 ? (d = g + s.shift(), P++) : d = g, G = !1) : (p = d, m = f + s.shift(), g = p + s.shift(), v = m + s.shift(), d = g + s.shift(), A - P == 5 ? (f = v + s.shift(), P++) : f = v, G = !0), t.U.P.curveTo(a, p, m, g, v, d, f), P += 4
                                            } else {
                                                if ("o" == (T + "").charAt(0)) throw console.debug("Unknown operation: " + T, e), T;
                                                s.push(T)
                                            }
                                        }
                                }
                                n.x = d, n.y = f, n.nStems = o, n.haveWidth = l, n.width = u, n.open = c
                            }, n = t, e.Typr = n, e.default = {
                                Typr: n
                            }, Object.defineProperty(e, "__esModule", {
                                value: !0
                            }), e).Typr
                        },
                        /*!
                        Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
                        (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
                        Original licenses apply: 
                        - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
                        - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
                        */
                        function() {
                            return function(e) {
                                var t = Uint8Array,
                                    n = Uint16Array,
                                    r = Uint32Array,
                                    i = new t([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
                                    a = new t([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
                                    s = new t([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                                    o = function(e, t) {
                                        for (var i = new n(31), a = 0; a < 31; ++a) i[a] = t += 1 << e[a - 1];
                                        var s = new r(i[30]);
                                        for (a = 1; a < 30; ++a)
                                            for (var o = i[a]; o < i[a + 1]; ++o) s[o] = o - i[a] << 5 | a;
                                        return [i, s]
                                    },
                                    l = o(i, 2),
                                    u = l[0],
                                    c = l[1];
                                u[28] = 258, c[258] = 28;
                                for (var h = o(a, 0)[0], d = new n(32768), f = 0; f < 32768; ++f) {
                                    var p = (43690 & f) >>> 1 | (21845 & f) << 1;
                                    p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1
                                }
                                var m = function(e, t, r) {
                                        for (var i = e.length, a = 0, s = new n(t); a < i; ++a) ++s[e[a] - 1];
                                        var o, l = new n(t);
                                        for (a = 0; a < t; ++a) l[a] = l[a - 1] + s[a - 1] << 1;
                                        if (r) {
                                            o = new n(1 << t);
                                            var u = 15 - t;
                                            for (a = 0; a < i; ++a)
                                                if (e[a])
                                                    for (var c = a << 4 | e[a], h = t - e[a], f = l[e[a] - 1]++ << h, p = f | (1 << h) - 1; f <= p; ++f) o[d[f] >>> u] = c
                                        } else
                                            for (o = new n(i), a = 0; a < i; ++a) e[a] && (o[a] = d[l[e[a] - 1]++] >>> 15 - e[a]);
                                        return o
                                    },
                                    g = new t(288);
                                for (f = 0; f < 144; ++f) g[f] = 8;
                                for (f = 144; f < 256; ++f) g[f] = 9;
                                for (f = 256; f < 280; ++f) g[f] = 7;
                                for (f = 280; f < 288; ++f) g[f] = 8;
                                var v = new t(32);
                                for (f = 0; f < 32; ++f) v[f] = 5;
                                var _ = m(g, 9, 1),
                                    y = m(v, 5, 1),
                                    x = function(e) {
                                        for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
                                        return t
                                    },
                                    b = function(e, t, n) {
                                        var r = t / 8 | 0;
                                        return (e[r] | e[r + 1] << 8) >> (7 & t) & n
                                    },
                                    w = function(e, t) {
                                        var n = t / 8 | 0;
                                        return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t)
                                    },
                                    S = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
                                    M = function(e, t, n) {
                                        var r = Error(t || S[e]);
                                        if (r.code = e, Error.captureStackTrace && Error.captureStackTrace(r, M), !n) throw r;
                                        return r
                                    },
                                    T = function(e, o, l) {
                                        var c, d, f, p, g = e.length;
                                        if (!g || l && !l.l && g < 5) return o || new t(0);
                                        var v = !o || l,
                                            S = !l || l.i;
                                        l || (l = {}), o || (o = new t(3 * g));
                                        var T, A = function(e) {
                                                var n = o.length;
                                                if (e > n) {
                                                    var r = new t(Math.max(2 * n, e));
                                                    r.set(o), o = r
                                                }
                                            },
                                            E = l.f || 0,
                                            C = l.p || 0,
                                            I = l.b || 0,
                                            P = l.l,
                                            R = l.d,
                                            L = l.m,
                                            D = l.n,
                                            k = 8 * g;
                                        do {
                                            if (!P) {
                                                l.f = E = b(e, C, 1);
                                                var U = b(e, C + 1, 3);
                                                if (C += 3, !U) {
                                                    var O = e[(X = ((T = C) / 8 | 0) + (7 & T && 1) + 4) - 4] | e[X - 3] << 8,
                                                        F = X + O;
                                                    if (F > g) {
                                                        S && M(0);
                                                        break
                                                    }
                                                    v && A(I + O), o.set(e.subarray(X, F), I), l.b = I += O, l.p = C = 8 * F;
                                                    continue
                                                }
                                                if (1 == U) P = _, R = y, L = 9, D = 5;
                                                else if (2 == U) {
                                                    var N = b(e, C, 31) + 257,
                                                        B = b(e, C + 10, 15) + 4,
                                                        z = N + b(e, C + 5, 31) + 1;
                                                    C += 14;
                                                    for (var G = new t(z), V = new t(19), W = 0; W < B; ++W) V[s[W]] = b(e, C + 3 * W, 7);
                                                    C += 3 * B;
                                                    var H = x(V),
                                                        j = (1 << H) - 1,
                                                        q = m(V, H, 1);
                                                    for (W = 0; W < z;) {
                                                        var X, Z = q[b(e, C, j)];
                                                        if (C += 15 & Z, (X = Z >>> 4) < 16) G[W++] = X;
                                                        else {
                                                            var Y = 0,
                                                                $ = 0;
                                                            for (16 == X ? ($ = 3 + b(e, C, 3), C += 2, Y = G[W - 1]) : 17 == X ? ($ = 3 + b(e, C, 7), C += 3) : 18 == X && ($ = 11 + b(e, C, 127), C += 7); $--;) G[W++] = Y
                                                        }
                                                    }
                                                    var J = G.subarray(0, N),
                                                        K = G.subarray(N);
                                                    L = x(J), D = x(K), P = m(J, L, 1), R = m(K, D, 1)
                                                } else M(1);
                                                if (C > k) {
                                                    S && M(0);
                                                    break
                                                }
                                            }
                                            v && A(I + 131072);
                                            for (var Q = (1 << L) - 1, ee = (1 << D) - 1, et = C;; et = C) {
                                                var en = (Y = P[w(e, C) & Q]) >>> 4;
                                                if ((C += 15 & Y) > k) {
                                                    S && M(0);
                                                    break
                                                }
                                                if (Y || M(2), en < 256) o[I++] = en;
                                                else {
                                                    if (256 == en) {
                                                        et = C, P = null;
                                                        break
                                                    }
                                                    var er = en - 254;
                                                    if (en > 264) {
                                                        var ei = i[W = en - 257];
                                                        er = b(e, C, (1 << ei) - 1) + u[W], C += ei
                                                    }
                                                    var ea = R[w(e, C) & ee],
                                                        es = ea >>> 4;
                                                    if (ea || M(3), C += 15 & ea, K = h[es], es > 3 && (ei = a[es], K += w(e, C) & (1 << ei) - 1, C += ei), C > k) {
                                                        S && M(0);
                                                        break
                                                    }
                                                    v && A(I + 131072);
                                                    for (var eo = I + er; I < eo; I += 4) o[I] = o[I - K], o[I + 1] = o[I + 1 - K], o[I + 2] = o[I + 2 - K], o[I + 3] = o[I + 3 - K];
                                                    I = eo
                                                }
                                            }
                                            l.l = P, l.p = et, l.b = I, P && (E = 1, l.m = L, l.d = R, l.n = D)
                                        } while (!E);
                                        return I == o.length ? o : (c = o, (d = 0) < 0 && (d = 0), (null == (f = I) || f > c.length) && (f = c.length), (p = new(c instanceof n ? n : c instanceof r ? r : t)(f - d)).set(c.subarray(d, f)), p)
                                    },
                                    A = new t(0),
                                    E = "undefined" != typeof TextDecoder && new TextDecoder;
                                try {
                                    E.decode(A, {
                                        stream: !0
                                    })
                                } catch (C) {}
                                return e.convert_streams = function(e) {
                                    var t = new DataView(e),
                                        n = 0;

                                    function r() {
                                        var e = t.getUint16(n);
                                        return n += 2, e
                                    }

                                    function i() {
                                        var e = t.getUint32(n);
                                        return n += 4, e
                                    }

                                    function a(e) {
                                        v.setUint16(_, e), _ += 2
                                    }

                                    function s(e) {
                                        v.setUint32(_, e), _ += 4
                                    }
                                    for (var o = {
                                            signature: i(),
                                            flavor: i(),
                                            length: i(),
                                            numTables: r(),
                                            reserved: r(),
                                            totalSfntSize: i(),
                                            majorVersion: r(),
                                            minorVersion: r(),
                                            metaOffset: i(),
                                            metaLength: i(),
                                            metaOrigLength: i(),
                                            privOffset: i(),
                                            privLength: i()
                                        }, l = 0; Math.pow(2, l) <= o.numTables;) l++;
                                    l--;
                                    for (var u = 16 * Math.pow(2, l), c = 16 * o.numTables - u, h = 12, d = [], f = 0; f < o.numTables; f++) d.push({
                                        tag: i(),
                                        offset: i(),
                                        compLength: i(),
                                        origLength: i(),
                                        origChecksum: i()
                                    }), h += 16;
                                    var p, m = new Uint8Array(12 + 16 * d.length + d.reduce(function(e, t) {
                                            return e + t.origLength + 4
                                        }, 0)),
                                        g = m.buffer,
                                        v = new DataView(g),
                                        _ = 0;
                                    return s(o.flavor), a(o.numTables), a(u), a(l), a(c), d.forEach(function(e) {
                                        s(e.tag), s(e.origChecksum), s(h), s(e.origLength), e.outOffset = h, (h += e.origLength) % 4 != 0 && (h += 4 - h % 4)
                                    }), d.forEach(function(t) {
                                        var n = e.slice(t.offset, t.offset + t.compLength);
                                        if (t.compLength != t.origLength) {
                                            var r = new Uint8Array(t.origLength);
                                            T(new Uint8Array(n, 2), r)
                                        } else r = new Uint8Array(n);
                                        m.set(r, t.outOffset);
                                        var i = 0;
                                        (h = t.outOffset + t.origLength) % 4 != 0 && (i = 4 - h % 4), m.set(new Uint8Array(i).buffer, t.outOffset + t.origLength), p = h + i
                                    }), g.slice(0, p)
                                }, Object.defineProperty(e, "__esModule", {
                                    value: !0
                                }), e
                            }({}).convert_streams
                        },
                        function(e, t) {
                            let n;
                            let r = {
                                    M: 2,
                                    L: 2,
                                    Q: 4,
                                    C: 6,
                                    Z: 0
                                },
                                i = {
                                    C: "18g,ca,368,1kz",
                                    D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
                                    R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
                                    L: "x9u,jff,a,fd,jv",
                                    T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"
                                },
                                a = [null, "isol", "init", "fina", "medi"];

                            function s(...e) {
                                for (let t = 0; t < e.length; t++)
                                    if ("number" == typeof e[t]) return e[t]
                            }
                            return function(o) {
                                let l = new Uint8Array(o, 0, 4),
                                    u = e._bin.readASCII(l, 0, 4);
                                if ("wOFF" === u) o = t(o);
                                else if ("wOF2" === u) throw Error("woff2 fonts not supported");
                                return function(t) {
                                    let o = Object.create(null),
                                        l = t["OS/2"],
                                        u = t.hhea,
                                        c = t.head.unitsPerEm,
                                        h = s(l && l.sTypoAscender, u && u.ascender, c),
                                        d = {
                                            unitsPerEm: c,
                                            ascender: h,
                                            descender: s(l && l.sTypoDescender, u && u.descender, 0),
                                            capHeight: s(l && l.sCapHeight, h),
                                            xHeight: s(l && l.sxHeight, h),
                                            lineGap: s(l && l.sTypoLineGap, u && u.lineGap),
                                            forEachGlyph(s, l, u, c) {
                                                let h = 0,
                                                    f = 1 / d.unitsPerEm * l,
                                                    p = function(t, r) {
                                                        let s = [];
                                                        for (let o = 0; o < r.length; o++) {
                                                            let l = r.codePointAt(o);
                                                            l > 65535 && o++, s.push(e.U.codeToGlyph(t, l))
                                                        }
                                                        let u = t.GSUB;
                                                        if (u) {
                                                            let c;
                                                            let {
                                                                lookupList: h,
                                                                featureList: d
                                                            } = u, f = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, p = [];
                                                            d.forEach(t => {
                                                                if (f.test(t.tag))
                                                                    for (let o = 0; o < t.tab.length; o++) {
                                                                        if (p[t.tab[o]]) continue;
                                                                        p[t.tab[o]] = !0;
                                                                        let l = h[t.tab[o]],
                                                                            u = /^(isol|init|fina|medi)$/.test(t.tag);
                                                                        u && !c && (c = function(e) {
                                                                            let t = new Uint8Array(e.length),
                                                                                r = 32,
                                                                                a = 1,
                                                                                s = -1;
                                                                            for (let o = 0; o < e.length; o++) {
                                                                                let l = e.codePointAt(o),
                                                                                    u = 0 | function(e) {
                                                                                        if (!n) {
                                                                                            let t = {
                                                                                                R: 2,
                                                                                                L: 1,
                                                                                                D: 4,
                                                                                                C: 16,
                                                                                                U: 32,
                                                                                                T: 8
                                                                                            };
                                                                                            for (let r in n = new Map, i) {
                                                                                                let a = 0;
                                                                                                i[r].split(",").forEach(e => {
                                                                                                    let [i, s] = e.split("+");
                                                                                                    i = parseInt(i, 36), s = s ? parseInt(s, 36) : 0, n.set(a += i, t[r]);
                                                                                                    for (let o = s; o--;) n.set(++a, t[r])
                                                                                                })
                                                                                            }
                                                                                        }
                                                                                        return n.get(e) || 32
                                                                                    }(l),
                                                                                    c = 1;
                                                                                !(8 & u) && (21 & r ? 22 & u ? (c = 3, (1 === a || 3 === a) && t[s]++) : 33 & u && (2 === a || 4 === a) && t[s]-- : 34 & r && (2 === a || 4 === a) && t[s]--, a = t[o] = c, r = u, s = o, l > 65535 && o++)
                                                                            }
                                                                            return t
                                                                        }(r));
                                                                        for (let d = 0; d < s.length; d++) c && u && a[c[d]] !== t.tag || e.U._applySubs(s, d, l, h)
                                                                    }
                                                            })
                                                        }
                                                        return s
                                                    }(t, s),
                                                    m = 0,
                                                    g = -1;
                                                return p.forEach((n, i) => {
                                                    if (-1 !== n) {
                                                        let a = o[n];
                                                        if (!a) {
                                                            let d, p, v, _;
                                                            let {
                                                                cmds: y,
                                                                crds: x
                                                            } = e.U.glyphToPath(t, n), b = "", w = 0;
                                                            for (let S = 0, M = y.length; S < M; S++) {
                                                                let T = r[y[S]];
                                                                b += y[S];
                                                                for (let A = 1; A <= T; A++) b += (A > 1 ? "," : "") + x[w++]
                                                            }
                                                            if (x.length) {
                                                                d = p = 1 / 0, v = _ = -1 / 0;
                                                                for (let E = 0, C = x.length; E < C; E += 2) {
                                                                    let I = x[E],
                                                                        P = x[E + 1];
                                                                    I < d && (d = I), P < p && (p = P), I > v && (v = I), P > _ && (_ = P)
                                                                }
                                                            } else d = v = p = _ = 0;
                                                            a = o[n] = {
                                                                index: n,
                                                                advanceWidth: t.hmtx.aWidth[n],
                                                                xMin: d,
                                                                yMin: p,
                                                                xMax: v,
                                                                yMax: _,
                                                                path: b,
                                                                pathCommandCount: y.length
                                                            }
                                                        } - 1 !== g && (h += e.U.getPairAdjustment(t, g, n) * f), c.call(null, a, h, m), a.advanceWidth && (h += a.advanceWidth * f), u && (h += u * l), g = n
                                                    }
                                                    m += s.codePointAt(m) > 65535 ? 2 : 1
                                                }), h
                                            }
                                        };
                                    return d
                                }(e.parse(o)[0])
                            }
                        }
                    ],
                    init(e, t, n) {
                        let r = e(),
                            i = t();
                        return n(r, i)
                    }
                }),
                V = {
                    defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
                    sdfGlyphSize: 64,
                    sdfMargin: 1 / 16,
                    sdfExponent: 9,
                    textureWidth: 2048
                },
                W = new a.Color;

            function H() {
                return (self.performance || Date).now()
            }
            let j = Object.create(null);

            function q(e, t) {
                var n;
                e = function(e, t) {
                    for (let n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
                    return e
                }({}, e);
                let r = H();
                if (e.font = (n = e.font || V.defaultFontURL, i || (i = "undefined" == typeof document ? {} : document.createElement("a")), i.href = n, i.href), e.text = "" + e.text, e.sdfGlyphSize = e.sdfGlyphSize || V.sdfGlyphSize, null != e.colorRanges) {
                    let s = {};
                    for (let o in e.colorRanges)
                        if (e.colorRanges.hasOwnProperty(o)) {
                            let l = e.colorRanges[o];
                            "number" != typeof l && (l = W.set(l).getHex()), s[o] = l
                        }
                    e.colorRanges = s
                }
                Object.freeze(e);
                let {
                    textureWidth: u,
                    sdfExponent: c
                } = V, {
                    sdfGlyphSize: h
                } = e, d = u / h * 4, f = j[h];
                if (!f) {
                    let p = document.createElement("canvas");
                    p.width = u, p.height = 256 * h / d, (f = j[h] = {
                            glyphCount: 0,
                            sdfGlyphSize: h,
                            sdfCanvas: p,
                            sdfTexture: new a.Texture(p, void 0, void 0, void 0, a.LinearFilter, a.LinearFilter),
                            contextLost: !1,
                            glyphsByFont: new Map
                        }).sdfTexture.generateMipmaps = !1,
                        function(e) {
                            let t = e.sdfCanvas;
                            t.addEventListener("webglcontextlost", t => {
                                console.log("Context Lost", t), t.preventDefault(), e.contextLost = !0
                            }), t.addEventListener("webglcontextrestored", t => {
                                console.log("Context Restored", t), e.contextLost = !1;
                                let n = [];
                                e.glyphsByFont.forEach(t => {
                                    t.forEach(t => {
                                        n.push(X(t, e, !0))
                                    })
                                }), Promise.all(n).then(() => {
                                    Y(e), e.sdfTexture.needsUpdate = !0
                                })
                            })
                        }(f)
                }
                let {
                    sdfTexture: m,
                    sdfCanvas: g
                } = f, v = f.glyphsByFont.get(e.font);
                v || f.glyphsByFont.set(e.font, v = new Map), J(e).then(n => {
                    let {
                        glyphIds: i,
                        glyphPositions: a,
                        fontSize: s,
                        unitsPerEm: o,
                        timings: l
                    } = n, p = [], _ = new Float32Array(4 * i.length), y = s / o, x = 0, b = 0, w = H();
                    i.forEach((e, t) => {
                        let r = v.get(e);
                        if (!r) {
                            let {
                                path: s,
                                pathBounds: o
                            } = n.glyphData[e], l = Math.max(o[2] - o[0], o[3] - o[1]) / h * (V.sdfMargin * h + .5), u = f.glyphCount++, c = [o[0] - l, o[1] - l, o[2] + l, o[3] + l];
                            v.set(e, r = {
                                path: s,
                                atlasIndex: u,
                                sdfViewBox: c
                            }), p.push(r)
                        }
                        let {
                            sdfViewBox: d
                        } = r, m = a[b++], g = a[b++];
                        _[x++] = m + d[0] * y, _[x++] = g + d[1] * y, _[x++] = m + d[2] * y, _[x++] = g + d[3] * y, i[t] = r.atlasIndex
                    }), l.quads = (l.quads || 0) + (H() - w);
                    let S = H();
                    l.sdf = {};
                    let M = g.height,
                        T = Math.ceil(f.glyphCount / d),
                        A = Math.pow(2, Math.ceil(Math.log2(T * h)));
                    A > M && (console.info(`Increasing SDF texture size ${M}->${A}`), z(g, u, A), m.dispose()), Promise.all(p.map(t => X(t, f, e.gpuAccelerateSDF).then(({
                        timing: e
                    }) => {
                        l.sdf[t.atlasIndex] = e
                    }))).then(() => {
                        p.length && !f.contextLost && (Y(f), m.needsUpdate = !0), l.sdfTotal = H() - S, l.total = H() - r, t(Object.freeze({
                            parameters: e,
                            sdfTexture: m,
                            sdfGlyphSize: h,
                            sdfExponent: c,
                            glyphBounds: _,
                            glyphAtlasIndices: i,
                            glyphColors: n.glyphColors,
                            caretPositions: n.caretPositions,
                            caretHeight: n.caretHeight,
                            chunkedBounds: n.chunkedBounds,
                            ascender: n.ascender,
                            descender: n.descender,
                            lineHeight: n.lineHeight,
                            capHeight: n.capHeight,
                            xHeight: n.xHeight,
                            topBaseline: n.topBaseline,
                            blockBounds: n.blockBounds,
                            visibleBounds: n.visibleBounds,
                            timings: n.timings
                        }))
                    })
                }), Promise.resolve().then(() => {
                    if (!f.contextLost) {
                        var e;
                        (e = g)._warm || (L.webgl.isSupported(e), e._warm = !0)
                    }
                })
            }

            function X({
                path: e,
                atlasIndex: t,
                sdfViewBox: n
            }, {
                sdfGlyphSize: i,
                sdfCanvas: a,
                contextLost: s
            }, o) {
                if (s) return Promise.resolve({
                    timing: -1
                });
                let {
                    textureWidth: l,
                    sdfExponent: u
                } = V, c = Math.max(n[2] - n[0], n[3] - n[1]), h = Math.floor(t / 4);
                return function(e, t, n, i, a, s, o, l, u, c, h = !0) {
                    return h ? O(e, t, n, i, a, s, o, l, u, c).then(null, h => (r || (console.warn("WebGL SDF generation failed, falling back to JS", h), r = !0), B(e, t, n, i, a, s, o, l, u, c))) : B(e, t, n, i, a, s, o, l, u, c)
                }(i, i, e, n, c, u, a, h % (l / i) * i, Math.floor(h / (l / i)) * i, t % 4, o)
            }

            function Z({
                font: e,
                characters: t,
                sdfGlyphSize: n
            }, r) {
                let i = Array.isArray(t) ? t.join("\n") : "" + t;
                q({
                    font: e,
                    sdfGlyphSize: n,
                    text: i
                }, r)
            }

            function Y(e) {
                if ("function" != typeof createImageBitmap) {
                    console.info("Safari<15: applying SDF canvas workaround");
                    let {
                        sdfCanvas: t,
                        sdfTexture: n
                    } = e, {
                        width: r,
                        height: i
                    } = t, a = e.sdfCanvas.getContext("webgl"), s = n.image.data;
                    s && s.length === r * i * 4 || (s = new Uint8Array(r * i * 4), n.image = {
                        width: r,
                        height: i,
                        data: s
                    }, n.flipY = !1, n.isDataTexture = !0), a.readPixels(0, 0, r, i, a.RGBA, a.UNSIGNED_BYTE, s)
                }
            }
            let $ = p({
                    name: "Typesetter",
                    dependencies: [V, G, function(e, t, n) {
                        let {
                            defaultFontURL: r
                        } = n, i = Object.create(null), a = 1 / 0, s = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, o = `[^\\S\\u00A0]`, l = RegExp(`${o}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);

                        function u(t, n) {
                            t || (t = r);
                            let a = i[t];
                            if (a) a.pending ? a.pending.push(n) : n(a);
                            else {
                                var s, o;
                                i[t] = {
                                        pending: [n]
                                    }, s = t, o = e => {
                                        let n = i[t].pending;
                                        i[t] = e, n.forEach(t => t(e))
                                    },
                                    function t() {
                                        let n = e => {
                                            console.error(`Failure loading font ${s}${s===r?"":"; trying fallback"}`, e), s !== r && (s = r, t())
                                        };
                                        try {
                                            let i = new XMLHttpRequest;
                                            i.open("get", s, !0), i.responseType = "arraybuffer", i.onload = function() {
                                                if (i.status >= 400) n(Error(i.statusText));
                                                else if (i.status > 0) try {
                                                    let t = e(i.response);
                                                    o(t)
                                                } catch (r) {
                                                    n(r)
                                                }
                                            }, i.onerror = n, i.send()
                                        } catch (a) {
                                            n(a)
                                        }
                                    }()
                            }
                        }

                        function c({
                            text: e = "",
                            font: n = r,
                            sdfGlyphSize: i = 64,
                            fontSize: c = 1,
                            letterSpacing: m = 0,
                            lineHeight: g = "normal",
                            maxWidth: v = a,
                            direction: _,
                            textAlign: y = "left",
                            textIndent: x = 0,
                            whiteSpace: b = "normal",
                            overflowWrap: w = "normal",
                            anchorX: S = 0,
                            anchorY: M = 0,
                            includeCaretPositions: T = !1,
                            chunkedBoundsSize: A = 8192,
                            colorRanges: E = null
                        }, C, I = !1) {
                            let P = f(),
                                R = {
                                    fontLoad: 0,
                                    typesetting: 0
                                };
                            e.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n")), c = +c, m = +m, v = +v, g = g || "normal", x = +x, u(n, n => {
                                let r = isFinite(v),
                                    i = null,
                                    u = null,
                                    L = null,
                                    D = null,
                                    k = null,
                                    U = null,
                                    O = null,
                                    F = 0,
                                    N = 0,
                                    B = "nowrap" !== b,
                                    {
                                        ascender: z,
                                        descender: G,
                                        unitsPerEm: V,
                                        lineGap: W,
                                        capHeight: H,
                                        xHeight: j
                                    } = n;
                                R.fontLoad = f() - P;
                                let q = f(),
                                    X = c / V;
                                "normal" === g && (g = (z - G + W) / V), g *= c;
                                let Z = (g - (z - G) * X) / 2,
                                    Y = -(z * X + Z),
                                    $ = Math.min(g, (z - G) * X),
                                    J = (z + G) / 2 * X - $ / 2,
                                    K = x,
                                    Q = new p,
                                    ee = [Q];
                                n.forEachGlyph(e, c, m, (t, n, i) => {
                                    let a;
                                    let u = e.charAt(i),
                                        h = t.advanceWidth * X,
                                        d = Q.count;
                                    if ("isEmpty" in t || (t.isWhitespace = !!u && RegExp(o).test(u), t.canBreakAfter = !!u && l.test(u), t.isEmpty = t.xMin === t.xMax || t.yMin === t.yMax || s.test(u)), !t.isWhitespace && !t.isEmpty && N++, B && r && !t.isWhitespace && n + h + K > v && d) {
                                        if (Q.glyphAt(d - 1).glyphObj.canBreakAfter) a = new p, K = -n;
                                        else
                                            for (let f = d; f--;) {
                                                if (0 === f && "break-word" === w) {
                                                    a = new p, K = -n;
                                                    break
                                                }
                                                if (Q.glyphAt(f).glyphObj.canBreakAfter) {
                                                    a = Q.splitAt(f + 1);
                                                    let g = a.glyphAt(0).x;
                                                    K -= g;
                                                    for (let _ = a.count; _--;) a.glyphAt(_).x -= g;
                                                    break
                                                }
                                            }
                                        a && (Q.isSoftWrapped = !0, Q = a, ee.push(Q), F = v)
                                    }
                                    let y = Q.glyphAt(Q.count);
                                    y.glyphObj = t, y.x = n + K, y.width = h, y.charIndex = i, "\n" === u && (Q = new p, ee.push(Q), K = -(n + h + m * c) + x)
                                }), ee.forEach(e => {
                                    for (let t = e.count; t--;) {
                                        let {
                                            glyphObj: n,
                                            x: r,
                                            width: i
                                        } = e.glyphAt(t);
                                        if (!n.isWhitespace) {
                                            e.width = r + i, e.width > F && (F = e.width);
                                            return
                                        }
                                    }
                                });
                                let et = 0,
                                    en = 0;
                                if (S && ("number" == typeof S ? et = -S : "string" == typeof S && (et = -F * ("left" === S ? 0 : "center" === S ? .5 : "right" === S ? 1 : h(S)))), M) {
                                    if ("number" == typeof M) en = -M;
                                    else if ("string" == typeof M) {
                                        let er = ee.length * g;
                                        en = "top" === M ? 0 : "top-baseline" === M ? -Y : "top-cap" === M ? -Y - H * X : "top-ex" === M ? -Y - j * X : "middle" === M ? er / 2 : "bottom" === M ? er : "bottom-baseline" === M ? er - Z + G * X : h(M) * er
                                    }
                                }
                                if (!I) {
                                    let ei, ea;
                                    let es = t.getEmbeddingLevels(e, _);
                                    i = new Uint16Array(N), u = new Float32Array(2 * N), L = {}, U = [a, a, -a, -a], O = [];
                                    let eo = Y;
                                    T && (k = new Float32Array(3 * e.length)), E && (D = new Uint8Array(3 * N));
                                    let el = 0,
                                        eu = -1,
                                        ec = -1;
                                    if (ee.forEach((r, s) => {
                                            let {
                                                count: o,
                                                width: l
                                            } = r;
                                            if (o > 0) {
                                                let c, h = 0;
                                                for (let f = o; f-- && r.glyphAt(f).glyphObj.isWhitespace;) h++;
                                                let p = 0,
                                                    m = 0;
                                                if ("center" === y) p = (F - l) / 2;
                                                else if ("right" === y) p = F - l;
                                                else if ("justify" === y && r.isSoftWrapped) {
                                                    let v = 0;
                                                    for (let _ = o - h; _--;) r.glyphAt(_).glyphObj.isWhitespace && v++;
                                                    m = (F - l) / v
                                                }
                                                if (m || p) {
                                                    let x = 0;
                                                    for (let b = 0; b < o; b++) {
                                                        let w = r.glyphAt(b),
                                                            S = w.glyphObj;
                                                        w.x += p + x, 0 !== m && S.isWhitespace && b < o - h && (x += m, w.width += m)
                                                    }
                                                }
                                                let M = t.getReorderSegments(e, es, r.glyphAt(0).charIndex, r.glyphAt(r.count - 1).charIndex);
                                                for (let C = 0; C < M.length; C++) {
                                                    let [I, P] = M[C], R = 1 / 0, N = -1 / 0;
                                                    for (let B = 0; B < o; B++)
                                                        if (r.glyphAt(B).charIndex >= I) {
                                                            let z = B,
                                                                G = B;
                                                            for (; G < o; G++) {
                                                                let V = r.glyphAt(G);
                                                                if (V.charIndex > P) break;
                                                                G < o - h && (R = Math.min(R, V.x), N = Math.max(N, V.x + V.width))
                                                            }
                                                            for (let W = z; W < G; W++) {
                                                                let H = r.glyphAt(W);
                                                                H.x = N - (H.x + H.width - R)
                                                            }
                                                            break
                                                        }
                                                }
                                                let j = e => c = e;
                                                for (let q = 0; q < o; q++) {
                                                    let Z = r.glyphAt(q);
                                                    c = Z.glyphObj;
                                                    let Y = c.index,
                                                        $ = 1 & es.levels[Z.charIndex];
                                                    if ($) {
                                                        let K = t.getMirroredCharacter(e[Z.charIndex]);
                                                        K && n.forEachGlyph(K, 0, 0, j)
                                                    }
                                                    if (T) {
                                                        let {
                                                            charIndex: Q
                                                        } = Z, ee = Z.x + et, er = Z.x + Z.width + et;
                                                        k[3 * Q] = $ ? er : ee, k[3 * Q + 1] = $ ? ee : er, k[3 * Q + 2] = eo + J + en;
                                                        let eh = Q - eu;
                                                        eh > 1 && d(k, eu, eh), eu = Q
                                                    }
                                                    if (E) {
                                                        let {
                                                            charIndex: ed
                                                        } = Z;
                                                        for (; ed > ec;) ec++, E.hasOwnProperty(ec) && (ea = E[ec])
                                                    }
                                                    if (!c.isWhitespace && !c.isEmpty) {
                                                        let ef = el++;
                                                        L[Y] || (L[Y] = {
                                                            path: c.path,
                                                            pathBounds: [c.xMin, c.yMin, c.xMax, c.yMax]
                                                        });
                                                        let ep = Z.x + et,
                                                            em = eo + en;
                                                        u[2 * ef] = ep, u[2 * ef + 1] = em;
                                                        let eg = ep + c.xMin * X,
                                                            ev = em + c.yMin * X,
                                                            e_ = ep + c.xMax * X,
                                                            ey = em + c.yMax * X;
                                                        eg < U[0] && (U[0] = eg), ev < U[1] && (U[1] = ev), e_ > U[2] && (U[2] = e_), ey > U[3] && (U[3] = ey), ef % A == 0 && (ei = {
                                                            start: ef,
                                                            end: ef,
                                                            rect: [a, a, -a, -a]
                                                        }, O.push(ei)), ei.end++;
                                                        let ex = ei.rect;
                                                        if (eg < ex[0] && (ex[0] = eg), ev < ex[1] && (ex[1] = ev), e_ > ex[2] && (ex[2] = e_), ey > ex[3] && (ex[3] = ey), i[ef] = Y, E) {
                                                            let eb = 3 * ef;
                                                            D[eb] = ea >> 16 & 255, D[eb + 1] = ea >> 8 & 255, D[eb + 2] = 255 & ea
                                                        }
                                                    }
                                                }
                                            }
                                            eo -= g
                                        }), k) {
                                        let eh = e.length - eu;
                                        eh > 1 && d(k, eu, eh)
                                    }
                                }
                                R.typesetting = f() - q, C({
                                    glyphIds: i,
                                    glyphPositions: u,
                                    glyphData: L,
                                    caretPositions: k,
                                    caretHeight: $,
                                    glyphColors: D,
                                    chunkedBounds: O,
                                    fontSize: c,
                                    unitsPerEm: V,
                                    ascender: z * X,
                                    descender: G * X,
                                    capHeight: H * X,
                                    xHeight: j * X,
                                    lineHeight: g,
                                    topBaseline: Y,
                                    blockBounds: [et, en - ee.length * g, et + F, en],
                                    visibleBounds: U,
                                    timings: R
                                })
                            })
                        }

                        function h(e) {
                            let t = e.match(/^([\d.]+)%$/),
                                n = t ? parseFloat(t[1]) : NaN;
                            return isNaN(n) ? 0 : n / 100
                        }

                        function d(e, t, n) {
                            let r = e[3 * t],
                                i = e[3 * t + 1],
                                a = e[3 * t + 2],
                                s = (i - r) / n;
                            for (let o = 0; o < n; o++) {
                                let l = (t + o) * 3;
                                e[l] = r + s * o, e[l + 1] = r + s * (o + 1), e[l + 2] = a
                            }
                        }

                        function f() {
                            return (self.performance || Date).now()
                        }

                        function p() {
                            this.data = []
                        }
                        let m = ["glyphObj", "x", "width", "charIndex"];
                        return p.prototype = {
                            width: 0,
                            isSoftWrapped: !1,
                            get count() {
                                return Math.ceil(this.data.length / m.length)
                            },
                            glyphAt(e) {
                                let t = p.flyweight;
                                return t.data = this.data, t.index = e, t
                            },
                            splitAt(e) {
                                let t = new p;
                                return t.data = this.data.splice(e * m.length), t
                            }
                        }, p.flyweight = m.reduce((e, t, n, r) => (Object.defineProperty(e, t, {
                            get() {
                                return this.data[this.index * m.length + n]
                            },
                            set(e) {
                                this.data[this.index * m.length + n] = e
                            }
                        }), e), {
                            data: null,
                            index: 0
                        }), {
                            typeset: c,
                            measure: function(e, t) {
                                c(e, e => {
                                    let [n, r, i, a] = e.blockBounds;
                                    t({
                                        width: i - n,
                                        height: a - r
                                    })
                                }, {
                                    metricsOnly: !0
                                })
                            },
                            loadFont: u
                        }
                    }, function() {
                        return function(e) {
                            var t, n, r, i, a = {
                                    R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
                                    EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
                                    ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
                                    ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
                                    AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
                                    CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
                                    B: "a,3,f+2,2v,690",
                                    S: "9,2,k",
                                    WS: "c,k,4f4,1vk+a,u,1j,335",
                                    ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
                                    BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
                                    NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
                                    AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
                                    LRO: "6ct",
                                    RLO: "6cu",
                                    LRE: "6cq",
                                    RLE: "6cr",
                                    PDF: "6cs",
                                    LRI: "6ee",
                                    RLI: "6ef",
                                    FSI: "6eg",
                                    PDI: "6eh"
                                },
                                s = {},
                                o = {};
                            s.L = 1, o[1] = "L", Object.keys(a).forEach(function(e, t) {
                                s[e] = 1 << t + 1, o[s[e]] = e
                            }), Object.freeze(s);
                            var l = s.LRI | s.RLI | s.FSI,
                                u = s.L | s.R | s.AL,
                                c = s.B | s.S | s.WS | s.ON | s.FSI | s.LRI | s.RLI | s.PDI,
                                h = s.BN | s.RLE | s.LRE | s.RLO | s.LRO | s.PDF,
                                d = s.S | s.WS | s.B | l | s.PDI | h,
                                f = null;

                            function p(e) {
                                return ! function() {
                                    if (!f) {
                                        f = new Map;
                                        var e = function(e) {
                                            if (a.hasOwnProperty(e)) {
                                                var t = 0;
                                                a[e].split(",").forEach(function(n) {
                                                    var r = n.split("+"),
                                                        i = r[0],
                                                        a = r[1];
                                                    i = parseInt(i, 36), a = a ? parseInt(a, 36) : 0, f.set(t += i, s[e]);
                                                    for (var o = 0; o < a; o++) f.set(++t, s[e])
                                                })
                                            }
                                        };
                                        for (var t in a) e(t)
                                    }
                                }(), f.get(e.codePointAt(0)) || s.L
                            }
                            var m = {
                                pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
                                canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
                            };

                            function g(e, t) {
                                var n, r = 0,
                                    i = new Map,
                                    a = t && new Map;
                                return e.split(",").forEach(function e(s) {
                                    if (-1 !== s.indexOf("+"))
                                        for (var o = +s; o--;) e(n);
                                    else {
                                        n = s;
                                        var l = s.split(">"),
                                            u = l[0],
                                            c = l[1];
                                        u = String.fromCodePoint(r += parseInt(u, 36)), c = String.fromCodePoint(r += parseInt(c, 36)), i.set(u, c), t && a.set(c, u)
                                    }
                                }), {
                                    map: i,
                                    reverseMap: a
                                }
                            }

                            function v() {
                                if (!t) {
                                    var e = g(m.pairs, !0),
                                        i = e.map,
                                        a = e.reverseMap;
                                    t = i, n = a, r = g(m.canonical, !1).map
                                }
                            }

                            function _(e) {
                                return v(), t.get(e) || null
                            }

                            function y(e) {
                                return v(), n.get(e) || null
                            }

                            function x(e) {
                                return v(), r.get(e) || null
                            }
                            var b = s.L,
                                w = s.R,
                                S = s.EN,
                                M = s.ES,
                                T = s.ET,
                                A = s.AN,
                                E = s.CS,
                                C = s.B,
                                I = s.S,
                                P = s.ON,
                                R = s.BN,
                                L = s.NSM,
                                D = s.AL,
                                k = s.LRO,
                                U = s.RLO,
                                O = s.LRE,
                                F = s.RLE,
                                N = s.PDF,
                                B = s.LRI,
                                z = s.RLI,
                                G = s.FSI,
                                V = s.PDI;

                            function W(e) {
                                return ! function() {
                                    if (!i) {
                                        var e = g("14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", !0),
                                            t = e.map;
                                        e.reverseMap.forEach(function(e, n) {
                                            t.set(n, e)
                                        }), i = t
                                    }
                                }(), i.get(e) || null
                            }

                            function H(e, t, n, r) {
                                var i = e.length;
                                n = Math.max(0, null == n ? 0 : +n), r = Math.min(i - 1, null == r ? i - 1 : +r);
                                var a = [];
                                return t.paragraphs.forEach(function(i) {
                                    var s = Math.max(n, i.start),
                                        o = Math.min(r, i.end);
                                    if (s < o) {
                                        for (var l = t.levels.slice(s, o + 1), u = o; u >= s && p(e[u]) & d; u--) l[u] = i.level;
                                        for (var c = i.level, h = 1 / 0, f = 0; f < l.length; f++) {
                                            var m = l[f];
                                            m > c && (c = m), m < h && (h = 1 | m)
                                        }
                                        for (var g = c; g >= h; g--)
                                            for (var v = 0; v < l.length; v++)
                                                if (l[v] >= g) {
                                                    for (var _ = v; v + 1 < l.length && l[v + 1] >= g;) v++;
                                                    v > _ && a.push([_ + n, v + n])
                                                }
                                    }
                                }), a
                            }

                            function j(e, t, n, r) {
                                for (var i = H(e, t, n, r), a = [], s = 0; s < e.length; s++) a[s] = s;
                                return i.forEach(function(e) {
                                    for (var t = e[0], n = e[1], r = a.slice(t, n + 1), i = r.length; i--;) a[n - i] = r[i]
                                }), a
                            }
                            return e.closingToOpeningBracket = y, e.getBidiCharType = p, e.getBidiCharTypeName = function(e) {
                                return o[p(e)]
                            }, e.getCanonicalBracket = x, e.getEmbeddingLevels = function(e, t) {
                                for (var n = new Uint32Array(e.length), r = 0; r < e.length; r++) n[r] = p(e[r]);
                                var i = new Map;

                                function a(e, t) {
                                    var r = n[e];
                                    n[e] = t, i.set(r, i.get(r) - 1), r & c && i.set(c, i.get(c) - 1), i.set(t, (i.get(t) || 0) + 1), t & c && i.set(c, (i.get(c) || 0) + 1)
                                }
                                for (var s = new Uint8Array(e.length), o = new Map, f = [], m = null, g = 0; g < e.length; g++) m || f.push(m = {
                                    start: g,
                                    end: e.length - 1,
                                    level: "rtl" === t ? 1 : "ltr" === t ? 0 : tP(g, !1)
                                }), n[g] & C && (m.end = g, m = null);
                                for (var v = F | O | U | k | l | V | N | C, W = function(e) {
                                        return e + (1 & e ? 1 : 2)
                                    }, H = function(e) {
                                        return e + (1 & e ? 2 : 1)
                                    }, j = 0; j < f.length; j++) {
                                    var q = [{
                                            _level: (m = f[j]).level,
                                            _override: 0,
                                            _isolate: 0
                                        }],
                                        X = void 0,
                                        Z = 0,
                                        Y = 0,
                                        $ = 0;
                                    i.clear();
                                    for (var J = m.start; J <= m.end; J++) {
                                        var K = n[J];
                                        if (X = q[q.length - 1], i.set(K, (i.get(K) || 0) + 1), K & c && i.set(c, (i.get(c) || 0) + 1), K & v) {
                                            if (K & (F | O)) {
                                                s[J] = X._level;
                                                var Q = (K === F ? H : W)(X._level);
                                                !(Q <= 125) || Z || Y ? !Z && Y++ : q.push({
                                                    _level: Q,
                                                    _override: 0,
                                                    _isolate: 0
                                                })
                                            } else if (K & (U | k)) {
                                                s[J] = X._level;
                                                var ee = (K === U ? H : W)(X._level);
                                                !(ee <= 125) || Z || Y ? !Z && Y++ : q.push({
                                                    _level: ee,
                                                    _override: K & U ? w : b,
                                                    _isolate: 0
                                                })
                                            } else if (K & l) {
                                                K & G && (K = 1 === tP(J + 1, !0) ? z : B), s[J] = X._level, X._override && a(J, X._override);
                                                var et = (K === z ? H : W)(X._level);
                                                et <= 125 && 0 === Z && 0 === Y ? ($++, q.push({
                                                    _level: et,
                                                    _override: 0,
                                                    _isolate: 1,
                                                    _isolInitIndex: J
                                                })) : Z++
                                            } else if (K & V) {
                                                if (Z > 0) Z--;
                                                else if ($ > 0) {
                                                    for (Y = 0; !q[q.length - 1]._isolate;) q.pop();
                                                    var en = q[q.length - 1]._isolInitIndex;
                                                    null != en && (o.set(en, J), o.set(J, en)), q.pop(), $--
                                                }
                                                X = q[q.length - 1], s[J] = X._level, X._override && a(J, X._override)
                                            } else K & N ? (0 === Z && (Y > 0 ? Y-- : !X._isolate && q.length > 1 && (q.pop(), X = q[q.length - 1])), s[J] = X._level) : K & C && (s[J] = m.level)
                                        } else s[J] = X._level, X._override && K !== R && a(J, X._override)
                                    }
                                    for (var er = [], ei = null, ea = m.start; ea <= m.end; ea++) {
                                        var es = n[ea];
                                        if (!(es & h)) {
                                            var eo = s[ea],
                                                el = es & l,
                                                eu = es === V;
                                            ei && eo === ei._level ? (ei._end = ea, ei._endsWithIsolInit = el) : er.push(ei = {
                                                _start: ea,
                                                _end: ea,
                                                _level: eo,
                                                _startsWithPDI: eu,
                                                _endsWithIsolInit: el
                                            })
                                        }
                                    }
                                    for (var ec = [], eh = 0; eh < er.length; eh++) {
                                        var ed = er[eh];
                                        if (!ed._startsWithPDI || ed._startsWithPDI && !o.has(ed._start)) {
                                            for (var ef = [ei = ed], ep = void 0; ei && ei._endsWithIsolInit && null != (ep = o.get(ei._end));)
                                                for (var em = eh + 1; em < er.length; em++)
                                                    if (er[em]._start === ep) {
                                                        ef.push(ei = er[em]);
                                                        break
                                                    }
                                            for (var eg = [], ev = 0; ev < ef.length; ev++)
                                                for (var e_ = ef[ev], ey = e_._start; ey <= e_._end; ey++) eg.push(ey);
                                            for (var ex = s[eg[0]], eb = m.level, ew = eg[0] - 1; ew >= 0; ew--)
                                                if (!(n[ew] & h)) {
                                                    eb = s[ew];
                                                    break
                                                }
                                            var eS = eg[eg.length - 1],
                                                eM = s[eS],
                                                eT = m.level;
                                            if (!(n[eS] & l)) {
                                                for (var eA = eS + 1; eA <= m.end; eA++)
                                                    if (!(n[eA] & h)) {
                                                        eT = s[eA];
                                                        break
                                                    }
                                            }
                                            ec.push({
                                                _seqIndices: eg,
                                                _sosType: Math.max(eb, ex) % 2 ? w : b,
                                                _eosType: Math.max(eT, eM) % 2 ? w : b
                                            })
                                        }
                                    }
                                    for (var eE = 0; eE < ec.length; eE++) {
                                        var eC = ec[eE],
                                            eI = eC._seqIndices,
                                            eP = eC._sosType,
                                            eR = eC._eosType;
                                        if (i.get(L))
                                            for (var eL = 0; eL < eI.length; eL++) {
                                                var eD = eI[eL];
                                                if (n[eD] & L) {
                                                    for (var ek = eP, eU = eL - 1; eU >= 0; eU--)
                                                        if (!(n[eI[eU]] & h)) {
                                                            ek = n[eI[eU]];
                                                            break
                                                        }
                                                    a(eD, ek & (l | V) ? P : ek)
                                                }
                                            }
                                        if (i.get(S))
                                            for (var eO = 0; eO < eI.length; eO++) {
                                                var eF = eI[eO];
                                                if (n[eF] & S)
                                                    for (var eN = eO - 1; eN >= -1; eN--) {
                                                        var eB = -1 === eN ? eP : n[eI[eN]];
                                                        if (eB & u) {
                                                            eB === D && a(eF, A);
                                                            break
                                                        }
                                                    }
                                            }
                                        if (i.get(D))
                                            for (var ez = 0; ez < eI.length; ez++) {
                                                var eG = eI[ez];
                                                n[eG] & D && a(eG, w)
                                            }
                                        if (i.get(M) || i.get(E))
                                            for (var eV = 1; eV < eI.length - 1; eV++) {
                                                var eW = eI[eV];
                                                if (n[eW] & (M | E)) {
                                                    for (var eH = 0, ej = 0, eq = eV - 1; eq >= 0 && (eH = n[eI[eq]]) & h; eq--);
                                                    for (var eX = eV + 1; eX < eI.length && (ej = n[eI[eX]]) & h; eX++);
                                                    eH === ej && (n[eW] === M ? eH === S : eH & (S | A)) && a(eW, eH)
                                                }
                                            }
                                        if (i.get(S)) {
                                            for (var eZ = 0; eZ < eI.length; eZ++)
                                                if (n[eI[eZ]] & S) {
                                                    for (var eY = eZ - 1; eY >= 0 && n[eI[eY]] & (T | h); eY--) a(eI[eY], S);
                                                    for (var e$ = eZ + 1; e$ < eI.length && n[eI[e$]] & (T | h); e$++) a(eI[e$], S)
                                                }
                                        }
                                        if (i.get(T) || i.get(M) || i.get(E))
                                            for (var eJ = 0; eJ < eI.length; eJ++) {
                                                var eK = eI[eJ];
                                                if (n[eK] & (T | M | E)) {
                                                    a(eK, P);
                                                    for (var eQ = eJ - 1; eQ >= 0 && n[eI[eQ]] & h; eQ--) a(eI[eQ], P);
                                                    for (var e0 = eJ + 1; e0 < eI.length && n[eI[e0]] & h; e0++) a(eI[e0], P)
                                                }
                                            }
                                        if (i.get(S))
                                            for (var e1 = 0, e2 = eP; e1 < eI.length; e1++) {
                                                var e3 = eI[e1],
                                                    e4 = n[e3];
                                                e4 & S ? e2 === b && a(e3, b) : e4 & u && (e2 = e4)
                                            }
                                        if (i.get(c)) {
                                            for (var e5 = w | S | A, e6 = e5 | b, e8 = [], e7 = [], e9 = 0; e9 < eI.length; e9++)
                                                if (n[eI[e9]] & c) {
                                                    var te = e[eI[e9]],
                                                        tt = void 0;
                                                    if (null !== _(te)) {
                                                        if (e7.length < 63) e7.push({
                                                            char: te,
                                                            seqIndex: e9
                                                        });
                                                        else break
                                                    } else if (null !== (tt = y(te)))
                                                        for (var tn = e7.length - 1; tn >= 0; tn--) {
                                                            var tr = e7[tn].char;
                                                            if (tr === tt || tr === y(x(te)) || _(x(tr)) === te) {
                                                                e8.push([e7[tn].seqIndex, e9]), e7.length = tn;
                                                                break
                                                            }
                                                        }
                                                }
                                            e8.sort(function(e, t) {
                                                return e[0] - t[0]
                                            });
                                            for (var ti = 0; ti < e8.length; ti++) {
                                                for (var ta = e8[ti], ts = ta[0], to = ta[1], tl = !1, tu = 0, tc = ts + 1; tc < to; tc++) {
                                                    var th = eI[tc];
                                                    if (n[th] & e6) {
                                                        tl = !0;
                                                        var td = n[th] & e5 ? w : b;
                                                        if (td === tR(th)) {
                                                            tu = td;
                                                            break
                                                        }
                                                    }
                                                }
                                                if (tl && !tu) {
                                                    tu = eP;
                                                    for (var tf = ts - 1; tf >= 0; tf--) {
                                                        var tp = eI[tf];
                                                        if (n[tp] & e6) {
                                                            var tm = n[tp] & e5 ? w : b;
                                                            tu = tm !== tR(tp) ? tm : tR(tp);
                                                            break
                                                        }
                                                    }
                                                }
                                                if (tu) {
                                                    if (n[eI[ts]] = n[eI[to]] = tu, tu !== tR(eI[ts])) {
                                                        for (var tg = ts + 1; tg < eI.length; tg++)
                                                            if (!(n[eI[tg]] & h)) {
                                                                p(e[eI[tg]]) & L && (n[eI[tg]] = tu);
                                                                break
                                                            }
                                                    }
                                                    if (tu !== tR(eI[to])) {
                                                        for (var tv = to + 1; tv < eI.length; tv++)
                                                            if (!(n[eI[tv]] & h)) {
                                                                p(e[eI[tv]]) & L && (n[eI[tv]] = tu);
                                                                break
                                                            }
                                                    }
                                                }
                                            }
                                            for (var t_ = 0; t_ < eI.length; t_++)
                                                if (n[eI[t_]] & c) {
                                                    for (var ty = t_, tx = t_, tb = eP, tw = t_ - 1; tw >= 0; tw--)
                                                        if (n[eI[tw]] & h) ty = tw;
                                                        else {
                                                            tb = n[eI[tw]] & e5 ? w : b;
                                                            break
                                                        }
                                                    for (var tS = eR, tM = t_ + 1; tM < eI.length; tM++)
                                                        if (n[eI[tM]] & (c | h)) tx = tM;
                                                        else {
                                                            tS = n[eI[tM]] & e5 ? w : b;
                                                            break
                                                        }
                                                    for (var tT = ty; tT <= tx; tT++) n[eI[tT]] = tb === tS ? tb : tR(eI[tT]);
                                                    t_ = tx
                                                }
                                        }
                                    }
                                    for (var tA = m.start; tA <= m.end; tA++) {
                                        var tE = s[tA],
                                            tC = n[tA];
                                        if (1 & tE ? tC & (b | S | A) && s[tA]++ : tC & w ? s[tA]++ : tC & (A | S) && (s[tA] += 2), tC & h && (s[tA] = 0 === tA ? m.level : s[tA - 1]), tA === m.end || p(e[tA]) & (I | C))
                                            for (var tI = tA; tI >= 0 && p(e[tI]) & d; tI--) s[tI] = m.level
                                    }
                                }
                                return {
                                    levels: s,
                                    paragraphs: f
                                };

                                function tP(t, r) {
                                    for (var i = t; i < e.length; i++) {
                                        var a = n[i];
                                        if (a & (w | D)) return 1;
                                        if (a & (C | b) || r && a === V) break;
                                        if (a & l) {
                                            var s = function(t) {
                                                for (var r = 1, i = t + 1; i < e.length; i++) {
                                                    var a = n[i];
                                                    if (a & C) break;
                                                    if (a & V) {
                                                        if (0 == --r) return i
                                                    } else a & l && r++
                                                }
                                                return -1
                                            }(i);
                                            i = -1 === s ? e.length : s
                                        }
                                    }
                                    return 0
                                }

                                function tR(e) {
                                    return 1 & s[e] ? w : b
                                }
                            }, e.getMirroredCharacter = W, e.getMirroredCharactersMap = function(e, t, n, r) {
                                var i = e.length;
                                n = Math.max(0, null == n ? 0 : +n), r = Math.min(i - 1, null == r ? i - 1 : +r);
                                for (var a = new Map, s = n; s <= r; s++)
                                    if (1 & t[s]) {
                                        var o = W(e[s]);
                                        null !== o && a.set(s, o)
                                    }
                                return a
                            }, e.getReorderSegments = H, e.getReorderedIndices = j, e.getReorderedString = function(e, t, n, r) {
                                var i = j(e, t, n, r),
                                    a = [].concat(e);
                                return i.forEach(function(n, r) {
                                    a[r] = (1 & t.levels[n] ? W(e[n]) : null) || e[n]
                                }), a.join("")
                            }, e.openingToClosingBracket = _, Object.defineProperty(e, "__esModule", {
                                value: !0
                            }), e
                        }({})
                    }],
                    init(e, t, n, r) {
                        let {
                            defaultFontURL: i
                        } = e;
                        return n(t, r(), {
                            defaultFontURL: i
                        })
                    }
                }),
                J = p({
                    name: "Typesetter",
                    dependencies: [$],
                    init: e => function(t) {
                        return new Promise(n => {
                            e.typeset(t, n)
                        })
                    },
                    getTransferables(e) {
                        let t = [e.glyphPositions.buffer, e.glyphIds.buffer];
                        return e.caretPositions && t.push(e.caretPositions.buffer), e.glyphColors && t.push(e.glyphColors.buffer), t
                    }
                }),
                K = {},
                Q = "aTroikaGlyphIndex";
            class ee extends a.InstancedBufferGeometry {
                constructor() {
                    super(), this.detail = 1, this.curveRadius = 0, this.groups = [{
                        start: 0,
                        count: 1 / 0,
                        materialIndex: 0
                    }, {
                        start: 0,
                        count: 1 / 0,
                        materialIndex: 1
                    }], this.boundingSphere = new a.Sphere, this.boundingBox = new a.Box3
                }
                computeBoundingSphere() {}
                computeBoundingBox() {}
                setSide(e) {
                    let t = this.getIndex().count;
                    this.setDrawRange(e === a.BackSide ? t / 2 : 0, e === a.DoubleSide ? t : t / 2)
                }
                set detail(e) {
                    if (e !== this._detail) {
                        this._detail = e, ("number" != typeof e || e < 1) && (e = 1);
                        let t = function(e) {
                            let t = K[e];
                            if (!t) {
                                let n = new a.PlaneGeometry(1, 1, e, e),
                                    r = n.clone(),
                                    i = n.attributes,
                                    s = r.attributes,
                                    o = new a.BufferGeometry,
                                    l = i.uv.count;
                                for (let u = 0; u < l; u++) s.position.array[3 * u] *= -1, s.normal.array[3 * u + 2] *= -1;
                                ["position", "normal", "uv"].forEach(e => {
                                    o.setAttribute(e, new a.Float32BufferAttribute([...i[e].array, ...s[e].array], i[e].itemSize))
                                }), o.setIndex([...n.index.array, ...r.index.array.map(e => e + l)]), o.translate(.5, .5, 0), t = K[e] = o
                            }
                            return t
                        }(e);
                        ["position", "normal", "uv"].forEach(e => {
                            this.attributes[e] = t.attributes[e].clone()
                        }), this.setIndex(t.getIndex().clone())
                    }
                }
                get detail() {
                    return this._detail
                }
                set curveRadius(e) {
                    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds())
                }
                get curveRadius() {
                    return this._curveRadius
                }
                updateGlyphs(e, t, n, r, i) {
                    et(this, "aTroikaGlyphBounds", e, 4), et(this, Q, t, 1), et(this, "aTroikaGlyphColor", i, 3), this._blockBounds = n, this._chunkedBounds = r, this.instanceCount = t.length, this._updateBounds()
                }
                _updateBounds() {
                    let e = this._blockBounds;
                    if (e) {
                        let {
                            curveRadius: t,
                            boundingBox: n
                        } = this;
                        if (t) {
                            let {
                                PI: r,
                                floor: i,
                                min: a,
                                max: s,
                                sin: o,
                                cos: l
                            } = Math, u = r / 2, c = 2 * r, h = Math.abs(t), d = e[0] / h, f = e[2] / h, p = i((d + u) / c) !== i((f + u) / c) ? -h : a(o(d) * h, o(f) * h), m = i((d - u) / c) !== i((f - u) / c) ? h : s(o(d) * h, o(f) * h), g = i((d + r) / c) !== i((f + r) / c) ? 2 * h : s(h - l(d) * h, h - l(f) * h);
                            n.min.set(p, e[1], t < 0 ? -g : 0), n.max.set(m, e[3], t < 0 ? 0 : g)
                        } else n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0);
                        n.getBoundingSphere(this.boundingSphere)
                    }
                }
                applyClipRect(e) {
                    let t = this.getAttribute(Q).count,
                        n = this._chunkedBounds;
                    if (n)
                        for (let r = n.length; r--;) {
                            t = n[r].end;
                            let i = n[r].rect;
                            if (i[1] < e.w && i[3] > e.y && i[0] < e.z && i[2] > e.x) break
                        }
                    this.instanceCount = t
                }
            }

            function et(e, t, n, r) {
                let i = e.getAttribute(t);
                n ? i && i.array.length === n.length ? (i.array.set(n), i.needsUpdate = !0) : (e.setAttribute(t, new a.InstancedBufferAttribute(n, r)), delete e._maxInstanceCount, e.dispose()) : i && e.deleteAttribute(t)
            }
            let en = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
                er = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
                ei = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
                ea = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`,
                es = new a.MeshBasicMaterial({
                    color: 16777215,
                    side: a.DoubleSide,
                    transparent: !0
                }),
                eo = new a.Matrix4,
                el = new a.Vector3,
                eu = new a.Vector3,
                ec = [],
                eh = new a.Vector3,
                ed = "+x+y";

            function ef(e) {
                return Array.isArray(e) ? e[0] : e
            }
            let ep = () => {
                    let e = new a.Mesh(new a.PlaneGeometry(1, 1), es);
                    return ep = () => e, e
                },
                em = () => {
                    let e = new a.Mesh(new a.PlaneGeometry(1, 1, 32, 1), es);
                    return em = () => e, e
                },
                eg = {
                    type: "syncstart"
                },
                ev = {
                    type: "synccomplete"
                },
                e_ = ["font", "fontSize", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"],
                ey = e_.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
            class ex extends a.Mesh {
                constructor() {
                    let e = new ee;
                    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = .1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = 8421504, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = ed, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1
                }
                sync(e) {
                    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(eg), q({
                        text: this.text,
                        font: this.font,
                        fontSize: this.fontSize || .1,
                        letterSpacing: this.letterSpacing || 0,
                        lineHeight: this.lineHeight || "normal",
                        maxWidth: this.maxWidth,
                        direction: this.direction || "auto",
                        textAlign: this.textAlign,
                        textIndent: this.textIndent,
                        whiteSpace: this.whiteSpace,
                        overflowWrap: this.overflowWrap,
                        anchorX: this.anchorX,
                        anchorY: this.anchorY,
                        colorRanges: this.colorRanges,
                        includeCaretPositions: !0,
                        sdfGlyphSize: this.sdfGlyphSize,
                        gpuAccelerateSDF: this.gpuAccelerateSDF
                    }, t => {
                        this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(t.glyphBounds, t.glyphAtlasIndices, t.blockBounds, t.chunkedBounds, t.glyphColors);
                        let n = this._queuedSyncs;
                        n && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
                            n.forEach(e => e && e())
                        })), this.dispatchEvent(ev), e && e()
                    })))
                }
                onBeforeRender(e, t, n, r, i, s) {
                    this.sync(), i.isTroikaTextMaterial && this._prepareForRender(i), i._hadOwnSide = i.hasOwnProperty("side"), this.geometry.setSide(i._actualSide = i.side), i.side = a.FrontSide
                }
                onAfterRender(e, t, n, r, i, a) {
                    i._hadOwnSide ? i.side = i._actualSide : delete i.side
                }
                dispose() {
                    this.geometry.dispose()
                }
                get textRenderInfo() {
                    return this._textRenderInfo || null
                }
                get material() {
                    let e = this._derivedMaterial,
                        t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = es.clone());
                    if (e && e.baseMaterial === t || (e = this._derivedMaterial = function(e) {
                            let t = function e(t, n) {
                                let r = function(e) {
                                        let t = JSON.stringify(e, C),
                                            n = P.get(t);
                                        return null == n && P.set(t, n = ++I), n
                                    }(n),
                                    i = M.get(t);
                                if (i || M.set(t, i = Object.create(null)), i[r]) return new i[r];
                                let s = `_onBeforeCompile${r}`,
                                    o = function(e) {
                                        t.onBeforeCompile.call(this, e);
                                        let i = this.customProgramCacheKey() + "|" + e.vertexShader + "|" + e.fragmentShader,
                                            a = T[i];
                                        if (!a) {
                                            let o = function({
                                                vertexShader: e,
                                                fragmentShader: t
                                            }, n, r) {
                                                let {
                                                    vertexDefs: i,
                                                    vertexMainIntro: a,
                                                    vertexMainOutro: s,
                                                    vertexTransform: o,
                                                    fragmentDefs: l,
                                                    fragmentMainIntro: u,
                                                    fragmentMainOutro: c,
                                                    fragmentColorTransform: h,
                                                    customRewriter: d,
                                                    timeUniform: f
                                                } = n;
                                                if (i = i || "", a = a || "", s = s || "", l = l || "", u = u || "", c = c || "", (o || d) && (e = y(e)), (h || d) && (t = t.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"), t = y(t)), d) {
                                                    let p = d({
                                                        vertexShader: e,
                                                        fragmentShader: t
                                                    });
                                                    e = p.vertexShader, t = p.fragmentShader
                                                }
                                                if (h) {
                                                    let m = [];
                                                    t = t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, e => (m.push(e), "")), c = `${h}
${m.join("\n")}
${c}`
                                                }
                                                if (f) {
                                                    let g = `
uniform float ${f};
`;
                                                    i = g + i, l = g + l
                                                }
                                                return o && (e = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${e}
`, i = `${i}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${o}
}
`, a = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (e, t, n, i) => /\battribute\s+vec[23]\s+$/.test(i.substr(0, n)) ? t : `troika_${t}_${r}`)), e = E(e, r, i, a, s), t = E(t, r, l, u, c), {
                                                    vertexShader: e,
                                                    fragmentShader: t
                                                }
                                            }(e, n, r);
                                            a = T[i] = o
                                        }
                                        e.vertexShader = a.vertexShader, e.fragmentShader = a.fragmentShader, w(e.uniforms, this.uniforms), n.timeUniform && (e.uniforms[n.timeUniform] = {
                                            get value() {
                                                return Date.now() - S
                                            }
                                        }), this[s] && this[s](e)
                                    },
                                    l = function() {
                                        return u(n.chained ? t : t.clone())
                                    },
                                    u = function(e) {
                                        let i = Object.create(e, c);
                                        return Object.defineProperty(i, "baseMaterial", {
                                            value: t
                                        }), Object.defineProperty(i, "id", {
                                            value: A++
                                        }), i.uuid = function() {
                                            let e = 4294967295 * Math.random() | 0,
                                                t = 4294967295 * Math.random() | 0,
                                                n = 4294967295 * Math.random() | 0,
                                                r = 4294967295 * Math.random() | 0,
                                                i = x[255 & e] + x[e >> 8 & 255] + x[e >> 16 & 255] + x[e >> 24 & 255] + "-" + x[255 & t] + x[t >> 8 & 255] + "-" + x[t >> 16 & 15 | 64] + x[t >> 24 & 255] + "-" + x[63 & n | 128] + x[n >> 8 & 255] + "-" + x[n >> 16 & 255] + x[n >> 24 & 255] + x[255 & r] + x[r >> 8 & 255] + x[r >> 16 & 255] + x[r >> 24 & 255];
                                            return i.toUpperCase()
                                        }(), i.uniforms = w({}, e.uniforms, n.uniforms), i.defines = w({}, e.defines, n.defines), i.defines[`TROIKA_DERIVED_MATERIAL_${r}`] = "", i.extensions = w({}, e.extensions, n.extensions), i._listeners = void 0, i
                                    },
                                    c = {
                                        constructor: {
                                            value: l
                                        },
                                        isDerivedMaterial: {
                                            value: !0
                                        },
                                        customProgramCacheKey: {
                                            writable: !0,
                                            configurable: !0,
                                            value: function() {
                                                return t.customProgramCacheKey() + "|" + r
                                            }
                                        },
                                        onBeforeCompile: {
                                            get: () => o,
                                            set(e) {
                                                this[s] = e
                                            }
                                        },
                                        copy: {
                                            writable: !0,
                                            configurable: !0,
                                            value: function(e) {
                                                return t.copy.call(this, e), t.isShaderMaterial || t.isDerivedMaterial || (w(this.extensions, e.extensions), w(this.defines, e.defines), w(this.uniforms, a.UniformsUtils.clone(e.uniforms))), this
                                            }
                                        },
                                        clone: {
                                            writable: !0,
                                            configurable: !0,
                                            value: function() {
                                                let e = new t.constructor;
                                                return u(e).copy(this)
                                            }
                                        },
                                        getDepthMaterial: {
                                            writable: !0,
                                            configurable: !0,
                                            value: function() {
                                                let r = this._depthMaterial;
                                                return r || ((r = this._depthMaterial = e(t.isDerivedMaterial ? t.getDepthMaterial() : new a.MeshDepthMaterial({
                                                    depthPacking: a.RGBADepthPacking
                                                }), n)).defines.IS_DEPTH_MATERIAL = "", r.uniforms = this.uniforms), r
                                            }
                                        },
                                        getDistanceMaterial: {
                                            writable: !0,
                                            configurable: !0,
                                            value: function() {
                                                let r = this._distanceMaterial;
                                                return r || ((r = this._distanceMaterial = e(t.isDerivedMaterial ? t.getDistanceMaterial() : new a.MeshDistanceMaterial, n)).defines.IS_DISTANCE_MATERIAL = "", r.uniforms = this.uniforms), r
                                            }
                                        },
                                        dispose: {
                                            writable: !0,
                                            configurable: !0,
                                            value() {
                                                let {
                                                    _depthMaterial: e,
                                                    _distanceMaterial: n
                                                } = this;
                                                e && e.dispose(), n && n.dispose(), t.dispose.call(this)
                                            }
                                        }
                                    };
                                return i[r] = l, new l
                            }(e, {
                                chained: !0,
                                extensions: {
                                    derivatives: !0
                                },
                                uniforms: {
                                    uTroikaSDFTexture: {
                                        value: null
                                    },
                                    uTroikaSDFTextureSize: {
                                        value: new a.Vector2
                                    },
                                    uTroikaSDFGlyphSize: {
                                        value: 0
                                    },
                                    uTroikaSDFExponent: {
                                        value: 0
                                    },
                                    uTroikaTotalBounds: {
                                        value: new a.Vector4(0, 0, 0, 0)
                                    },
                                    uTroikaClipRect: {
                                        value: new a.Vector4(0, 0, 0, 0)
                                    },
                                    uTroikaDistanceOffset: {
                                        value: 0
                                    },
                                    uTroikaOutlineOpacity: {
                                        value: 0
                                    },
                                    uTroikaFillOpacity: {
                                        value: 1
                                    },
                                    uTroikaPositionOffset: {
                                        value: new a.Vector2
                                    },
                                    uTroikaCurveRadius: {
                                        value: 0
                                    },
                                    uTroikaBlurRadius: {
                                        value: 0
                                    },
                                    uTroikaStrokeWidth: {
                                        value: 0
                                    },
                                    uTroikaStrokeColor: {
                                        value: new a.Color
                                    },
                                    uTroikaStrokeOpacity: {
                                        value: 1
                                    },
                                    uTroikaOrient: {
                                        value: new a.Matrix3
                                    },
                                    uTroikaUseGlyphColors: {
                                        value: !0
                                    },
                                    uTroikaSDFDebug: {
                                        value: !1
                                    }
                                },
                                vertexDefs: en,
                                vertexTransform: er,
                                fragmentDefs: ei,
                                fragmentColorTransform: ea,
                                customRewriter({
                                    vertexShader: e,
                                    fragmentShader: t
                                }) {
                                    let n = /\buniform\s+vec3\s+diffuse\b/;
                                    return n.test(t) && (t = t.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(e) || (e = e.replace(_, "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"))), {
                                        vertexShader: e,
                                        fragmentShader: t
                                    }
                                }
                            });
                            return t.transparent = !0, Object.defineProperties(t, {
                                isTroikaTextMaterial: {
                                    value: !0
                                },
                                shadowSide: {
                                    get() {
                                        return this.side
                                    },
                                    set() {}
                                }
                            }), t
                        }(t), t.addEventListener("dispose", function n() {
                            t.removeEventListener("dispose", n), e.dispose()
                        })), !this.outlineWidth && !this.outlineBlur && !this.outlineOffsetX && !this.outlineOffsetY) return e; {
                        let n = e._outlineMtl;
                        return n || ((n = e._outlineMtl = Object.create(e, {
                            id: {
                                value: e.id + .1
                            }
                        })).isTextOutlineMaterial = !0, n.depthWrite = !1, n.map = null, e.addEventListener("dispose", function t() {
                            e.removeEventListener("dispose", t), n.dispose()
                        })), [n, e]
                    }
                }
                set material(e) {
                    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e
                }
                get glyphGeometryDetail() {
                    return this.geometry.detail
                }
                set glyphGeometryDetail(e) {
                    this.geometry.detail = e
                }
                get curveRadius() {
                    return this.geometry.curveRadius
                }
                set curveRadius(e) {
                    this.geometry.curveRadius = e
                }
                get customDepthMaterial() {
                    return ef(this.material).getDepthMaterial()
                }
                get customDistanceMaterial() {
                    return ef(this.material).getDistanceMaterial()
                }
                _prepareForRender(e) {
                    let t = e.isTextOutlineMaterial,
                        n = e.uniforms,
                        r = this.textRenderInfo;
                    if (r) {
                        let i, s, o;
                        let {
                            sdfTexture: l,
                            blockBounds: u
                        } = r;
                        n.uTroikaSDFTexture.value = l, n.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height), n.uTroikaSDFGlyphSize.value = r.sdfGlyphSize, n.uTroikaSDFExponent.value = r.sdfExponent, n.uTroikaTotalBounds.value.fromArray(u), n.uTroikaUseGlyphColors.value = !t && !!r.glyphColors;
                        let c = 0,
                            h = 0,
                            d = 0,
                            f = 0,
                            p = 0;
                        if (t) {
                            let {
                                outlineWidth: m,
                                outlineOffsetX: g,
                                outlineOffsetY: v,
                                outlineBlur: _,
                                outlineOpacity: y
                            } = this;
                            c = this._parsePercent(m) || 0, h = Math.max(0, this._parsePercent(_) || 0), i = y, f = this._parsePercent(g) || 0, p = this._parsePercent(v) || 0
                        } else(d = Math.max(0, this._parsePercent(this.strokeWidth) || 0)) && (o = this.strokeColor, n.uTroikaStrokeColor.value.set(null == o ? 8421504 : o), null == (s = this.strokeOpacity) && (s = 1)), i = this.fillOpacity;
                        n.uTroikaDistanceOffset.value = c, n.uTroikaPositionOffset.value.set(f, p), n.uTroikaBlurRadius.value = h, n.uTroikaStrokeWidth.value = d, n.uTroikaStrokeOpacity.value = s, n.uTroikaFillOpacity.value = null == i ? 1 : i, n.uTroikaCurveRadius.value = this.curveRadius || 0;
                        let x = this.clipRect;
                        if (x && Array.isArray(x) && 4 === x.length) n.uTroikaClipRect.value.fromArray(x);
                        else {
                            let b = 100 * (this.fontSize || .1);
                            n.uTroikaClipRect.value.set(u[0] - b, u[1] - b, u[2] + b, u[3] + b)
                        }
                        this.geometry.applyClipRect(n.uTroikaClipRect.value)
                    }
                    n.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
                    let w = t ? this.outlineColor || 0 : this.color;
                    if (null == w) delete e.color;
                    else {
                        let S = e.hasOwnProperty("color") ? e.color : e.color = new a.Color;
                        (w !== S._input || "object" == typeof w) && S.set(S._input = w)
                    }
                    let M = this.orientation || ed;
                    if (M !== e._orientation) {
                        let T = n.uTroikaOrient.value,
                            A = (M = M.replace(/[^-+xyz]/g, "")) !== ed && M.match(/^([-+])([xyz])([-+])([xyz])$/);
                        if (A) {
                            let [, E, C, I, P] = A;
                            el.set(0, 0, 0)[C] = "-" === E ? 1 : -1, eu.set(0, 0, 0)[P] = "-" === I ? -1 : 1, eo.lookAt(eh, el.cross(eu), eu), T.setFromMatrix4(eo)
                        } else T.identity();
                        e._orientation = M
                    }
                }
                _parsePercent(e) {
                    if ("string" == typeof e) {
                        let t = e.match(/^(-?[\d.]+)%$/),
                            n = t ? parseFloat(t[1]) : NaN;
                        e = (isNaN(n) ? 0 : n / 100) * this.fontSize
                    }
                    return e
                }
                localPositionToTextCoords(e, t = new a.Vector2) {
                    t.copy(e);
                    let n = this.curveRadius;
                    return n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)), t
                }
                worldPositionToTextCoords(e, t = new a.Vector2) {
                    return el.copy(e), this.localPositionToTextCoords(this.worldToLocal(el), t)
                }
                raycast(e, t) {
                    let {
                        textRenderInfo: n,
                        curveRadius: r
                    } = this;
                    if (n) {
                        let i = n.blockBounds,
                            a = r ? em() : ep(),
                            s = a.geometry,
                            {
                                position: o,
                                uv: l
                            } = s.attributes;
                        for (let u = 0; u < l.count; u++) {
                            let c = i[0] + l.getX(u) * (i[2] - i[0]),
                                h = i[1] + l.getY(u) * (i[3] - i[1]),
                                d = 0;
                            r && (d = r - Math.cos(c / r) * r, c = Math.sin(c / r) * r), o.setXYZ(u, c, h, d)
                        }
                        s.boundingSphere = this.geometry.boundingSphere, s.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, ec.length = 0, a.raycast(e, ec);
                        for (let f = 0; f < ec.length; f++) ec[f].object = this, t.push(ec[f])
                    }
                }
                copy(e) {
                    let t = this.geometry;
                    return super.copy(e), this.geometry = t, ey.forEach(t => {
                        this[t] = e[t]
                    }), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            e_.forEach(e => {
                let t = "_private_" + e;
                Object.defineProperty(ex.prototype, e, {
                    get() {
                        return this[t]
                    },
                    set(e) {
                        e !== this[t] && (this[t] = e, this._needsSync = !0)
                    }
                })
            }), new WeakMap, new WeakMap
        },
        3451: function(e, t, n) {
            var r;
            ! function(i, a) {
                "use strict";
                var s = "function",
                    o = "undefined",
                    l = "object",
                    u = "string",
                    c = "model",
                    h = "name",
                    d = "type",
                    f = "vendor",
                    p = "version",
                    m = "architecture",
                    g = "console",
                    v = "mobile",
                    _ = "tablet",
                    y = "smarttv",
                    x = "wearable",
                    b = "embedded",
                    w = "Amazon",
                    S = "Apple",
                    M = "ASUS",
                    T = "BlackBerry",
                    A = "Browser",
                    E = "Chrome",
                    C = "Firefox",
                    I = "Google",
                    P = "Huawei",
                    R = "Microsoft",
                    L = "Motorola",
                    D = "Opera",
                    k = "Samsung",
                    U = "Sharp",
                    O = "Sony",
                    F = "Xiaomi",
                    N = "Zebra",
                    B = "Facebook",
                    z = function(e, t) {
                        var n = {};
                        for (var r in e) t[r] && t[r].length % 2 == 0 ? n[r] = t[r].concat(e[r]) : n[r] = e[r];
                        return n
                    },
                    G = function(e) {
                        for (var t = {}, n = 0; n < e.length; n++) t[e[n].toUpperCase()] = e[n];
                        return t
                    },
                    V = function(e, t) {
                        return typeof e === u && -1 !== W(t).indexOf(W(e))
                    },
                    W = function(e) {
                        return e.toLowerCase()
                    },
                    H = function(e, t) {
                        if (typeof e === u) return e = e.replace(/^\s\s*/, "").replace(/\s\s*$/, ""), typeof t === o ? e : e.substring(0, 350)
                    },
                    j = function(e, t) {
                        for (var n, r, i, o, u, c, h = 0; h < t.length && !u;) {
                            var d = t[h],
                                f = t[h + 1];
                            for (n = r = 0; n < d.length && !u;)
                                if (u = d[n++].exec(e))
                                    for (i = 0; i < f.length; i++) c = u[++r], typeof(o = f[i]) === l && o.length > 0 ? 2 === o.length ? typeof o[1] == s ? this[o[0]] = o[1].call(this, c) : this[o[0]] = o[1] : 3 === o.length ? typeof o[1] !== s || o[1].exec && o[1].test ? this[o[0]] = c ? c.replace(o[1], o[2]) : a : this[o[0]] = c ? o[1].call(this, c, o[2]) : a : 4 === o.length && (this[o[0]] = c ? o[3].call(this, c.replace(o[1], o[2])) : a) : this[o] = c || a;
                            h += 2
                        }
                    },
                    q = function(e, t) {
                        for (var n in t)
                            if (typeof t[n] === l && t[n].length > 0) {
                                for (var r = 0; r < t[n].length; r++)
                                    if (V(t[n][r], e)) return "?" === n ? a : n
                            } else if (V(t[n], e)) return "?" === n ? a : n;
                        return e
                    },
                    X = {
                        ME: "4.90",
                        "NT 3.11": "NT3.51",
                        "NT 4.0": "NT4.0",
                        2e3: "NT 5.0",
                        XP: ["NT 5.1", "NT 5.2"],
                        Vista: "NT 6.0",
                        7: "NT 6.1",
                        8: "NT 6.2",
                        8.1: "NT 6.3",
                        10: ["NT 6.4", "NT 10.0"],
                        RT: "ARM"
                    },
                    Z = {
                        browser: [
                            [/\b(?:crmo|crios)\/([\w\.]+)/i],
                            [p, [h, "Chrome"]],
                            [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                            [p, [h, "Edge"]],
                            [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i],
                            [h, p],
                            [/opios[\/ ]+([\w\.]+)/i],
                            [p, [h, D + " Mini"]],
                            [/\bopr\/([\w\.]+)/i],
                            [p, [h, D]],
                            [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i],
                            [h, p],
                            [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                            [p, [h, "UC" + A]],
                            [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i],
                            [p, [h, "WeChat(Win) Desktop"]],
                            [/micromessenger\/([\w\.]+)/i],
                            [p, [h, "WeChat"]],
                            [/konqueror\/([\w\.]+)/i],
                            [p, [h, "Konqueror"]],
                            [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                            [p, [h, "IE"]],
                            [/yabrowser\/([\w\.]+)/i],
                            [p, [h, "Yandex"]],
                            [/(avast|avg)\/([\w\.]+)/i],
                            [
                                [h, /(.+)/, "$1 Secure " + A], p
                            ],
                            [/\bfocus\/([\w\.]+)/i],
                            [p, [h, C + " Focus"]],
                            [/\bopt\/([\w\.]+)/i],
                            [p, [h, D + " Touch"]],
                            [/coc_coc\w+\/([\w\.]+)/i],
                            [p, [h, "Coc Coc"]],
                            [/dolfin\/([\w\.]+)/i],
                            [p, [h, "Dolphin"]],
                            [/coast\/([\w\.]+)/i],
                            [p, [h, D + " Coast"]],
                            [/miuibrowser\/([\w\.]+)/i],
                            [p, [h, "MIUI " + A]],
                            [/fxios\/([-\w\.]+)/i],
                            [p, [h, C]],
                            [/\bqihu|(qi?ho?o?|360)browser/i],
                            [
                                [h, "360 " + A]
                            ],
                            [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
                            [
                                [h, /(.+)/, "$1 " + A], p
                            ],
                            [/(comodo_dragon)\/([\w\.]+)/i],
                            [
                                [h, /_/g, " "], p
                            ],
                            [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i],
                            [h, p],
                            [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i],
                            [h],
                            [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
                            [
                                [h, B], p
                            ],
                            [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i],
                            [h, p],
                            [/\bgsa\/([\w\.]+) .*safari\//i],
                            [p, [h, "GSA"]],
                            [/headlesschrome(?:\/([\w\.]+)| )/i],
                            [p, [h, E + " Headless"]],
                            [/ wv\).+(chrome)\/([\w\.]+)/i],
                            [
                                [h, E + " WebView"], p
                            ],
                            [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                            [p, [h, "Android " + A]],
                            [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
                            [h, p],
                            [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                            [p, [h, "Mobile Safari"]],
                            [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                            [p, h],
                            [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                            [h, [p, q, {
                                "1.0": "/8",
                                1.2: "/1",
                                1.3: "/3",
                                "2.0": "/412",
                                "2.0.2": "/416",
                                "2.0.3": "/417",
                                "2.0.4": "/419",
                                "?": "/"
                            }]],
                            [/(webkit|khtml)\/([\w\.]+)/i],
                            [h, p],
                            [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                            [
                                [h, "Netscape"], p
                            ],
                            [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                            [p, [h, C + " Reality"]],
                            [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i],
                            [h, p]
                        ],
                        cpu: [
                            [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                            [
                                [m, "amd64"]
                            ],
                            [/(ia32(?=;))/i],
                            [
                                [m, W]
                            ],
                            [/((?:i[346]|x)86)[;\)]/i],
                            [
                                [m, "ia32"]
                            ],
                            [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                            [
                                [m, "arm64"]
                            ],
                            [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                            [
                                [m, "armhf"]
                            ],
                            [/windows (ce|mobile); ppc;/i],
                            [
                                [m, "arm"]
                            ],
                            [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                            [
                                [m, /ower/, "", W]
                            ],
                            [/(sun4\w)[;\)]/i],
                            [
                                [m, "sparc"]
                            ],
                            [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i],
                            [
                                [m, W]
                            ]
                        ],
                        device: [
                            [/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],
                            [c, [f, k],
                                [d, _]
                            ],
                            [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i],
                            [c, [f, k],
                                [d, v]
                            ],
                            [/\((ip(?:hone|od)[\w ]*);/i],
                            [c, [f, S],
                                [d, v]
                            ],
                            [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i],
                            [c, [f, S],
                                [d, _]
                            ],
                            [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
                            [c, [f, P],
                                [d, _]
                            ],
                            [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],
                            [c, [f, P],
                                [d, v]
                            ],
                            [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i],
                            [
                                [c, /_/g, " "],
                                [f, F],
                                [d, v]
                            ],
                            [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
                            [
                                [c, /_/g, " "],
                                [f, F],
                                [d, _]
                            ],
                            [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],
                            [c, [f, "OPPO"],
                                [d, v]
                            ],
                            [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
                            [c, [f, "Vivo"],
                                [d, v]
                            ],
                            [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
                            [c, [f, "Realme"],
                                [d, v]
                            ],
                            [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],
                            [c, [f, L],
                                [d, v]
                            ],
                            [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                            [c, [f, L],
                                [d, _]
                            ],
                            [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
                            [c, [f, "LG"],
                                [d, _]
                            ],
                            [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i],
                            [c, [f, "LG"],
                                [d, v]
                            ],
                            [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i],
                            [c, [f, "Lenovo"],
                                [d, _]
                            ],
                            [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i],
                            [
                                [c, /_/g, " "],
                                [f, "Nokia"],
                                [d, v]
                            ],
                            [/(pixel c)\b/i],
                            [c, [f, I],
                                [d, _]
                            ],
                            [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                            [c, [f, I],
                                [d, v]
                            ],
                            [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],
                            [c, [f, O],
                                [d, v]
                            ],
                            [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
                            [
                                [c, "Xperia Tablet"],
                                [f, O],
                                [d, _]
                            ],
                            [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],
                            [c, [f, "OnePlus"],
                                [d, v]
                            ],
                            [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i],
                            [c, [f, w],
                                [d, _]
                            ],
                            [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                            [
                                [c, /(.+)/g, "Fire Phone $1"],
                                [f, w],
                                [d, v]
                            ],
                            [/(playbook);[-\w\),; ]+(rim)/i],
                            [c, f, [d, _]],
                            [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
                            [c, [f, T],
                                [d, v]
                            ],
                            [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],
                            [c, [f, M],
                                [d, _]
                            ],
                            [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                            [c, [f, M],
                                [d, v]
                            ],
                            [/(nexus 9)/i],
                            [c, [f, "HTC"],
                                [d, _]
                            ],
                            [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i],
                            [f, [c, /_/g, " "],
                                [d, v]
                            ],
                            [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                            [c, [f, "Acer"],
                                [d, _]
                            ],
                            [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
                            [c, [f, "Meizu"],
                                [d, v]
                            ],
                            [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                            [c, [f, U],
                                [d, v]
                            ],
                            [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i],
                            [f, c, [d, v]],
                            [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i],
                            [f, c, [d, _]],
                            [/(surface duo)/i],
                            [c, [f, R],
                                [d, _]
                            ],
                            [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                            [c, [f, "Fairphone"],
                                [d, v]
                            ],
                            [/(u304aa)/i],
                            [c, [f, "AT&T"],
                                [d, v]
                            ],
                            [/\bsie-(\w*)/i],
                            [c, [f, "Siemens"],
                                [d, v]
                            ],
                            [/\b(rct\w+) b/i],
                            [c, [f, "RCA"],
                                [d, _]
                            ],
                            [/\b(venue[\d ]{2,7}) b/i],
                            [c, [f, "Dell"],
                                [d, _]
                            ],
                            [/\b(q(?:mv|ta)\w+) b/i],
                            [c, [f, "Verizon"],
                                [d, _]
                            ],
                            [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                            [c, [f, "Barnes & Noble"],
                                [d, _]
                            ],
                            [/\b(tm\d{3}\w+) b/i],
                            [c, [f, "NuVision"],
                                [d, _]
                            ],
                            [/\b(k88) b/i],
                            [c, [f, "ZTE"],
                                [d, _]
                            ],
                            [/\b(nx\d{3}j) b/i],
                            [c, [f, "ZTE"],
                                [d, v]
                            ],
                            [/\b(gen\d{3}) b.+49h/i],
                            [c, [f, "Swiss"],
                                [d, v]
                            ],
                            [/\b(zur\d{3}) b/i],
                            [c, [f, "Swiss"],
                                [d, _]
                            ],
                            [/\b((zeki)?tb.*\b) b/i],
                            [c, [f, "Zeki"],
                                [d, _]
                            ],
                            [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
                            [
                                [f, "Dragon Touch"], c, [d, _]
                            ],
                            [/\b(ns-?\w{0,9}) b/i],
                            [c, [f, "Insignia"],
                                [d, _]
                            ],
                            [/\b((nxa|next)-?\w{0,9}) b/i],
                            [c, [f, "NextBook"],
                                [d, _]
                            ],
                            [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                            [
                                [f, "Voice"], c, [d, v]
                            ],
                            [/\b(lvtel\-)?(v1[12]) b/i],
                            [
                                [f, "LvTel"], c, [d, v]
                            ],
                            [/\b(ph-1) /i],
                            [c, [f, "Essential"],
                                [d, v]
                            ],
                            [/\b(v(100md|700na|7011|917g).*\b) b/i],
                            [c, [f, "Envizen"],
                                [d, _]
                            ],
                            [/\b(trio[-\w\. ]+) b/i],
                            [c, [f, "MachSpeed"],
                                [d, _]
                            ],
                            [/\btu_(1491) b/i],
                            [c, [f, "Rotor"],
                                [d, _]
                            ],
                            [/(shield[\w ]+) b/i],
                            [c, [f, "Nvidia"],
                                [d, _]
                            ],
                            [/(sprint) (\w+)/i],
                            [f, c, [d, v]],
                            [/(kin\.[onetw]{3})/i],
                            [
                                [c, /\./g, " "],
                                [f, R],
                                [d, v]
                            ],
                            [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                            [c, [f, N],
                                [d, _]
                            ],
                            [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                            [c, [f, N],
                                [d, v]
                            ],
                            [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
                            [f, c, [d, g]],
                            [/droid.+; (shield) bui/i],
                            [c, [f, "Nvidia"],
                                [d, g]
                            ],
                            [/(playstation [345portablevi]+)/i],
                            [c, [f, O],
                                [d, g]
                            ],
                            [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                            [c, [f, R],
                                [d, g]
                            ],
                            [/smart-tv.+(samsung)/i],
                            [f, [d, y]],
                            [/hbbtv.+maple;(\d+)/i],
                            [
                                [c, /^/, "SmartTV"],
                                [f, k],
                                [d, y]
                            ],
                            [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
                            [
                                [f, "LG"],
                                [d, y]
                            ],
                            [/(apple) ?tv/i],
                            [f, [c, S + " TV"],
                                [d, y]
                            ],
                            [/crkey/i],
                            [
                                [c, E + "cast"],
                                [f, I],
                                [d, y]
                            ],
                            [/droid.+aft(\w)( bui|\))/i],
                            [c, [f, w],
                                [d, y]
                            ],
                            [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
                            [c, [f, U],
                                [d, y]
                            ],
                            [/(bravia[\w ]+)( bui|\))/i],
                            [c, [f, O],
                                [d, y]
                            ],
                            [/(mitv-\w{5}) bui/i],
                            [c, [f, F],
                                [d, y]
                            ],
                            [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i],
                            [
                                [f, H],
                                [c, H],
                                [d, y]
                            ],
                            [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                            [
                                [d, y]
                            ],
                            [/((pebble))app/i],
                            [f, c, [d, x]],
                            [/droid.+; (glass) \d/i],
                            [c, [f, I],
                                [d, x]
                            ],
                            [/droid.+; (wt63?0{2,3})\)/i],
                            [c, [f, N],
                                [d, x]
                            ],
                            [/(quest( 2)?)/i],
                            [c, [f, B],
                                [d, x]
                            ],
                            [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                            [f, [d, b]],
                            [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
                            [c, [d, v]],
                            [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
                            [c, [d, _]],
                            [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                            [
                                [d, _]
                            ],
                            [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],
                            [
                                [d, v]
                            ],
                            [/(android[-\w\. ]{0,9});.+buil/i],
                            [c, [f, "Generic"]]
                        ],
                        engine: [
                            [/windows.+ edge\/([\w\.]+)/i],
                            [p, [h, "EdgeHTML"]],
                            [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                            [p, [h, "Blink"]],
                            [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i],
                            [h, p],
                            [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                            [p, h]
                        ],
                        os: [
                            [/microsoft (windows) (vista|xp)/i],
                            [h, p],
                            [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i],
                            [h, [p, q, X]],
                            [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
                            [
                                [h, "Windows"],
                                [p, q, X]
                            ],
                            [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i],
                            [
                                [p, /_/g, "."],
                                [h, "iOS"]
                            ],
                            [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i],
                            [
                                [h, "Mac OS"],
                                [p, /_/g, "."]
                            ],
                            [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                            [p, h],
                            [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i],
                            [h, p],
                            [/\(bb(10);/i],
                            [p, [h, T]],
                            [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                            [p, [h, "Symbian"]],
                            [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],
                            [p, [h, C + " OS"]],
                            [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
                            [p, [h, "webOS"]],
                            [/crkey\/([\d\.]+)/i],
                            [p, [h, E + "cast"]],
                            [/(cros) [\w]+ ([\w\.]+\w)/i],
                            [
                                [h, "Chromium OS"], p
                            ],
                            [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i],
                            [h, p],
                            [/(sunos) ?([\w\.\d]*)/i],
                            [
                                [h, "Solaris"], p
                            ],
                            [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i],
                            [h, p]
                        ]
                    },
                    Y = function(e, t) {
                        if (typeof e === l && (t = e, e = a), !(this instanceof Y)) return new Y(e, t).getResult();
                        var n = e || (typeof i !== o && i.navigator && i.navigator.userAgent ? i.navigator.userAgent : ""),
                            r = t ? z(Z, t) : Z;
                        return this.getBrowser = function() {
                            var e, t = {};
                            return t[h] = a, t[p] = a, j.call(t, n, r.browser), t.major = typeof(e = t.version) === u ? e.replace(/[^\d\.]/g, "").split(".")[0] : a, t
                        }, this.getCPU = function() {
                            var e = {};
                            return e[m] = a, j.call(e, n, r.cpu), e
                        }, this.getDevice = function() {
                            var e = {};
                            return e[f] = a, e[c] = a, e[d] = a, j.call(e, n, r.device), e
                        }, this.getEngine = function() {
                            var e = {};
                            return e[h] = a, e[p] = a, j.call(e, n, r.engine), e
                        }, this.getOS = function() {
                            var e = {};
                            return e[h] = a, e[p] = a, j.call(e, n, r.os), e
                        }, this.getResult = function() {
                            return {
                                ua: this.getUA(),
                                browser: this.getBrowser(),
                                engine: this.getEngine(),
                                os: this.getOS(),
                                device: this.getDevice(),
                                cpu: this.getCPU()
                            }
                        }, this.getUA = function() {
                            return n
                        }, this.setUA = function(e) {
                            return n = typeof e === u && e.length > 350 ? H(e, 350) : e, this
                        }, this.setUA(n), this
                    };
                Y.VERSION = "1.0.32", Y.BROWSER = G([h, p, "major"]), Y.CPU = G([m]), Y.DEVICE = G([c, f, d, g, v, y, _, x, b]), Y.ENGINE = Y.OS = G([h, p]), typeof t !== o ? (e.exports && (t = e.exports = Y), t.UAParser = Y) : n.amdO ? (r = (function() {
                    return Y
                }).call(t, n, t, e), a !== r && (e.exports = r)) : typeof i !== o && (i.UAParser = Y);
                var $ = typeof i !== o && (i.jQuery || i.Zepto);
                if ($ && !$.ua) {
                    var J = new Y;
                    $.ua = J.getResult(), $.ua.get = function() {
                        return J.getUA()
                    }, $.ua.set = function(e) {
                        J.setUA(e);
                        var t = J.getResult();
                        for (var n in t) $.ua[n] = t[n]
                    }
                }
            }("object" == typeof window ? window : this)
        },
        4671: function(e, t, n) {
            "use strict";
            n.d(t, {
                Z: function() {
                    return s
                }
            });
            var r = n(7294);
            let i = "undefined" == typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
                a = i ? r.useEffect : r.useLayoutEffect;

            function s(e) {
                let t = "function" == typeof e ? function(e) {
                        let t;
                        let n = new Set,
                            r = (e, r) => {
                                let i = "function" == typeof e ? e(t) : e;
                                if (i !== t) {
                                    let a = t;
                                    t = r ? i : Object.assign({}, t, i), n.forEach(e => e(t, a))
                                }
                            },
                            i = () => t,
                            a = (e, r = i, a = Object.is) => {
                                console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
                                let s = r(t);

                                function o() {
                                    let n = r(t);
                                    if (!a(s, n)) {
                                        let i = s;
                                        e(s = n, i)
                                    }
                                }
                                return n.add(o), () => n.delete(o)
                            },
                            s = (e, t, r) => t || r ? a(e, t, r) : (n.add(e), () => n.delete(e)),
                            o = () => n.clear(),
                            l = {
                                setState: r,
                                getState: i,
                                subscribe: s,
                                destroy: o
                            };
                        return t = e(r, i, l), l
                    }(e) : e,
                    n = (e = t.getState, n = Object.is) => {
                        let i;
                        let [, s] = (0, r.useReducer)(e => e + 1, 0), o = t.getState(), l = (0, r.useRef)(o), u = (0, r.useRef)(e), c = (0, r.useRef)(n), h = (0, r.useRef)(!1), d = (0, r.useRef)();
                        void 0 === d.current && (d.current = e(o));
                        let f = !1;
                        (l.current !== o || u.current !== e || c.current !== n || h.current) && (i = e(o), f = !n(d.current, i)), a(() => {
                            f && (d.current = i), l.current = o, u.current = e, c.current = n, h.current = !1
                        });
                        let p = (0, r.useRef)(o);
                        a(() => {
                            let e = () => {
                                    try {
                                        let e = t.getState(),
                                            n = u.current(e);
                                        c.current(d.current, n) || (l.current = e, d.current = n, s())
                                    } catch (r) {
                                        h.current = !0, s()
                                    }
                                },
                                n = t.subscribe(e);
                            return t.getState() !== p.current && e(), n
                        }, []);
                        let m = f ? i : d.current;
                        return (0, r.useDebugValue)(m), m
                    };
                return Object.assign(n, t), n[Symbol.iterator] = function() {
                    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
                    let e = [n, t];
                    return {
                        next() {
                            let t = e.length <= 0;
                            return {
                                value: e.shift(),
                                done: t
                            }
                        }
                    }
                }, n
            }
        },
        8597: function(e, t, n) {
            "use strict";
            n.d(t, {
                XR: function() {
                    return r
                },
                tJ: function() {
                    return h
                }
            }), Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
            let r = e => (t, n, r) => {
                let i = r.subscribe;
                r.subscribe = (e, t, n) => {
                    let a = e;
                    if (t) {
                        let s = (null == n ? void 0 : n.equalityFn) || Object.is,
                            o = e(r.getState());
                        a = n => {
                            let r = e(n);
                            if (!s(o, r)) {
                                let i = o;
                                t(o = r, i)
                            }
                        }, (null == n ? void 0 : n.fireImmediately) && t(o, o)
                    }
                    return i(a)
                };
                let a = e(t, n, r);
                return a
            };
            var i = Object.defineProperty,
                a = Object.getOwnPropertySymbols,
                s = Object.prototype.hasOwnProperty,
                o = Object.prototype.propertyIsEnumerable,
                l = (e, t, n) => t in e ? i(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : e[t] = n,
                u = (e, t) => {
                    for (var n in t || (t = {})) s.call(t, n) && l(e, n, t[n]);
                    if (a)
                        for (var n of a(t)) o.call(t, n) && l(e, n, t[n]);
                    return e
                };
            let c = e => t => {
                    try {
                        let n = e(t);
                        if (n instanceof Promise) return n;
                        return {
                            then: e => c(e)(n),
                            catch (e) {
                                return this
                            }
                        }
                    } catch (r) {
                        return {
                            then(e) {
                                return this
                            },
                            catch: e => c(e)(r)
                        }
                    }
                },
                h = (e, t) => (n, r, i) => {
                    let a, s, o = u({
                        getStorage: () => localStorage,
                        serialize: JSON.stringify,
                        deserialize: JSON.parse,
                        partialize: e => e,
                        version: 0,
                        merge: (e, t) => u(u({}, t), e)
                    }, t);
                    (o.blacklist || o.whitelist) && console.warn(`The ${o.blacklist?"blacklist":"whitelist"} option is deprecated and will be removed in the next version. Please use the 'partialize' option instead.`);
                    let l = !1,
                        h = new Set,
                        d = new Set;
                    try {
                        a = o.getStorage()
                    } catch (f) {}
                    if (!a) return e((...e) => {
                        console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`), n(...e)
                    }, r, i);
                    a.removeItem || console.warn(`[zustand persist middleware] The given storage for item '${o.name}' does not contain a 'removeItem' method, which will be required in v4.`);
                    let p = c(o.serialize),
                        m = () => {
                            let e;
                            let t = o.partialize(u({}, r()));
                            o.whitelist && Object.keys(t).forEach(e => {
                                var n;
                                (null == (n = o.whitelist) ? void 0 : n.includes(e)) || delete t[e]
                            }), o.blacklist && o.blacklist.forEach(e => delete t[e]);
                            let n = p({
                                state: t,
                                version: o.version
                            }).then(e => a.setItem(o.name, e)).catch(t => {
                                e = t
                            });
                            if (e) throw e;
                            return n
                        },
                        g = i.setState;
                    i.setState = (e, t) => {
                        g(e, t), m()
                    };
                    let v = e((...e) => {
                            n(...e), m()
                        }, r, i),
                        _ = () => {
                            var e;
                            if (!a) return;
                            l = !1, h.forEach(e => e(r()));
                            let t = (null == (e = o.onRehydrateStorage) ? void 0 : e.call(o, r())) || void 0;
                            return c(a.getItem.bind(a))(o.name).then(e => {
                                if (e) return o.deserialize(e)
                            }).then(e => {
                                if (e) {
                                    if ("number" != typeof e.version || e.version === o.version) return e.state;
                                    if (o.migrate) return o.migrate(e.state, e.version);
                                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                                }
                            }).then(e => {
                                var t;
                                return n(s = o.merge(e, null != (t = r()) ? t : v), !0), m()
                            }).then(() => {
                                null == t || t(s, void 0), l = !0, d.forEach(e => e(s))
                            }).catch(e => {
                                null == t || t(void 0, e)
                            })
                        };
                    return i.persist = {
                        setOptions: e => {
                            o = u(u({}, o), e), e.getStorage && (a = e.getStorage())
                        },
                        clearStorage: () => {
                            var e;
                            null == (e = null == a ? void 0 : a.removeItem) || e.call(a, o.name)
                        },
                        rehydrate: () => _(),
                        hasHydrated: () => l,
                        onHydrate: e => (h.add(e), () => {
                            h.delete(e)
                        }),
                        onFinishHydration: e => (d.add(e), () => {
                            d.delete(e)
                        })
                    }, _(), s || v
                }
        },
        374: function(e, t, n) {
            "use strict";

            function r(e, t) {
                if (Object.is(e, t)) return !0;
                if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1;
                let n = Object.keys(e);
                if (n.length !== Object.keys(t).length) return !1;
                for (let r = 0; r < n.length; r++)
                    if (!Object.prototype.hasOwnProperty.call(t, n[r]) || !Object.is(e[n[r]], t[n[r]])) return !1;
                return !0
            }
            n.d(t, {
                Z: function() {
                    return r
                }
            })
        },
        7297: function(e, t, n) {
            "use strict";

            function r(e, t) {
                return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
                    raw: {
                        value: Object.freeze(t)
                    }
                }))
            }
            n.d(t, {
                Z: function() {
                    return r
                }
            })
        },
        9477: function(e, t, n) {
            "use strict";
            let r, i, a, s, o;
            n.r(t), n.d(t, {
                ACESFilmicToneMapping: function() {
                    return ea
                },
                AddEquation: function() {
                    return C
                },
                AddOperation: function() {
                    return ee
                },
                AdditiveAnimationBlendMode: function() {
                    return tb
                },
                AdditiveBlending: function() {
                    return M
                },
                AlphaFormat: function() {
                    return eF
                },
                AlwaysDepth: function() {
                    return j
                },
                AlwaysStencilFunc: function() {
                    return tY
                },
                AmbientLight: function() {
                    return cd
                },
                AmbientLightProbe: function() {
                    return cC
                },
                AnimationClip: function() {
                    return uX
                },
                AnimationLoader: function() {
                    return u1
                },
                AnimationMixer: function() {
                    return c7
                },
                AnimationObjectGroup: function() {
                    return c5
                },
                AnimationUtils: function() {
                    return uk
                },
                ArcCurve: function() {
                    return lg
                },
                ArrayCamera: function() {
                    return s$
                },
                ArrowHelper: function() {
                    return hz
                },
                Audio: function() {
                    return cz
                },
                AudioAnalyser: function() {
                    return cq
                },
                AudioContext: function() {
                    return cT
                },
                AudioListener: function() {
                    return cB
                },
                AudioLoader: function() {
                    return cA
                },
                AxesHelper: function() {
                    return hG
                },
                BackSide: function() {
                    return x
                },
                BasicDepthPacking: function() {
                    return tE
                },
                BasicShadowMap: function() {
                    return m
                },
                Bone: function() {
                    return oW
                },
                BooleanKeyframeTrack: function() {
                    return uz
                },
                Box2: function() {
                    return hc
                },
                Box3: function() {
                    return nZ
                },
                Box3Helper: function() {
                    return hF
                },
                BoxBufferGeometry: function() {
                    return hY
                },
                BoxGeometry: function() {
                    return iP
                },
                BoxHelper: function() {
                    return hO
                },
                BufferAttribute: function() {
                    return r0
                },
                BufferGeometry: function() {
                    return iu
                },
                BufferGeometryLoader: function() {
                    return cy
                },
                ByteType: function() {
                    return eE
                },
                Cache: function() {
                    return uZ
                },
                Camera: function() {
                    return iO
                },
                CameraHelper: function() {
                    return hD
                },
                CanvasTexture: function() {
                    return lf
                },
                CapsuleBufferGeometry: function() {
                    return h$
                },
                CapsuleGeometry: function() {
                    return lF
                },
                CatmullRomCurve3: function() {
                    return lw
                },
                CineonToneMapping: function() {
                    return ei
                },
                CircleBufferGeometry: function() {
                    return hJ
                },
                CircleGeometry: function() {
                    return lN
                },
                ClampToEdgeWrapping: function() {
                    return ep
                },
                Clock: function() {
                    return cD
                },
                Color: function() {
                    return nR
                },
                ColorKeyframeTrack: function() {
                    return uG
                },
                ColorManagement: function() {
                    return nM
                },
                CompressedArrayTexture: function() {
                    return ld
                },
                CompressedTexture: function() {
                    return lh
                },
                CompressedTextureLoader: function() {
                    return u2
                },
                ConeBufferGeometry: function() {
                    return hK
                },
                ConeGeometry: function() {
                    return lz
                },
                CubeCamera: function() {
                    return iN
                },
                CubeReflectionMapping: function() {
                    return el
                },
                CubeRefractionMapping: function() {
                    return eu
                },
                CubeTexture: function() {
                    return iB
                },
                CubeTextureLoader: function() {
                    return u4
                },
                CubeUVReflectionMapping: function() {
                    return ed
                },
                CubicBezierCurve: function() {
                    return lA
                },
                CubicBezierCurve3: function() {
                    return lE
                },
                CubicInterpolant: function() {
                    return uO
                },
                CullFaceBack: function() {
                    return d
                },
                CullFaceFront: function() {
                    return f
                },
                CullFaceFrontBack: function() {
                    return p
                },
                CullFaceNone: function() {
                    return h
                },
                Curve: function() {
                    return lp
                },
                CurvePath: function() {
                    return lk
                },
                CustomBlending: function() {
                    return E
                },
                CustomToneMapping: function() {
                    return es
                },
                CylinderBufferGeometry: function() {
                    return hQ
                },
                CylinderGeometry: function() {
                    return lB
                },
                Cylindrical: function() {
                    return hl
                },
                Data3DTexture: function() {
                    return nG
                },
                DataArrayTexture: function() {
                    return nB
                },
                DataTexture: function() {
                    return oC
                },
                DataTexture2DArray: function() {
                    return hX
                },
                DataTexture3D: function() {
                    return hZ
                },
                DataTextureLoader: function() {
                    return u5
                },
                DataUtils: function() {
                    return hH
                },
                DecrementStencilOp: function() {
                    return tN
                },
                DecrementWrapStencilOp: function() {
                    return tz
                },
                DefaultLoadingManager: function() {
                    return u$
                },
                DepthFormat: function() {
                    return eV
                },
                DepthStencilFormat: function() {
                    return eW
                },
                DepthTexture: function() {
                    return s1
                },
                DirectionalLight: function() {
                    return ch
                },
                DirectionalLightHelper: function() {
                    return hP
                },
                DiscreteInterpolant: function() {
                    return uN
                },
                DodecahedronBufferGeometry: function() {
                    return h0
                },
                DodecahedronGeometry: function() {
                    return lV
                },
                DoubleSide: function() {
                    return b
                },
                DstAlphaFactor: function() {
                    return B
                },
                DstColorFactor: function() {
                    return G
                },
                DynamicCopyUsage: function() {
                    return t3
                },
                DynamicDrawUsage: function() {
                    return tJ
                },
                DynamicReadUsage: function() {
                    return t0
                },
                EdgesGeometry: function() {
                    return lX
                },
                EllipseCurve: function() {
                    return lm
                },
                EqualDepth: function() {
                    return Z
                },
                EqualStencilFunc: function() {
                    return tH
                },
                EquirectangularReflectionMapping: function() {
                    return ec
                },
                EquirectangularRefractionMapping: function() {
                    return eh
                },
                Euler: function() {
                    return rw
                },
                EventDispatcher: function() {
                    return t7
                },
                ExtrudeBufferGeometry: function() {
                    return h1
                },
                ExtrudeGeometry: function() {
                    return ui
                },
                FileLoader: function() {
                    return u0
                },
                Float16BufferAttribute: function() {
                    return r7
                },
                Float32BufferAttribute: function() {
                    return r9
                },
                Float64BufferAttribute: function() {
                    return ie
                },
                FloatType: function() {
                    return eL
                },
                Fog: function() {
                    return s9
                },
                FogExp2: function() {
                    return s7
                },
                FramebufferTexture: function() {
                    return lc
                },
                FrontSide: function() {
                    return y
                },
                Frustum: function() {
                    return iX
                },
                GLBufferAttribute: function() {
                    return hr
                },
                GLSL1: function() {
                    return t5
                },
                GLSL3: function() {
                    return t6
                },
                GreaterDepth: function() {
                    return $
                },
                GreaterEqualDepth: function() {
                    return Y
                },
                GreaterEqualStencilFunc: function() {
                    return tZ
                },
                GreaterStencilFunc: function() {
                    return tq
                },
                GridHelper: function() {
                    return hT
                },
                Group: function() {
                    return sK
                },
                HalfFloatType: function() {
                    return eD
                },
                HemisphereLight: function() {
                    return u7
                },
                HemisphereLightHelper: function() {
                    return hM
                },
                HemisphereLightProbe: function() {
                    return cE
                },
                IcosahedronBufferGeometry: function() {
                    return h2
                },
                IcosahedronGeometry: function() {
                    return us
                },
                ImageBitmapLoader: function() {
                    return cM
                },
                ImageLoader: function() {
                    return u3
                },
                ImageUtils: function() {
                    return nL
                },
                ImmediateRenderObject: function() {
                    return hj
                },
                IncrementStencilOp: function() {
                    return tF
                },
                IncrementWrapStencilOp: function() {
                    return tB
                },
                InstancedBufferAttribute: function() {
                    return oO
                },
                InstancedBufferGeometry: function() {
                    return c_
                },
                InstancedInterleavedBuffer: function() {
                    return hn
                },
                InstancedMesh: function() {
                    return o0
                },
                InstancedSkinnedMesh: function() {
                    return oV
                },
                Int16BufferAttribute: function() {
                    return r4
                },
                Int32BufferAttribute: function() {
                    return r6
                },
                Int8BufferAttribute: function() {
                    return r1
                },
                IntType: function() {
                    return eP
                },
                InterleavedBuffer: function() {
                    return ot
                },
                InterleavedBufferAttribute: function() {
                    return or
                },
                Interpolant: function() {
                    return uU
                },
                InterpolateDiscrete: function() {
                    return tp
                },
                InterpolateLinear: function() {
                    return tm
                },
                InterpolateSmooth: function() {
                    return tg
                },
                InvertStencilOp: function() {
                    return tG
                },
                KeepStencilOp: function() {
                    return tU
                },
                KeyframeTrack: function() {
                    return uB
                },
                LOD: function() {
                    return ob
                },
                LatheBufferGeometry: function() {
                    return h3
                },
                LatheGeometry: function() {
                    return lO
                },
                Layers: function() {
                    return rS
                },
                LessDepth: function() {
                    return q
                },
                LessEqualDepth: function() {
                    return X
                },
                LessEqualStencilFunc: function() {
                    return tj
                },
                LessStencilFunc: function() {
                    return tW
                },
                Light: function() {
                    return u8
                },
                LightProbe: function() {
                    return cm
                },
                Line: function() {
                    return o8
                },
                Line3: function() {
                    return hf
                },
                LineBasicMaterial: function() {
                    return o1
                },
                LineCurve: function() {
                    return lC
                },
                LineCurve3: function() {
                    return lI
                },
                LineDashedMaterial: function() {
                    return uE
                },
                LineLoop: function() {
                    return lt
                },
                LineSegments: function() {
                    return le
                },
                LinearEncoding: function() {
                    return tT
                },
                LinearFilter: function() {
                    return eb
                },
                LinearInterpolant: function() {
                    return uF
                },
                LinearMipMapLinearFilter: function() {
                    return eT
                },
                LinearMipMapNearestFilter: function() {
                    return eS
                },
                LinearMipmapLinearFilter: function() {
                    return eM
                },
                LinearMipmapNearestFilter: function() {
                    return ew
                },
                LinearSRGBColorSpace: function() {
                    return tD
                },
                LinearToneMapping: function() {
                    return en
                },
                Loader: function() {
                    return uJ
                },
                LoaderUtils: function() {
                    return cv
                },
                LoadingManager: function() {
                    return uY
                },
                LoopOnce: function() {
                    return th
                },
                LoopPingPong: function() {
                    return tf
                },
                LoopRepeat: function() {
                    return td
                },
                LuminanceAlphaFormat: function() {
                    return eG
                },
                LuminanceFormat: function() {
                    return ez
                },
                MOUSE: function() {
                    return u
                },
                Material: function() {
                    return r$
                },
                MaterialLoader: function() {
                    return cg
                },
                MathUtils: function() {
                    return nf
                },
                Matrix3: function() {
                    return nm
                },
                Matrix4: function() {
                    return rd
                },
                MaxEquation: function() {
                    return L
                },
                Mesh: function() {
                    return iC
                },
                MeshBasicMaterial: function() {
                    return rJ
                },
                MeshDepthMaterial: function() {
                    return sW
                },
                MeshDistanceMaterial: function() {
                    return sH
                },
                MeshLambertMaterial: function() {
                    return uT
                },
                MeshMatcapMaterial: function() {
                    return uA
                },
                MeshNormalMaterial: function() {
                    return uM
                },
                MeshPhongMaterial: function() {
                    return uw
                },
                MeshPhysicalMaterial: function() {
                    return ub
                },
                MeshStandardMaterial: function() {
                    return ux
                },
                MeshToonMaterial: function() {
                    return uS
                },
                MetaMesh: function() {
                    return oR
                },
                MetaSkinnedMesh: function() {
                    return oU
                },
                MinEquation: function() {
                    return R
                },
                MirroredRepeatWrapping: function() {
                    return em
                },
                MixOperation: function() {
                    return Q
                },
                MultiplyBlending: function() {
                    return A
                },
                MultiplyOperation: function() {
                    return K
                },
                NearestFilter: function() {
                    return eg
                },
                NearestMipMapLinearFilter: function() {
                    return ex
                },
                NearestMipMapNearestFilter: function() {
                    return e_
                },
                NearestMipmapLinearFilter: function() {
                    return ey
                },
                NearestMipmapNearestFilter: function() {
                    return ev
                },
                NeverDepth: function() {
                    return H
                },
                NeverStencilFunc: function() {
                    return tV
                },
                NoBlending: function() {
                    return w
                },
                NoColorSpace: function() {
                    return tR
                },
                NoToneMapping: function() {
                    return et
                },
                NormalAnimationBlendMode: function() {
                    return tx
                },
                NormalBlending: function() {
                    return S
                },
                NotEqualDepth: function() {
                    return J
                },
                NotEqualStencilFunc: function() {
                    return tX
                },
                NumberKeyframeTrack: function() {
                    return uV
                },
                Object3D: function() {
                    return rF
                },
                ObjectLoader: function() {
                    return cx
                },
                ObjectSpaceNormalMap: function() {
                    return tP
                },
                OctahedronBufferGeometry: function() {
                    return h4
                },
                OctahedronGeometry: function() {
                    return uo
                },
                OneFactor: function() {
                    return k
                },
                OneMinusDstAlphaFactor: function() {
                    return z
                },
                OneMinusDstColorFactor: function() {
                    return V
                },
                OneMinusSrcAlphaFactor: function() {
                    return N
                },
                OneMinusSrcColorFactor: function() {
                    return O
                },
                OrthographicCamera: function() {
                    return i8
                },
                PCFShadowMap: function() {
                    return g
                },
                PCFSoftShadowMap: function() {
                    return v
                },
                PMREMGenerator: function() {
                    return aa
                },
                Path: function() {
                    return lU
                },
                PerspectiveCamera: function() {
                    return iF
                },
                Plane: function() {
                    return iH
                },
                PlaneBufferGeometry: function() {
                    return h5
                },
                PlaneGeometry: function() {
                    return i$
                },
                PlaneHelper: function() {
                    return hN
                },
                PointLight: function() {
                    return cu
                },
                PointLightHelper: function() {
                    return hx
                },
                Points: function() {
                    return lo
                },
                PointsMaterial: function() {
                    return ln
                },
                PolarGridHelper: function() {
                    return hA
                },
                PolyhedronBufferGeometry: function() {
                    return h6
                },
                PolyhedronGeometry: function() {
                    return lG
                },
                PositionalAudio: function() {
                    return cj
                },
                PropertyBinding: function() {
                    return c4
                },
                PropertyMixer: function() {
                    return cX
                },
                QuadraticBezierCurve: function() {
                    return lP
                },
                QuadraticBezierCurve3: function() {
                    return lR
                },
                Quaternion: function() {
                    return nH
                },
                QuaternionKeyframeTrack: function() {
                    return uH
                },
                QuaternionLinearInterpolant: function() {
                    return uW
                },
                REVISION: function() {
                    return l
                },
                RGBADepthPacking: function() {
                    return tC
                },
                RGBAFormat: function() {
                    return eB
                },
                RGBAIntegerFormat: function() {
                    return eZ
                },
                RGBA_ASTC_10x10_Format: function() {
                    return to
                },
                RGBA_ASTC_10x5_Format: function() {
                    return ti
                },
                RGBA_ASTC_10x6_Format: function() {
                    return ta
                },
                RGBA_ASTC_10x8_Format: function() {
                    return ts
                },
                RGBA_ASTC_12x10_Format: function() {
                    return tl
                },
                RGBA_ASTC_12x12_Format: function() {
                    return tu
                },
                RGBA_ASTC_4x4_Format: function() {
                    return e6
                },
                RGBA_ASTC_5x4_Format: function() {
                    return e8
                },
                RGBA_ASTC_5x5_Format: function() {
                    return e7
                },
                RGBA_ASTC_6x5_Format: function() {
                    return e9
                },
                RGBA_ASTC_6x6_Format: function() {
                    return te
                },
                RGBA_ASTC_8x5_Format: function() {
                    return tt
                },
                RGBA_ASTC_8x6_Format: function() {
                    return tn
                },
                RGBA_ASTC_8x8_Format: function() {
                    return tr
                },
                RGBA_BPTC_Format: function() {
                    return tc
                },
                RGBA_ETC2_EAC_Format: function() {
                    return e5
                },
                RGBA_PVRTC_2BPPV1_Format: function() {
                    return e2
                },
                RGBA_PVRTC_4BPPV1_Format: function() {
                    return e1
                },
                RGBA_S3TC_DXT1_Format: function() {
                    return e$
                },
                RGBA_S3TC_DXT3_Format: function() {
                    return eJ
                },
                RGBA_S3TC_DXT5_Format: function() {
                    return eK
                },
                RGBFormat: function() {
                    return eN
                },
                RGB_ETC1_Format: function() {
                    return e3
                },
                RGB_ETC2_Format: function() {
                    return e4
                },
                RGB_PVRTC_2BPPV1_Format: function() {
                    return e0
                },
                RGB_PVRTC_4BPPV1_Format: function() {
                    return eQ
                },
                RGB_S3TC_DXT1_Format: function() {
                    return eY
                },
                RGFormat: function() {
                    return eq
                },
                RGIntegerFormat: function() {
                    return eX
                },
                RawShaderMaterial: function() {
                    return uy
                },
                Ray: function() {
                    return rh
                },
                Raycaster: function() {
                    return hi
                },
                RectAreaLight: function() {
                    return cf
                },
                RedFormat: function() {
                    return eH
                },
                RedIntegerFormat: function() {
                    return ej
                },
                ReinhardToneMapping: function() {
                    return er
                },
                RepeatWrapping: function() {
                    return ef
                },
                ReplaceStencilOp: function() {
                    return tO
                },
                ReverseSubtractEquation: function() {
                    return P
                },
                RingBufferGeometry: function() {
                    return h8
                },
                RingGeometry: function() {
                    return ul
                },
                SRGBColorSpace: function() {
                    return tL
                },
                Scene: function() {
                    return oe
                },
                ShaderChunk: function() {
                    return iJ
                },
                ShaderLib: function() {
                    return iQ
                },
                ShaderMaterial: function() {
                    return iU
                },
                ShadowMaterial: function() {
                    return u_
                },
                Shape: function() {
                    return lZ
                },
                ShapeBufferGeometry: function() {
                    return h7
                },
                ShapeGeometry: function() {
                    return uu
                },
                ShapePath: function() {
                    return hV
                },
                ShapeUtils: function() {
                    return ut
                },
                ShortType: function() {
                    return eC
                },
                Skeleton: function() {
                    return oq
                },
                SkeletonHelper: function() {
                    return hy
                },
                SkinnedMesh: function() {
                    return oE
                },
                Source: function() {
                    return nD
                },
                Sphere: function() {
                    return rr
                },
                SphereBufferGeometry: function() {
                    return h9
                },
                SphereGeometry: function() {
                    return uc
                },
                Spherical: function() {
                    return ho
                },
                SphericalHarmonics3: function() {
                    return cp
                },
                SplineCurve: function() {
                    return lL
                },
                SpotLight: function() {
                    return ci
                },
                SpotLightHelper: function() {
                    return hm
                },
                Sprite: function() {
                    return ov
                },
                SpriteMaterial: function() {
                    return oi
                },
                SrcAlphaFactor: function() {
                    return F
                },
                SrcAlphaSaturateFactor: function() {
                    return W
                },
                SrcColorFactor: function() {
                    return U
                },
                StaticCopyUsage: function() {
                    return t2
                },
                StaticDrawUsage: function() {
                    return t$
                },
                StaticReadUsage: function() {
                    return tQ
                },
                StereoCamera: function() {
                    return cL
                },
                StreamCopyUsage: function() {
                    return t4
                },
                StreamDrawUsage: function() {
                    return tK
                },
                StreamReadUsage: function() {
                    return t1
                },
                StringKeyframeTrack: function() {
                    return uj
                },
                SubtractEquation: function() {
                    return I
                },
                SubtractiveBlending: function() {
                    return T
                },
                TOUCH: function() {
                    return c
                },
                TangentSpaceNormalMap: function() {
                    return tI
                },
                TetrahedronBufferGeometry: function() {
                    return de
                },
                TetrahedronGeometry: function() {
                    return uh
                },
                Texture: function() {
                    return nO
                },
                TextureLoader: function() {
                    return u6
                },
                TorusBufferGeometry: function() {
                    return dt
                },
                TorusGeometry: function() {
                    return ud
                },
                TorusKnotBufferGeometry: function() {
                    return dn
                },
                TorusKnotGeometry: function() {
                    return uf
                },
                Triangle: function() {
                    return rZ
                },
                TriangleFanDrawMode: function() {
                    return tM
                },
                TriangleStripDrawMode: function() {
                    return tS
                },
                TrianglesDrawMode: function() {
                    return tw
                },
                TubeBufferGeometry: function() {
                    return dr
                },
                TubeGeometry: function() {
                    return up
                },
                UVMapping: function() {
                    return eo
                },
                Uint16BufferAttribute: function() {
                    return r5
                },
                Uint32BufferAttribute: function() {
                    return r8
                },
                Uint8BufferAttribute: function() {
                    return r2
                },
                Uint8ClampedBufferAttribute: function() {
                    return r3
                },
                Uniform: function() {
                    return c9
                },
                UniformsGroup: function() {
                    return ht
                },
                UniformsLib: function() {
                    return iK
                },
                UniformsUtils: function() {
                    return ik
                },
                UnsignedByteType: function() {
                    return eA
                },
                UnsignedInt248Type: function() {
                    return eO
                },
                UnsignedIntType: function() {
                    return eR
                },
                UnsignedShort4444Type: function() {
                    return ek
                },
                UnsignedShort5551Type: function() {
                    return eU
                },
                UnsignedShortType: function() {
                    return eI
                },
                VSMShadowMap: function() {
                    return _
                },
                Vector2: function() {
                    return np
                },
                Vector3: function() {
                    return nj
                },
                Vector4: function() {
                    return nF
                },
                VectorKeyframeTrack: function() {
                    return uq
                },
                VideoTexture: function() {
                    return lu
                },
                WebGL1Renderer: function() {
                    return s8
                },
                WebGL3DRenderTarget: function() {
                    return nV
                },
                WebGLArrayRenderTarget: function() {
                    return nz
                },
                WebGLCubeRenderTarget: function() {
                    return iz
                },
                WebGLMultipleRenderTargets: function() {
                    return nW
                },
                WebGLMultisampleRenderTarget: function() {
                    return hq
                },
                WebGLRenderTarget: function() {
                    return nN
                },
                WebGLRenderer: function() {
                    return s5
                },
                WebGLTransformFeedback: function() {
                    return s6
                },
                WebGLUtils: function() {
                    return sY
                },
                WireframeGeometry: function() {
                    return um
                },
                WrapAroundEnding: function() {
                    return ty
                },
                ZeroCurvatureEnding: function() {
                    return tv
                },
                ZeroFactor: function() {
                    return D
                },
                ZeroSlopeEnding: function() {
                    return t_
                },
                ZeroStencilOp: function() {
                    return tk
                },
                _SRGBAFormat: function() {
                    return t8
                },
                sRGBEncoding: function() {
                    return tA
                }
            });
            /**
             * @license
             * Copyright 2010-2022 Three.js Authors
             * SPDX-License-Identifier: MIT
             */
            let l = "145",
                u = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                },
                c = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                h = 0,
                d = 1,
                f = 2,
                p = 3,
                m = 0,
                g = 1,
                v = 2,
                _ = 3,
                y = 0,
                x = 1,
                b = 2,
                w = 0,
                S = 1,
                M = 2,
                T = 3,
                A = 4,
                E = 5,
                C = 100,
                I = 101,
                P = 102,
                R = 103,
                L = 104,
                D = 200,
                k = 201,
                U = 202,
                O = 203,
                F = 204,
                N = 205,
                B = 206,
                z = 207,
                G = 208,
                V = 209,
                W = 210,
                H = 0,
                j = 1,
                q = 2,
                X = 3,
                Z = 4,
                Y = 5,
                $ = 6,
                J = 7,
                K = 0,
                Q = 1,
                ee = 2,
                et = 0,
                en = 1,
                er = 2,
                ei = 3,
                ea = 4,
                es = 5,
                eo = 300,
                el = 301,
                eu = 302,
                ec = 303,
                eh = 304,
                ed = 306,
                ef = 1e3,
                ep = 1001,
                em = 1002,
                eg = 1003,
                ev = 1004,
                e_ = 1004,
                ey = 1005,
                ex = 1005,
                eb = 1006,
                ew = 1007,
                eS = 1007,
                eM = 1008,
                eT = 1008,
                eA = 1009,
                eE = 1010,
                eC = 1011,
                eI = 1012,
                eP = 1013,
                eR = 1014,
                eL = 1015,
                eD = 1016,
                ek = 1017,
                eU = 1018,
                eO = 1020,
                eF = 1021,
                eN = 1022,
                eB = 1023,
                ez = 1024,
                eG = 1025,
                eV = 1026,
                eW = 1027,
                eH = 1028,
                ej = 1029,
                eq = 1030,
                eX = 1031,
                eZ = 1033,
                eY = 33776,
                e$ = 33777,
                eJ = 33778,
                eK = 33779,
                eQ = 35840,
                e0 = 35841,
                e1 = 35842,
                e2 = 35843,
                e3 = 36196,
                e4 = 37492,
                e5 = 37496,
                e6 = 37808,
                e8 = 37809,
                e7 = 37810,
                e9 = 37811,
                te = 37812,
                tt = 37813,
                tn = 37814,
                tr = 37815,
                ti = 37816,
                ta = 37817,
                ts = 37818,
                to = 37819,
                tl = 37820,
                tu = 37821,
                tc = 36492,
                th = 2200,
                td = 2201,
                tf = 2202,
                tp = 2300,
                tm = 2301,
                tg = 2302,
                tv = 2400,
                t_ = 2401,
                ty = 2402,
                tx = 2500,
                tb = 2501,
                tw = 0,
                tS = 1,
                tM = 2,
                tT = 3e3,
                tA = 3001,
                tE = 3200,
                tC = 3201,
                tI = 0,
                tP = 1,
                tR = "",
                tL = "srgb",
                tD = "srgb-linear",
                tk = 0,
                tU = 7680,
                tO = 7681,
                tF = 7682,
                tN = 7683,
                tB = 34055,
                tz = 34056,
                tG = 5386,
                tV = 512,
                tW = 513,
                tH = 514,
                tj = 515,
                tq = 516,
                tX = 517,
                tZ = 518,
                tY = 519,
                t$ = 35044,
                tJ = 35048,
                tK = 35040,
                tQ = 35045,
                t0 = 35049,
                t1 = 35041,
                t2 = 35046,
                t3 = 35050,
                t4 = 35042,
                t5 = "100",
                t6 = "300 es",
                t8 = 1035;
            class t7 {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    let n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return !1;
                    let n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return;
                    let n = this._listeners,
                        r = n[e];
                    if (void 0 !== r) {
                        let i = r.indexOf(t); - 1 !== i && r.splice(i, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return;
                    let t = this._listeners,
                        n = t[e.type];
                    if (void 0 !== n) {
                        e.target = this;
                        let r = n.slice(0);
                        for (let i = 0, a = r.length; i < a; i++) r[i].call(this, e);
                        e.target = null
                    }
                }
            }
            let t9 = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
                ne = 1234567,
                nt = Math.PI / 180,
                nn = 180 / Math.PI;

            function nr() {
                let e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0,
                    i = t9[255 & e] + t9[e >> 8 & 255] + t9[e >> 16 & 255] + t9[e >> 24 & 255] + "-" + t9[255 & t] + t9[t >> 8 & 255] + "-" + t9[t >> 16 & 15 | 64] + t9[t >> 24 & 255] + "-" + t9[63 & n | 128] + t9[n >> 8 & 255] + "-" + t9[n >> 16 & 255] + t9[n >> 24 & 255] + t9[255 & r] + t9[r >> 8 & 255] + t9[r >> 16 & 255] + t9[r >> 24 & 255];
                return i.toLowerCase()
            }

            function ni(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }

            function na(e, t) {
                return (e % t + t) % t
            }

            function ns(e, t, n) {
                return (1 - n) * e + n * t
            }

            function no(e, t, n, r) {
                return ns(e, t, 1 - Math.exp(-n * r))
            }

            function nl(e) {
                return (e & e - 1) == 0 && 0 !== e
            }

            function nu(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }

            function nc(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }

            function nh(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw Error("Invalid component type.")
                }
            }

            function nd(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint16Array:
                        return Math.round(65535 * e);
                    case Uint8Array:
                        return Math.round(255 * e);
                    case Int16Array:
                        return Math.round(32767 * e);
                    case Int8Array:
                        return Math.round(127 * e);
                    default:
                        throw Error("Invalid component type.")
                }
            }
            var nf = Object.freeze({
                __proto__: null,
                DEG2RAD: nt,
                RAD2DEG: nn,
                generateUUID: nr,
                clamp: ni,
                euclideanModulo: na,
                mapLinear: function(e, t, n, r, i) {
                    return r + (e - t) * (i - r) / (n - t)
                },
                inverseLerp: function(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                },
                lerp: ns,
                damp: no,
                pingpong: function(e, t = 1) {
                    return t - Math.abs(na(e, 2 * t) - t)
                },
                smoothstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    void 0 !== e && (ne = e);
                    let t = ne += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, 1 | t), (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 4294967296
                },
                degToRad: function(e) {
                    return e * nt
                },
                radToDeg: function(e) {
                    return e * nn
                },
                isPowerOfTwo: nl,
                ceilPowerOfTwo: nu,
                floorPowerOfTwo: nc,
                setQuaternionFromProperEuler: function(e, t, n, r, i) {
                    let a = Math.cos,
                        s = Math.sin,
                        o = a(n / 2),
                        l = s(n / 2),
                        u = a((t + r) / 2),
                        c = s((t + r) / 2),
                        h = a((t - r) / 2),
                        d = s((t - r) / 2),
                        f = a((r - t) / 2),
                        p = s((r - t) / 2);
                    switch (i) {
                        case "XYX":
                            e.set(o * c, l * h, l * d, o * u);
                            break;
                        case "YZY":
                            e.set(l * d, o * c, l * h, o * u);
                            break;
                        case "ZXZ":
                            e.set(l * h, l * d, o * c, o * u);
                            break;
                        case "XZX":
                            e.set(o * c, l * p, l * f, o * u);
                            break;
                        case "YXY":
                            e.set(l * f, o * c, l * p, o * u);
                            break;
                        case "ZYZ":
                            e.set(l * p, l * f, o * c, o * u);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                    }
                },
                normalize: nd,
                denormalize: nh
            });
            class np {
                constructor(e = 0, t = 0) {
                    np.prototype.isVector2 = !0, this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    let t = this.x,
                        n = this.y,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    let n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    let e = Math.atan2(-this.y, -this.x) + Math.PI;
                    return e
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    let t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    let n = Math.cos(t),
                        r = Math.sin(t),
                        i = this.x - e.x,
                        a = this.y - e.y;
                    return this.x = i * n - a * r + e.x, this.y = i * r + a * n + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            class nm {
                constructor() {
                    nm.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
                }
                set(e, t, n, r, i, a, s, o, l) {
                    let u = this.elements;
                    return u[0] = e, u[1] = r, u[2] = s, u[3] = t, u[4] = i, u[5] = o, u[6] = n, u[7] = a, u[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(e) {
                    let t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    let t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    let n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        a = n[0],
                        s = n[3],
                        o = n[6],
                        l = n[1],
                        u = n[4],
                        c = n[7],
                        h = n[2],
                        d = n[5],
                        f = n[8],
                        p = r[0],
                        m = r[3],
                        g = r[6],
                        v = r[1],
                        _ = r[4],
                        y = r[7],
                        x = r[2],
                        b = r[5],
                        w = r[8];
                    return i[0] = a * p + s * v + o * x, i[3] = a * m + s * _ + o * b, i[6] = a * g + s * y + o * w, i[1] = l * p + u * v + c * x, i[4] = l * m + u * _ + c * b, i[7] = l * g + u * y + c * w, i[2] = h * p + d * v + f * x, i[5] = h * m + d * _ + f * b, i[8] = h * g + d * y + f * w, this
                }
                multiplyScalar(e) {
                    let t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    let e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        u = e[8];
                    return t * a * u - t * s * l - n * i * u + n * s * o + r * i * l - r * a * o
                }
                invert() {
                    let e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        u = e[8],
                        c = u * a - s * l,
                        h = s * o - u * i,
                        d = l * i - a * o,
                        f = t * c + n * h + r * d;
                    if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let p = 1 / f;
                    return e[0] = c * p, e[1] = (r * l - u * n) * p, e[2] = (s * n - r * a) * p, e[3] = h * p, e[4] = (u * t - r * o) * p, e[5] = (r * i - s * t) * p, e[6] = d * p, e[7] = (n * o - l * t) * p, e[8] = (a * t - n * i) * p, this
                }
                transpose() {
                    let e;
                    let t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    let t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, n, r, i, a, s) {
                    let o = Math.cos(i),
                        l = Math.sin(i);
                    return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -r * l, r * o, -r * (-l * a + o * s) + s + t, 0, 0, 1), this
                }
                scale(e, t) {
                    return this.premultiply(ng.makeScale(e, t)), this
                }
                rotate(e) {
                    return this.premultiply(ng.makeRotation(-e)), this
                }
                translate(e, t) {
                    return this.premultiply(ng.makeTranslation(e, t)), this
                }
                makeTranslation(e, t) {
                    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
                }
                makeRotation(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
                }
                makeScale(e, t) {
                    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
                }
                equals(e) {
                    let t = this.elements,
                        n = e.elements;
                    for (let r = 0; r < 9; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    let n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
                clone() {
                    return new this.constructor().fromArray(this.elements)
                }
            }
            let ng = new nm;

            function nv(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] >= 65535) return !0;
                return !1
            }
            let n_ = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function ny(e, t) {
                return new n_[e](t)
            }

            function nx(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }

            function nb(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function nw(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            let nS = {
                    [tL]: {
                        [tD]: nb
                    },
                    [tD]: {
                        [tL]: nw
                    }
                },
                nM = {
                    legacyMode: !0,
                    get workingColorSpace() {
                        return tD
                    },
                    set workingColorSpace(colorSpace) {
                        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                    },
                    convert: function(e, t, n) {
                        if (this.legacyMode || t === n || !t || !n) return e;
                        if (nS[t] && void 0 !== nS[t][n]) {
                            let r = nS[t][n];
                            return e.r = r(e.r), e.g = r(e.g), e.b = r(e.b), e
                        }
                        throw Error("Unsupported color space conversion.")
                    },
                    fromWorkingColorSpace: function(e, t) {
                        return this.convert(e, this.workingColorSpace, t)
                    },
                    toWorkingColorSpace: function(e, t) {
                        return this.convert(e, t, this.workingColorSpace)
                    }
                },
                nT = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                nA = {
                    r: 0,
                    g: 0,
                    b: 0
                },
                nE = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                nC = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function nI(e, t, n) {
                return (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6) ? e + (t - e) * 6 * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e
            }

            function nP(e, t) {
                return t.r = e.r, t.g = e.g, t.b = e.b, t
            }
            class nR {
                constructor(e, t, n) {
                    if (this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n) return this.set(e);
                    return this.setRGB(e, t, n)
                }
                set(e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e, t = tL) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, nM.toWorkingColorSpace(this, t), this
                }
                setRGB(e, t, n, r = nM.workingColorSpace) {
                    return this.r = e, this.g = t, this.b = n, nM.toWorkingColorSpace(this, r), this
                }
                setHSL(e, t, n, r = nM.workingColorSpace) {
                    if (e = na(e, 1), t = ni(t, 0, 1), n = ni(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                    else {
                        let i = n <= .5 ? n * (1 + t) : n + t - n * t,
                            a = 2 * n - i;
                        this.r = nI(a, i, e + 1 / 3), this.g = nI(a, i, e), this.b = nI(a, i, e - 1 / 3)
                    }
                    return nM.toWorkingColorSpace(this, r), this
                }
                setStyle(e, t = tL) {
                    let n;

                    function r(t) {
                        void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                        let i;
                        let a = n[1],
                            s = n[2];
                        switch (a) {
                            case "rgb":
                            case "rgba":
                                if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, nM.toWorkingColorSpace(this, t), r(i[4]), this;
                                if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, nM.toWorkingColorSpace(this, t), r(i[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                    let o = parseFloat(i[1]) / 360,
                                        l = parseFloat(i[2]) / 100,
                                        u = parseFloat(i[3]) / 100;
                                    return r(i[4]), this.setHSL(o, l, u, t)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        let c = n[1],
                            h = c.length;
                        if (3 === h) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, nM.toWorkingColorSpace(this, t), this;
                        if (6 === h) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, nM.toWorkingColorSpace(this, t), this
                    }
                    return e && e.length > 0 ? this.setColorName(e, t) : this
                }
                setColorName(e, t = tL) {
                    let n = nT[e.toLowerCase()];
                    return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copySRGBToLinear(e) {
                    return this.r = nb(e.r), this.g = nb(e.g), this.b = nb(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = nw(e.r), this.g = nw(e.g), this.b = nw(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(e = tL) {
                    return nM.fromWorkingColorSpace(nP(this, nA), e), ni(255 * nA.r, 0, 255) << 16 ^ ni(255 * nA.g, 0, 255) << 8 ^ ni(255 * nA.b, 0, 255) << 0
                }
                getHexString(e = tL) {
                    return ("000000" + this.getHex(e).toString(16)).slice(-6)
                }
                getHSL(e, t = nM.workingColorSpace) {
                    let n, r;
                    nM.fromWorkingColorSpace(nP(this, nA), t);
                    let i = nA.r,
                        a = nA.g,
                        s = nA.b,
                        o = Math.max(i, a, s),
                        l = Math.min(i, a, s),
                        u = (l + o) / 2;
                    if (l === o) n = 0, r = 0;
                    else {
                        let c = o - l;
                        switch (r = u <= .5 ? c / (o + l) : c / (2 - o - l), o) {
                            case i:
                                n = (a - s) / c + (a < s ? 6 : 0);
                                break;
                            case a:
                                n = (s - i) / c + 2;
                                break;
                            case s:
                                n = (i - a) / c + 4
                        }
                        n /= 6
                    }
                    return e.h = n, e.s = r, e.l = u, e
                }
                getRGB(e, t = nM.workingColorSpace) {
                    return nM.fromWorkingColorSpace(nP(this, nA), t), e.r = nA.r, e.g = nA.g, e.b = nA.b, e
                }
                getStyle(e = tL) {
                    return (nM.fromWorkingColorSpace(nP(this, nA), e), e !== tL) ? `color(${e} ${nA.r} ${nA.g} ${nA.b})` : `rgb(${255*nA.r|0},${255*nA.g|0},${255*nA.b|0})`
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(nE), nE.h += e, nE.s += t, nE.l += n, this.setHSL(nE.h, nE.s, nE.l), this
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpColors(e, t, n) {
                    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
                }
                lerpHSL(e, t) {
                    this.getHSL(nE), e.getHSL(nC);
                    let n = ns(nE.h, nC.h, t),
                        r = ns(nE.s, nC.s, t),
                        i = ns(nE.l, nC.l, t);
                    return this.setHSL(n, r, i), this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
                }
                toJSON() {
                    return this.getHex()
                }*[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b
                }
            }
            nR.NAMES = nT;
            class nL {
                static getDataURL(e) {
                    let t;
                    if (/^data:/i.test(e.src) || "undefined" == typeof HTMLCanvasElement) return e.src;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === r && (r = nx("canvas")), r.width = e.width, r.height = e.height;
                        let n = r.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = r
                    }
                    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        let t = nx("canvas");
                        t.width = e.width, t.height = e.height;
                        let n = t.getContext("2d");
                        n.drawImage(e, 0, 0, e.width, e.height);
                        let r = n.getImageData(0, 0, e.width, e.height),
                            i = r.data;
                        for (let a = 0; a < i.length; a++) i[a] = 255 * nb(i[a] / 255);
                        return n.putImageData(r, 0, 0), t
                    }
                    if (!e.data) return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e; {
                        let s = e.data.slice(0);
                        for (let o = 0; o < s.length; o++) s instanceof Uint8Array || s instanceof Uint8ClampedArray ? s[o] = Math.floor(255 * nb(s[o] / 255)) : s[o] = nb(s[o]);
                        return {
                            data: s,
                            width: e.width,
                            height: e.height
                        }
                    }
                }
            }
            class nD {
                constructor(e = null) {
                    this.isSource = !0, this.uuid = nr(), this.data = e, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                    let n = {
                            uuid: this.uuid,
                            url: ""
                        },
                        r = this.data;
                    if (null !== r) {
                        let i;
                        if (Array.isArray(r)) {
                            i = [];
                            for (let a = 0, s = r.length; a < s; a++) r[a].isDataTexture ? i.push(nk(r[a].image)) : i.push(nk(r[a]))
                        } else i = nk(r);
                        n.url = i
                    }
                    return t || (e.images[this.uuid] = n), n
                }
            }

            function nk(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? nL.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            let nU = 0;
            class nO extends t7 {
                constructor(e = nO.DEFAULT_IMAGE, t = nO.DEFAULT_MAPPING, n = ep, r = ep, i = eb, a = eM, s = eB, o = eA, l = nO.DEFAULT_ANISOTROPY, u = tT) {
                    super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                        value: nU++
                    }), this.uuid = nr(), this.name = "", this.source = new nD(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new np(0, 0), this.repeat = new np(1, 1), this.center = new np(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new nm, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                }
                get image() {
                    return this.source.data
                }
                set image(e) {
                    this.source.data = e
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    let n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(e).uuid,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (this.mapping !== eo) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case ef:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case ep:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case em:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case ef:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case ep:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case em:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
                set needsUpdate(e) {
                    !0 === e && (this.version++, this.source.needsUpdate = !0)
                }
            }
            nO.DEFAULT_IMAGE = null, nO.DEFAULT_MAPPING = eo, nO.DEFAULT_ANISOTROPY = 4;
            class nF {
                constructor(e = 0, t = 0, n = 0, r = 1) {
                    nF.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, r) {
                    return this.x = e, this.y = t, this.z = n, this.w = r, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        a = e.elements;
                    return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    let t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, r;
                    let i = e.elements,
                        a = i[0],
                        s = i[4],
                        o = i[8],
                        l = i[1],
                        u = i[5],
                        c = i[9],
                        h = i[2],
                        d = i[6],
                        f = i[10];
                    if (.01 > Math.abs(s - l) && .01 > Math.abs(o - h) && .01 > Math.abs(c - d)) {
                        if (.1 > Math.abs(s + l) && .1 > Math.abs(o + h) && .1 > Math.abs(c + d) && .1 > Math.abs(a + u + f - 3)) return this.set(1, 0, 0, 0), this;
                        let p = (a + 1) / 2,
                            m = (u + 1) / 2,
                            g = (f + 1) / 2,
                            v = (s + l) / 4,
                            _ = (o + h) / 4,
                            y = (c + d) / 4;
                        return p > m && p > g ? p < .01 ? (t = 0, n = .707106781, r = .707106781) : (n = v / (t = Math.sqrt(p)), r = _ / t) : m > g ? m < .01 ? (t = .707106781, n = 0, r = .707106781) : (t = v / (n = Math.sqrt(m)), r = y / n) : g < .01 ? (t = .707106781, n = .707106781, r = 0) : (t = _ / (r = Math.sqrt(g)), n = y / r), this.set(t, n, r, Math.PI), this
                    }
                    let x = Math.sqrt((d - c) * (d - c) + (o - h) * (o - h) + (l - s) * (l - s));
                    return .001 > Math.abs(x) && (x = 1), this.x = (d - c) / x, this.y = (o - h) / x, this.z = (l - s) / x, this.w = Math.acos((a + u + f - 1) / 2), this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    let n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            class nN extends t7 {
                constructor(e, t, n = {}) {
                    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new nF(0, 0, e, t), this.scissorTest = !1, this.viewport = new nF(0, 0, e, t), this.texture = new nO({
                        width: e,
                        height: t,
                        depth: 1
                    }, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : eb, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0
                }
                setSize(e, t, n = 1) {
                    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
                    let t = Object.assign({}, e.texture.image);
                    return this.texture.source = new nD(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class nB extends nO {
                constructor(e = null, t = 1, n = 1, r = 1) {
                    super(null), this.isDataArrayTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    }, this.magFilter = eg, this.minFilter = eg, this.wrapR = ep, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class nz extends nN {
                constructor(e, t, n) {
                    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new nB(null, e, t, n), this.texture.isRenderTargetTexture = !0
                }
            }
            class nG extends nO {
                constructor(e = null, t = 1, n = 1, r = 1) {
                    super(null), this.isData3DTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    }, this.magFilter = eg, this.minFilter = eg, this.wrapR = ep, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class nV extends nN {
                constructor(e, t, n) {
                    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new nG(null, e, t, n), this.texture.isRenderTargetTexture = !0
                }
            }
            class nW extends nN {
                constructor(e, t, n, r = {}) {
                    super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
                    let i = this.texture;
                    this.texture = [];
                    for (let a = 0; a < n; a++) this.texture[a] = i.clone(), this.texture[a].isRenderTargetTexture = !0
                }
                setSize(e, t, n = 1) {
                    if (this.width !== e || this.height !== t || this.depth !== n) {
                        this.width = e, this.height = t, this.depth = n;
                        for (let r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;
                        this.dispose()
                    }
                    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                copy(e) {
                    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
                    for (let t = 0, n = e.texture.length; t < n; t++) {
                        this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
                        let r = Object.assign({}, e.texture.image);
                        this.texture[t].source = new nD(r)
                    }
                    return this
                }
            }
            class nH {
                constructor(e = 0, t = 0, n = 0, r = 1) {
                    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r
                }
                static slerpFlat(e, t, n, r, i, a, s) {
                    let o = n[r + 0],
                        l = n[r + 1],
                        u = n[r + 2],
                        c = n[r + 3],
                        h = i[a + 0],
                        d = i[a + 1],
                        f = i[a + 2],
                        p = i[a + 3];
                    if (0 === s) {
                        e[t + 0] = o, e[t + 1] = l, e[t + 2] = u, e[t + 3] = c;
                        return
                    }
                    if (1 === s) {
                        e[t + 0] = h, e[t + 1] = d, e[t + 2] = f, e[t + 3] = p;
                        return
                    }
                    if (c !== p || o !== h || l !== d || u !== f) {
                        let m = 1 - s,
                            g = o * h + l * d + u * f + c * p,
                            v = g >= 0 ? 1 : -1,
                            _ = 1 - g * g;
                        if (_ > Number.EPSILON) {
                            let y = Math.sqrt(_),
                                x = Math.atan2(y, g * v);
                            m = Math.sin(m * x) / y, s = Math.sin(s * x) / y
                        }
                        let b = s * v;
                        if (o = o * m + h * b, l = l * m + d * b, u = u * m + f * b, c = c * m + p * b, m === 1 - s) {
                            let w = 1 / Math.sqrt(o * o + l * l + u * u + c * c);
                            o *= w, l *= w, u *= w, c *= w
                        }
                    }
                    e[t] = o, e[t + 1] = l, e[t + 2] = u, e[t + 3] = c
                }
                static multiplyQuaternionsFlat(e, t, n, r, i, a) {
                    let s = n[r],
                        o = n[r + 1],
                        l = n[r + 2],
                        u = n[r + 3],
                        c = i[a],
                        h = i[a + 1],
                        d = i[a + 2],
                        f = i[a + 3];
                    return e[t] = s * f + u * c + o * d - l * h, e[t + 1] = o * f + u * h + l * c - s * d, e[t + 2] = l * f + u * d + s * h - o * c, e[t + 3] = u * f - s * c - o * h - l * d, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t) {
                    let n = e._x,
                        r = e._y,
                        i = e._z,
                        a = e._order,
                        s = Math.cos,
                        o = Math.sin,
                        l = s(n / 2),
                        u = s(r / 2),
                        c = s(i / 2),
                        h = o(n / 2),
                        d = o(r / 2),
                        f = o(i / 2);
                    switch (a) {
                        case "XYZ":
                            this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                            break;
                        case "YXZ":
                            this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                            break;
                        case "ZXY":
                            this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                            break;
                        case "ZYX":
                            this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                            break;
                        case "YZX":
                            this._x = h * u * c + l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c - h * d * f;
                            break;
                        case "XZY":
                            this._x = h * u * c - l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c + h * d * f;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                    }
                    return !1 !== t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    let n = t / 2,
                        r = Math.sin(n);
                    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    let t = e.elements,
                        n = t[0],
                        r = t[4],
                        i = t[8],
                        a = t[1],
                        s = t[5],
                        o = t[9],
                        l = t[2],
                        u = t[6],
                        c = t[10],
                        h = n + s + c;
                    if (h > 0) {
                        let d = .5 / Math.sqrt(h + 1);
                        this._w = .25 / d, this._x = (u - o) * d, this._y = (i - l) * d, this._z = (a - r) * d
                    } else if (n > s && n > c) {
                        let f = 2 * Math.sqrt(1 + n - s - c);
                        this._w = (u - o) / f, this._x = .25 * f, this._y = (r + a) / f, this._z = (i + l) / f
                    } else if (s > c) {
                        let p = 2 * Math.sqrt(1 + s - n - c);
                        this._w = (i - l) / p, this._x = (r + a) / p, this._y = .25 * p, this._z = (o + u) / p
                    } else {
                        let m = 2 * Math.sqrt(1 + c - n - s);
                        this._w = (a - r) / m, this._x = (i + l) / m, this._y = (o + u) / m, this._z = .25 * m
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(ni(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    let n = this.angleTo(e);
                    return 0 === n || this.slerp(e, Math.min(1, t / n)), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e) {
                    return this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    let n = e._x,
                        r = e._y,
                        i = e._z,
                        a = e._w,
                        s = t._x,
                        o = t._y,
                        l = t._z,
                        u = t._w;
                    return this._x = n * u + a * s + r * l - i * o, this._y = r * u + a * o + i * s - n * l, this._z = i * u + a * l + n * o - r * s, this._w = a * u - n * s - r * o - i * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    let n = this._x,
                        r = this._y,
                        i = this._z,
                        a = this._w,
                        s = a * e._w + n * e._x + r * e._y + i * e._z;
                    if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this;
                    let o = 1 - s * s;
                    if (o <= Number.EPSILON) {
                        let l = 1 - t;
                        return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * r + t * this._y, this._z = l * i + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    let u = Math.sqrt(o),
                        c = Math.atan2(u, s),
                        h = Math.sin((1 - t) * c) / u,
                        d = Math.sin(t * c) / u;
                    return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = r * h + this._y * d, this._z = i * h + this._z * d, this._onChangeCallback(), this
                }
                slerpQuaternions(e, t, n) {
                    return this.copy(e).slerp(t, n)
                }
                damp(e, t, n) {
                    this.slerp(e, 1 - Math.exp(-t * n))
                }
                random() {
                    let e = Math.random(),
                        t = Math.sqrt(1 - e),
                        n = Math.sqrt(e),
                        r = 2 * Math.PI * Math.random(),
                        i = 2 * Math.PI * Math.random();
                    return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._w
                }
            }
            class nj {
                constructor(e = 0, t = 0, n = 0) {
                    nj.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return this.applyQuaternion(nX.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(nX.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements,
                        a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a, this
                }
                applyQuaternion(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.x,
                        a = e.y,
                        s = e.z,
                        o = e.w,
                        l = o * t + a * r - s * n,
                        u = o * n + s * t - i * r,
                        c = o * r + i * n - a * t,
                        h = -i * t - a * n - s * r;
                    return this.x = l * o + -(h * i) + -(u * s) - -(c * a), this.y = u * o + -(h * a) + -(c * i) - -(l * s), this.z = c * o + -(h * s) + -(l * a) - -(u * i), this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    let t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    let n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                damp(e, t, n) {
                    this.x = no(this.x, e.x, t, n), this.y = no(this.y, e.y, t, n), this.z = no(this.z, e.z, t, n)
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                }
                cross(e) {
                    return this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z,
                        a = t.x,
                        s = t.y,
                        o = t.z;
                    return this.x = r * o - i * s, this.y = i * a - n * o, this.z = n * s - r * a, this
                }
                projectOnVector(e) {
                    let t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    let n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return nq.copy(this).projectOnVector(e), this.sub(nq)
                }
                reflect(e) {
                    return this.sub(nq.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    let t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    let n = this.dot(e) / t;
                    return Math.acos(ni(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    let t = this.x - e.x,
                        n = this.y - e.y,
                        r = this.z - e.z;
                    return t * t + n * n + r * r
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    let r = Math.sin(t) * e;
                    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    let t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    let t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = r, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                setFromEuler(e) {
                    return this.x = e._x, this.y = e._y, this.z = e._z, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    let e = (Math.random() - .5) * 2,
                        t = Math.random() * Math.PI * 2,
                        n = Math.sqrt(1 - e ** 2);
                    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            let nq = new nj,
                nX = new nH;
            class nZ {
                constructor(e = new nj(Infinity, Infinity, Infinity), t = new nj(-1 / 0, -1 / 0, -1 / 0)) {
                    this.isBox3 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    let t = Infinity,
                        n = Infinity,
                        r = Infinity,
                        i = -1 / 0,
                        a = -1 / 0,
                        s = -1 / 0;
                    for (let o = 0, l = e.length; o < l; o += 3) {
                        let u = e[o],
                            c = e[o + 1],
                            h = e[o + 2];
                        u < t && (t = u), c < n && (n = c), h < r && (r = h), u > i && (i = u), c > a && (a = c), h > s && (s = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, a, s), this
                }
                setFromBufferAttribute(e) {
                    let t = Infinity,
                        n = Infinity,
                        r = Infinity,
                        i = -1 / 0,
                        a = -1 / 0,
                        s = -1 / 0;
                    for (let o = 0, l = e.count; o < l; o++) {
                        let u = e.getX(o),
                            c = e.getY(o),
                            h = e.getZ(o);
                        u < t && (t = u), c < n && (n = c), h < r && (r = h), u > i && (i = u), c > a && (a = c), h > s && (s = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, a, s), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    let n = n$.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                setFromObject(e, t = !1) {
                    return this.makeEmpty(), this.expandByObject(e, t)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e, t = !1) {
                    e.updateWorldMatrix(!1, !1);
                    let n = e.geometry;
                    if (null === e.boundingBox) {
                        if (t && void 0 != n.attributes && void 0 !== n.attributes.position) {
                            let r = n.attributes.position;
                            for (let i = 0, a = r.count; i < a; i++) n$.fromBufferAttribute(r, i).applyMatrix4(e.matrixWorld), this.expandByPoint(n$)
                        } else null === e.boundingBox && e.computeBoundingBox(), nJ.copy(e.boundingBox), nJ.applyMatrix4(e.matrixWorld), this.union(nJ)
                    } else void 0 !== n && (null === n.boundingBox && n.computeBoundingBox(), nJ.copy(n.boundingBox), nJ.applyMatrix4(e.matrixWorld), this.union(nJ));
                    let s = e.children;
                    for (let o = 0, l = s.length; o < l; o++) this.expandByObject(s[o], t);
                    return this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x) && !(e.x > this.max.x) && !(e.y < this.min.y) && !(e.y > this.max.y) && !(e.z < this.min.z) && !(e.z > this.max.z)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x) && !(e.min.x > this.max.x) && !(e.max.y < this.min.y) && !(e.min.y > this.max.y) && !(e.max.z < this.min.z) && !(e.min.z > this.max.z)
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, n$), n$.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(n4), n5.subVectors(this.max, n4), nK.subVectors(e.a, n4), nQ.subVectors(e.b, n4), n0.subVectors(e.c, n4), n1.subVectors(nQ, nK), n2.subVectors(n0, nQ), n3.subVectors(nK, n0);
                    let t = [0, -n1.z, n1.y, 0, -n2.z, n2.y, 0, -n3.z, n3.y, n1.z, 0, -n1.x, n2.z, 0, -n2.x, n3.z, 0, -n3.x, -n1.y, n1.x, 0, -n2.y, n2.x, 0, -n3.y, n3.x, 0];
                    return !!(n7(t, nK, nQ, n0, n5) && n7(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], nK, nQ, n0, n5)) && (n6.crossVectors(n1, n2), n7(t = [n6.x, n6.y, n6.z], nK, nQ, n0, n5))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    let t = n$.copy(e).clamp(this.min, this.max);
                    return t.sub(e).length()
                }
                getBoundingSphere(e) {
                    return this.getCenter(e.center), e.radius = .5 * this.getSize(n$).length(), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (nY[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), nY[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), nY[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), nY[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), nY[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), nY[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), nY[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), nY[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(nY)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            let nY = [new nj, new nj, new nj, new nj, new nj, new nj, new nj, new nj],
                n$ = new nj,
                nJ = new nZ,
                nK = new nj,
                nQ = new nj,
                n0 = new nj,
                n1 = new nj,
                n2 = new nj,
                n3 = new nj,
                n4 = new nj,
                n5 = new nj,
                n6 = new nj,
                n8 = new nj;

            function n7(e, t, n, r, i) {
                for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                    n8.fromArray(e, a);
                    let o = i.x * Math.abs(n8.x) + i.y * Math.abs(n8.y) + i.z * Math.abs(n8.z),
                        l = t.dot(n8),
                        u = n.dot(n8),
                        c = r.dot(n8);
                    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > o) return !1
                }
                return !0
            }
            let n9 = new nZ,
                re = new nj,
                rt = new nj,
                rn = new nj;
            class rr {
                constructor(e = new nj, t = -1) {
                    this.center = e, this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    let n = this.center;
                    void 0 !== t ? n.copy(t) : n9.setFromPoints(e).getCenter(n);
                    let r = 0;
                    for (let i = 0, a = e.length; i < a; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                    return this.radius = Math.sqrt(r), this
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    let t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    let n = this.center.distanceToSquared(e);
                    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                expandByPoint(e) {
                    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                    rn.subVectors(e, this.center);
                    let t = rn.lengthSq();
                    if (t > this.radius * this.radius) {
                        let n = Math.sqrt(t),
                            r = (n - this.radius) * .5;
                        this.center.add(rn.multiplyScalar(r / n)), this.radius += r
                    }
                    return this
                }
                union(e) {
                    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? rt.set(0, 0, 1).multiplyScalar(e.radius) : rt.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(re.copy(e.center).add(rt)), this.expandByPoint(re.copy(e.center).sub(rt)), this)
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let ri = new nj,
                ra = new nj,
                rs = new nj,
                ro = new nj,
                rl = new nj,
                ru = new nj,
                rc = new nj;
            class rh {
                constructor(e = new nj, t = new nj(0, 0, -1)) {
                    this.origin = e, this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, ri)), this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    let n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    let t = ri.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (ri.copy(this.direction).multiplyScalar(t).add(this.origin), ri.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, r) {
                    let i, a, s, o;
                    ra.copy(e).add(t).multiplyScalar(.5), rs.copy(t).sub(e).normalize(), ro.copy(this.origin).sub(ra);
                    let l = .5 * e.distanceTo(t),
                        u = -this.direction.dot(rs),
                        c = ro.dot(this.direction),
                        h = -ro.dot(rs),
                        d = ro.lengthSq(),
                        f = Math.abs(1 - u * u);
                    if (f > 0) {
                        if (i = u * h - c, a = u * c - h, o = l * f, i >= 0) {
                            if (a >= -o) {
                                if (a <= o) {
                                    let p = 1 / f;
                                    i *= p, a *= p, s = i * (i + u * a + 2 * c) + a * (u * i + a + 2 * h) + d
                                } else s = -(i = Math.max(0, -(u * (a = l) + c))) * i + a * (a + 2 * h) + d
                            } else s = -(i = Math.max(0, -(u * (a = -l) + c))) * i + a * (a + 2 * h) + d
                        } else a <= -o ? (a = (i = Math.max(0, -(-u * l + c))) > 0 ? -l : Math.min(Math.max(-l, -h), l), s = -i * i + a * (a + 2 * h) + d) : a <= o ? (i = 0, s = (a = Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d) : (a = (i = Math.max(0, -(u * l + c))) > 0 ? l : Math.min(Math.max(-l, -h), l), s = -i * i + a * (a + 2 * h) + d)
                    } else a = u > 0 ? -l : l, s = -(i = Math.max(0, -(u * a + c))) * i + a * (a + 2 * h) + d;
                    return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(rs).multiplyScalar(a).add(ra), s
                }
                intersectSphere(e, t) {
                    ri.subVectors(e.center, this.origin);
                    let n = ri.dot(this.direction),
                        r = ri.dot(ri) - n * n,
                        i = e.radius * e.radius;
                    if (r > i) return null;
                    let a = Math.sqrt(i - r),
                        s = n - a,
                        o = n + a;
                    return s < 0 && o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    let t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    let n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    let n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    let t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    let n = e.normal.dot(this.direction);
                    return n * t < 0
                }
                intersectBox(e, t) {
                    let n, r, i, a, s, o;
                    let l = 1 / this.direction.x,
                        u = 1 / this.direction.y,
                        c = 1 / this.direction.z,
                        h = this.origin;
                    return (l >= 0 ? (n = (e.min.x - h.x) * l, r = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, r = (e.min.x - h.x) * l), u >= 0 ? (i = (e.min.y - h.y) * u, a = (e.max.y - h.y) * u) : (i = (e.max.y - h.y) * u, a = (e.min.y - h.y) * u), n > a || i > r) ? null : ((i > n || n != n) && (n = i), (a < r || r != r) && (r = a), c >= 0 ? (s = (e.min.z - h.z) * c, o = (e.max.z - h.z) * c) : (s = (e.max.z - h.z) * c, o = (e.min.z - h.z) * c), n > o || s > r) ? null : ((s > n || n != n) && (n = s), (o < r || r != r) && (r = o), r < 0) ? null : this.at(n >= 0 ? n : r, t)
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, ri)
                }
                intersectTriangle(e, t, n, r, i) {
                    let a;
                    rl.subVectors(t, e), ru.subVectors(n, e), rc.crossVectors(rl, ru);
                    let s = this.direction.dot(rc);
                    if (s > 0) {
                        if (r) return null;
                        a = 1
                    } else {
                        if (!(s < 0)) return null;
                        a = -1, s = -s
                    }
                    ro.subVectors(this.origin, e);
                    let o = a * this.direction.dot(ru.crossVectors(ro, ru));
                    if (o < 0) return null;
                    let l = a * this.direction.dot(rl.cross(ro));
                    if (l < 0 || o + l > s) return null;
                    let u = -a * ro.dot(rc);
                    return u < 0 ? null : this.at(u / s, i)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class rd {
                constructor() {
                    rd.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                }
                set(e, t, n, r, i, a, s, o, l, u, c, h, d, f, p, m) {
                    let g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = u, g[10] = c, g[14] = h, g[3] = d, g[7] = f, g[11] = p, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return new rd().fromArray(this.elements)
                }
                copy(e) {
                    let t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                }
                copyPosition(e) {
                    let t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                }
                setFromMatrix3(e) {
                    let t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    let t = this.elements,
                        n = e.elements,
                        r = 1 / rf.setFromMatrixColumn(e, 0).length(),
                        i = 1 / rf.setFromMatrixColumn(e, 1).length(),
                        a = 1 / rf.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    let t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z,
                        a = Math.cos(n),
                        s = Math.sin(n),
                        o = Math.cos(r),
                        l = Math.sin(r),
                        u = Math.cos(i),
                        c = Math.sin(i);
                    if ("XYZ" === e.order) {
                        let h = a * u,
                            d = a * c,
                            f = s * u,
                            p = s * c;
                        t[0] = o * u, t[4] = -o * c, t[8] = l, t[1] = d + f * l, t[5] = h - p * l, t[9] = -s * o, t[2] = p - h * l, t[6] = f + d * l, t[10] = a * o
                    } else if ("YXZ" === e.order) {
                        let m = o * u,
                            g = o * c,
                            v = l * u,
                            _ = l * c;
                        t[0] = m + _ * s, t[4] = v * s - g, t[8] = a * l, t[1] = a * c, t[5] = a * u, t[9] = -s, t[2] = g * s - v, t[6] = _ + m * s, t[10] = a * o
                    } else if ("ZXY" === e.order) {
                        let y = o * u,
                            x = o * c,
                            b = l * u,
                            w = l * c;
                        t[0] = y - w * s, t[4] = -a * c, t[8] = b + x * s, t[1] = x + b * s, t[5] = a * u, t[9] = w - y * s, t[2] = -a * l, t[6] = s, t[10] = a * o
                    } else if ("ZYX" === e.order) {
                        let S = a * u,
                            M = a * c,
                            T = s * u,
                            A = s * c;
                        t[0] = o * u, t[4] = T * l - M, t[8] = S * l + A, t[1] = o * c, t[5] = A * l + S, t[9] = M * l - T, t[2] = -l, t[6] = s * o, t[10] = a * o
                    } else if ("YZX" === e.order) {
                        let E = a * o,
                            C = a * l,
                            I = s * o,
                            P = s * l;
                        t[0] = o * u, t[4] = P - E * c, t[8] = I * c + C, t[1] = c, t[5] = a * u, t[9] = -s * u, t[2] = -l * u, t[6] = C * c + I, t[10] = E - P * c
                    } else if ("XZY" === e.order) {
                        let R = a * o,
                            L = a * l,
                            D = s * o,
                            k = s * l;
                        t[0] = o * u, t[4] = -c, t[8] = l * u, t[1] = R * c + k, t[5] = a * u, t[9] = L * c - D, t[2] = D * c - L, t[6] = s * u, t[10] = k * c + R
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(rm, e, rg)
                }
                lookAt(e, t, n) {
                    let r = this.elements;
                    return ry.subVectors(e, t), 0 === ry.lengthSq() && (ry.z = 1), ry.normalize(), rv.crossVectors(n, ry), 0 === rv.lengthSq() && (1 === Math.abs(n.z) ? ry.x += 1e-4 : ry.z += 1e-4, ry.normalize(), rv.crossVectors(n, ry)), rv.normalize(), r_.crossVectors(ry, rv), r[0] = rv.x, r[4] = r_.x, r[8] = ry.x, r[1] = rv.y, r[5] = r_.y, r[9] = ry.y, r[2] = rv.z, r[6] = r_.z, r[10] = ry.z, this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    let n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        a = n[0],
                        s = n[4],
                        o = n[8],
                        l = n[12],
                        u = n[1],
                        c = n[5],
                        h = n[9],
                        d = n[13],
                        f = n[2],
                        p = n[6],
                        m = n[10],
                        g = n[14],
                        v = n[3],
                        _ = n[7],
                        y = n[11],
                        x = n[15],
                        b = r[0],
                        w = r[4],
                        S = r[8],
                        M = r[12],
                        T = r[1],
                        A = r[5],
                        E = r[9],
                        C = r[13],
                        I = r[2],
                        P = r[6],
                        R = r[10],
                        L = r[14],
                        D = r[3],
                        k = r[7],
                        U = r[11],
                        O = r[15];
                    return i[0] = a * b + s * T + o * I + l * D, i[4] = a * w + s * A + o * P + l * k, i[8] = a * S + s * E + o * R + l * U, i[12] = a * M + s * C + o * L + l * O, i[1] = u * b + c * T + h * I + d * D, i[5] = u * w + c * A + h * P + d * k, i[9] = u * S + c * E + h * R + d * U, i[13] = u * M + c * C + h * L + d * O, i[2] = f * b + p * T + m * I + g * D, i[6] = f * w + p * A + m * P + g * k, i[10] = f * S + p * E + m * R + g * U, i[14] = f * M + p * C + m * L + g * O, i[3] = v * b + _ * T + y * I + x * D, i[7] = v * w + _ * A + y * P + x * k, i[11] = v * S + _ * E + y * R + x * U, i[15] = v * M + _ * C + y * L + x * O, this
                }
                multiplyScalar(e) {
                    let t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    let e = this.elements,
                        t = e[0],
                        n = e[4],
                        r = e[8],
                        i = e[12],
                        a = e[1],
                        s = e[5],
                        o = e[9],
                        l = e[13],
                        u = e[2],
                        c = e[6],
                        h = e[10],
                        d = e[14],
                        f = e[3],
                        p = e[7],
                        m = e[11],
                        g = e[15];
                    return f * (+i * o * c - r * l * c - i * s * h + n * l * h + r * s * d - n * o * d) + p * (+t * o * d - t * l * h + i * a * h - r * a * d + r * l * u - i * o * u) + m * (+t * l * c - t * s * d - i * a * c + n * a * d + i * s * u - n * l * u) + g * (-r * s * u - t * o * c + t * s * h + r * a * c - n * a * h + n * o * u)
                }
                transpose() {
                    let e;
                    let t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(e, t, n) {
                    let r = this.elements;
                    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
                }
                invert() {
                    let e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        u = e[8],
                        c = e[9],
                        h = e[10],
                        d = e[11],
                        f = e[12],
                        p = e[13],
                        m = e[14],
                        g = e[15],
                        v = c * m * l - p * h * l + p * o * d - s * m * d - c * o * g + s * h * g,
                        _ = f * h * l - u * m * l - f * o * d + a * m * d + u * o * g - a * h * g,
                        y = u * p * l - f * c * l + f * s * d - a * p * d - u * s * g + a * c * g,
                        x = f * c * o - u * p * o - f * s * h + a * p * h + u * s * m - a * c * m,
                        b = t * v + n * _ + r * y + i * x;
                    if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let w = 1 / b;
                    return e[0] = v * w, e[1] = (p * h * i - c * m * i - p * r * d + n * m * d + c * r * g - n * h * g) * w, e[2] = (s * m * i - p * o * i + p * r * l - n * m * l - s * r * g + n * o * g) * w, e[3] = (c * o * i - s * h * i - c * r * l + n * h * l + s * r * d - n * o * d) * w, e[4] = _ * w, e[5] = (u * m * i - f * h * i + f * r * d - t * m * d - u * r * g + t * h * g) * w, e[6] = (f * o * i - a * m * i - f * r * l + t * m * l + a * r * g - t * o * g) * w, e[7] = (a * h * i - u * o * i + u * r * l - t * h * l - a * r * d + t * o * d) * w, e[8] = y * w, e[9] = (f * c * i - u * p * i - f * n * d + t * p * d + u * n * g - t * c * g) * w, e[10] = (a * p * i - f * s * i + f * n * l - t * p * l - a * n * g + t * s * g) * w, e[11] = (u * s * i - a * c * i - u * n * l + t * c * l + a * n * d - t * s * d) * w, e[12] = x * w, e[13] = (u * p * r - f * c * r + f * n * h - t * p * h - u * n * m + t * c * m) * w, e[14] = (f * s * r - a * p * r - f * n * o + t * p * o + a * n * m - t * s * m) * w, e[15] = (a * c * r - u * s * r + u * n * o - t * c * o - a * n * h + t * s * h) * w, this
                }
                scale(e) {
                    let t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z;
                    return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                }
                getMaxScaleOnAxis() {
                    let e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, r))
                }
                makeTranslation(e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    let t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    let n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 - n,
                        a = e.x,
                        s = e.y,
                        o = e.z,
                        l = i * a,
                        u = i * s;
                    return this.set(l * a + n, l * s - r * o, l * o + r * s, 0, l * s + r * o, u * s + n, u * o - r * a, 0, l * o - r * s, u * o + r * a, i * o * o + n, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, n, r, i, a) {
                    return this.set(1, n, i, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, n) {
                    let r = this.elements,
                        i = t._x,
                        a = t._y,
                        s = t._z,
                        o = t._w,
                        l = i + i,
                        u = a + a,
                        c = s + s,
                        h = i * l,
                        d = i * u,
                        f = i * c,
                        p = a * u,
                        m = a * c,
                        g = s * c,
                        v = o * l,
                        _ = o * u,
                        y = o * c,
                        x = n.x,
                        b = n.y,
                        w = n.z;
                    return r[0] = (1 - (p + g)) * x, r[1] = (d + y) * x, r[2] = (f - _) * x, r[3] = 0, r[4] = (d - y) * b, r[5] = (1 - (h + g)) * b, r[6] = (m + v) * b, r[7] = 0, r[8] = (f + _) * w, r[9] = (m - v) * w, r[10] = (1 - (h + p)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                }
                decompose(e, t, n) {
                    let r = this.elements,
                        i = rf.set(r[0], r[1], r[2]).length(),
                        a = rf.set(r[4], r[5], r[6]).length(),
                        s = rf.set(r[8], r[9], r[10]).length(),
                        o = this.determinant();
                    o < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], rp.copy(this);
                    let l = 1 / i,
                        u = 1 / a,
                        c = 1 / s;
                    return rp.elements[0] *= l, rp.elements[1] *= l, rp.elements[2] *= l, rp.elements[4] *= u, rp.elements[5] *= u, rp.elements[6] *= u, rp.elements[8] *= c, rp.elements[9] *= c, rp.elements[10] *= c, t.setFromRotationMatrix(rp), n.x = i, n.y = a, n.z = s, this
                }
                makePerspective(e, t, n, r, i, a) {
                    let s = this.elements;
                    return s[0] = 2 * i / (t - e), s[4] = 0, s[8] = (t + e) / (t - e), s[12] = 0, s[1] = 0, s[5] = 2 * i / (n - r), s[9] = (n + r) / (n - r), s[13] = 0, s[2] = 0, s[6] = 0, s[10] = -(a + i) / (a - i), s[14] = -2 * a * i / (a - i), s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
                }
                makeOrthographic(e, t, n, r, i, a) {
                    let s = this.elements,
                        o = 1 / (t - e),
                        l = 1 / (n - r),
                        u = 1 / (a - i);
                    return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -((t + e) * o), s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -((n + r) * l), s[2] = 0, s[6] = 0, s[10] = -2 * u, s[14] = -((a + i) * u), s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
                }
                equals(e) {
                    let t = this.elements,
                        n = e.elements;
                    for (let r = 0; r < 16; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    let n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }
            let rf = new nj,
                rp = new rd,
                rm = new nj(0, 0, 0),
                rg = new nj(1, 1, 1),
                rv = new nj,
                r_ = new nj,
                ry = new nj,
                rx = new rd,
                rb = new nH;
            class rw {
                constructor(e = 0, t = 0, n = 0, r = rw.DefaultOrder) {
                    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, n, r = this._order) {
                    return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t = this._order, n = !0) {
                    let r = e.elements,
                        i = r[0],
                        a = r[4],
                        s = r[8],
                        o = r[1],
                        l = r[5],
                        u = r[9],
                        c = r[2],
                        h = r[6],
                        d = r[10];
                    switch (t) {
                        case "XYZ":
                            this._y = Math.asin(ni(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(h, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-ni(u, -1, 1)), .9999999 > Math.abs(u) ? (this._y = Math.atan2(s, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, i), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(ni(h, -1, 1)), .9999999 > Math.abs(h) ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(o, i));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-ni(c, -1, 1)), .9999999 > Math.abs(c) ? (this._x = Math.atan2(h, d), this._z = Math.atan2(o, i)) : (this._x = 0, this._z = Math.atan2(-a, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(ni(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-c, i)) : (this._x = 0, this._y = Math.atan2(s, d));
                            break;
                        case "XZY":
                            this._z = Math.asin(-ni(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(h, l), this._y = Math.atan2(s, i)) : (this._x = Math.atan2(-u, d), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t, !0 === n && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, n) {
                    return rx.makeRotationFromQuaternion(e), this.setFromRotationMatrix(rx, t, n)
                }
                setFromVector3(e, t = this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return rb.setFromEuler(this), this.setFromQuaternion(rb, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._order
                }
                toVector3() {
                    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
                }
            }
            rw.DefaultOrder = "XYZ", rw.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class rS {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = (1 << e | 0) >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return (this.mask & e.mask) != 0
                }
                isEnabled(e) {
                    return (this.mask & (1 << e | 0)) != 0
                }
            }
            let rM = 0,
                rT = new nj,
                rA = new nH,
                rE = new rd,
                rC = new nj,
                rI = new nj,
                rP = new nj,
                rR = new nH,
                rL = new nj(1, 0, 0),
                rD = new nj(0, 1, 0),
                rk = new nj(0, 0, 1),
                rU = {
                    type: "added"
                },
                rO = {
                    type: "removed"
                };
            class rF extends t7 {
                constructor() {
                    super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                        value: rM++
                    }), this.uuid = nr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = rF.DefaultUp.clone();
                    let e = new nj,
                        t = new rw,
                        n = new nH,
                        r = new nj(1, 1, 1);
                    t._onChange(function() {
                        n.setFromEuler(t, !1)
                    }), n._onChange(function() {
                        t.setFromQuaternion(n, void 0, !1)
                    }), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: r
                        },
                        modelViewMatrix: {
                            value: new rd
                        },
                        normalMatrix: {
                            value: new nm
                        }
                    }), this.matrix = new rd, this.matrixWorld = new rd, this.matrixAutoUpdate = rF.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = rF.DefaultMatrixWorldAutoUpdate, this.layers = new rS, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e), this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return rA.setFromAxisAngle(e, t), this.quaternion.multiply(rA), this
                }
                rotateOnWorldAxis(e, t) {
                    return rA.setFromAxisAngle(e, t), this.quaternion.premultiply(rA), this
                }
                rotateX(e) {
                    return this.rotateOnAxis(rL, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(rD, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(rk, e)
                }
                translateOnAxis(e, t) {
                    return rT.copy(e).applyQuaternion(this.quaternion), this.position.add(rT.multiplyScalar(t)), this
                }
                translateX(e) {
                    return this.translateOnAxis(rL, e)
                }
                translateY(e) {
                    return this.translateOnAxis(rD, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(rk, e)
                }
                localToWorld(e) {
                    return e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return e.applyMatrix4(rE.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, n) {
                    e.isVector3 ? rC.copy(e) : rC.set(e, t, n);
                    let r = this.parent;
                    this.updateWorldMatrix(!0, !1), rI.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? rE.lookAt(rI, rC, this.up) : rE.lookAt(rC, rI, this.up), this.quaternion.setFromRotationMatrix(rE), r && (rE.extractRotation(r.matrixWorld), rA.setFromRotationMatrix(rE), this.quaternion.premultiply(rA.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(rU)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    let n = this.children.indexOf(e);
                    return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(rO)), this
                }
                removeFromParent() {
                    let e = this.parent;
                    return null !== e && e.remove(this), this
                }
                clear() {
                    for (let e = 0; e < this.children.length; e++) {
                        let t = this.children[e];
                        t.parent = null, t.dispatchEvent(rO)
                    }
                    return this.children.length = 0, this
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1), rE.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), rE.multiply(e.parent.matrixWorld)), e.applyMatrix4(rE), this.add(e), e.updateWorldMatrix(!1, !0), this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t) return this;
                    for (let n = 0, r = this.children.length; n < r; n++) {
                        let i = this.children[n],
                            a = i.getObjectByProperty(e, t);
                        if (void 0 !== a) return a
                    }
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rI, e, rP), e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rI, rR, e), e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    let t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    let t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    let t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                }
                traverseAncestors(e) {
                    let t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    let t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let i = t[n];
                        (!0 === i.matrixWorldAutoUpdate || !0 === e) && i.updateMatrixWorld(e)
                    }
                }
                updateWorldMatrix(e, t) {
                    let n = this.parent;
                    if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                        let r = this.children;
                        for (let i = 0, a = r.length; i < a; i++) {
                            let s = r[i];
                            !0 === s.matrixWorldAutoUpdate && s.updateWorldMatrix(!1, !0)
                        }
                    }
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    let r = {};

                    function i(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(e.geometries, this.geometry);
                        let a = this.geometry.parameters;
                        if (void 0 !== a && void 0 !== a.shapes) {
                            let s = a.shapes;
                            if (Array.isArray(s))
                                for (let o = 0, l = s.length; o < l; o++) {
                                    let u = s[o];
                                    i(e.shapes, u)
                                } else i(e.shapes, s)
                        }
                    }
                    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
                        if (Array.isArray(this.material)) {
                            let c = [];
                            for (let h = 0, d = this.material.length; h < d; h++) c.push(i(e.materials, this.material[h]));
                            r.material = c
                        } else r.material = i(e.materials, this.material)
                    }
                    if (this.children.length > 0) {
                        r.children = [];
                        for (let f = 0; f < this.children.length; f++) r.children.push(this.children[f].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        r.animations = [];
                        for (let p = 0; p < this.animations.length; p++) {
                            let m = this.animations[p];
                            r.animations.push(i(e.animations, m))
                        }
                    }
                    if (t) {
                        let g = M(e.geometries),
                            v = M(e.materials),
                            _ = M(e.textures),
                            y = M(e.images),
                            x = M(e.shapes),
                            b = M(e.skeletons),
                            w = M(e.animations),
                            S = M(e.nodes);
                        g.length > 0 && (n.geometries = g), v.length > 0 && (n.materials = v), _.length > 0 && (n.textures = _), y.length > 0 && (n.images = y), x.length > 0 && (n.shapes = x), b.length > 0 && (n.skeletons = b), w.length > 0 && (n.animations = w), S.length > 0 && (n.nodes = S)
                    }
                    return n.object = r, n;

                    function M(e) {
                        let t = [];
                        for (let n in e) {
                            let r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                }
                clone(e) {
                    return new this.constructor().copy(this, e)
                }
                copy(e, t = !0) {
                    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (let n = 0; n < e.children.length; n++) {
                            let r = e.children[n];
                            this.add(r.clone())
                        }
                    return this
                }
            }
            rF.DefaultUp = new nj(0, 1, 0), rF.DefaultMatrixAutoUpdate = !0, rF.DefaultMatrixWorldAutoUpdate = !0;
            let rN = new nj,
                rB = new nj,
                rz = new nj,
                rG = new nj,
                rV = new nj,
                rW = new nj,
                rH = new nj,
                rj = new nj,
                rq = new nj,
                rX = new nj;
            class rZ {
                constructor(e = new nj, t = new nj, n = new nj) {
                    this.a = e, this.b = t, this.c = n
                }
                static getNormal(e, t, n, r) {
                    r.subVectors(n, t), rN.subVectors(e, t), r.cross(rN);
                    let i = r.lengthSq();
                    return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, r, i) {
                    rN.subVectors(r, t), rB.subVectors(n, t), rz.subVectors(e, t);
                    let a = rN.dot(rN),
                        s = rN.dot(rB),
                        o = rN.dot(rz),
                        l = rB.dot(rB),
                        u = rB.dot(rz),
                        c = a * l - s * s;
                    if (0 === c) return i.set(-2, -1, -1);
                    let h = 1 / c,
                        d = (l * o - s * u) * h,
                        f = (a * u - s * o) * h;
                    return i.set(1 - d - f, f, d)
                }
                static containsPoint(e, t, n, r) {
                    return this.getBarycoord(e, t, n, r, rG), rG.x >= 0 && rG.y >= 0 && rG.x + rG.y <= 1
                }
                static getUV(e, t, n, r, i, a, s, o) {
                    return this.getBarycoord(e, t, n, r, rG), o.set(0, 0), o.addScaledVector(i, rG.x), o.addScaledVector(a, rG.y), o.addScaledVector(s, rG.z), o
                }
                static isFrontFacing(e, t, n, r) {
                    return rN.subVectors(n, t), rB.subVectors(e, t), 0 > rN.cross(rB).dot(r)
                }
                set(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                }
                setFromPointsAndIndices(e, t, n, r) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                }
                setFromAttributeAndIndices(e, t, n, r) {
                    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return rN.subVectors(this.c, this.b), rB.subVectors(this.a, this.b), .5 * rN.cross(rB).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return rZ.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return rZ.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getUV(e, t, n, r, i) {
                    return rZ.getUV(e, this.a, this.b, this.c, t, n, r, i)
                }
                containsPoint(e) {
                    return rZ.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return rZ.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    let n, r;
                    let i = this.a,
                        a = this.b,
                        s = this.c;
                    rV.subVectors(a, i), rW.subVectors(s, i), rj.subVectors(e, i);
                    let o = rV.dot(rj),
                        l = rW.dot(rj);
                    if (o <= 0 && l <= 0) return t.copy(i);
                    rq.subVectors(e, a);
                    let u = rV.dot(rq),
                        c = rW.dot(rq);
                    if (u >= 0 && c <= u) return t.copy(a);
                    let h = o * c - u * l;
                    if (h <= 0 && o >= 0 && u <= 0) return n = o / (o - u), t.copy(i).addScaledVector(rV, n);
                    rX.subVectors(e, s);
                    let d = rV.dot(rX),
                        f = rW.dot(rX);
                    if (f >= 0 && d <= f) return t.copy(s);
                    let p = d * l - o * f;
                    if (p <= 0 && l >= 0 && f <= 0) return r = l / (l - f), t.copy(i).addScaledVector(rW, r);
                    let m = u * f - d * c;
                    if (m <= 0 && c - u >= 0 && d - f >= 0) return rH.subVectors(s, a), r = (c - u) / (c - u + (d - f)), t.copy(a).addScaledVector(rH, r);
                    let g = 1 / (m + p + h);
                    return n = p * g, r = h * g, t.copy(i).addScaledVector(rV, n).addScaledVector(rW, r)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            let rY = 0;
            class r$ extends t7 {
                constructor() {
                    super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                        value: rY++
                    }), this.uuid = nr(), this.name = "", this.type = "Material", this.blending = r$.DEFAULT_BLENDING, this.side = y, this.vertexColors = !1, this.cellShading = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = F, this.blendDst = N, this.blendEquation = C, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = X, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = tY, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = tU, this.stencilZFail = tU, this.stencilZPass = tU, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (let t in e) {
                            let n = e[t];
                            if (void 0 === n) {
                                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                continue
                            }
                            let r = this[t];
                            if (void 0 === r) {
                                console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                                continue
                            }
                            r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n
                        }
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    let n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(e) {
                        let t = [];
                        for (let n in e) {
                            let r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== S && (n.blending = this.blending), this.side !== y && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                        let i = r(e.textures),
                            a = r(e.images);
                        i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a)
                    }
                    return n
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    let t = e.clippingPlanes,
                        n = null;
                    if (null !== t) {
                        let r = t.length;
                        n = Array(r);
                        for (let i = 0; i !== r; ++i) n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            r$.DEFAULT_BLENDING = w;
            class rJ extends r$ {
                constructor(e) {
                    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new nR(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = K, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            let rK = new nj,
                rQ = new np;
            class r0 {
                constructor(e, t, n) {
                    if (Array.isArray(e)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = t$, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (let r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e), this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) rQ.fromBufferAttribute(this, t), rQ.applyMatrix3(e), this.setXY(t, rQ.x, rQ.y);
                    else if (3 === this.itemSize)
                        for (let r = 0, i = this.count; r < i; r++) rK.fromBufferAttribute(this, r), rK.applyMatrix3(e), this.setXYZ(r, rK.x, rK.y, rK.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.count; t < n; t++) rK.fromBufferAttribute(this, t), rK.applyMatrix4(e), this.setXYZ(t, rK.x, rK.y, rK.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) rK.fromBufferAttribute(this, t), rK.applyNormalMatrix(e), this.setXYZ(t, rK.x, rK.y, rK.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) rK.fromBufferAttribute(this, t), rK.transformDirection(e), this.setXYZ(t, rK.x, rK.y, rK.z);
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                getX(e) {
                    let t = this.array[e * this.itemSize];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                setX(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.array[e * this.itemSize] = t, this
                }
                getY(e) {
                    let t = this.array[e * this.itemSize + 1];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                setY(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.array[e * this.itemSize + 1] = t, this
                }
                getZ(e) {
                    let t = this.array[e * this.itemSize + 2];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                setZ(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.array[e * this.itemSize + 2] = t, this
                }
                getW(e) {
                    let t = this.array[e * this.itemSize + 3];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                setW(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.array[e * this.itemSize + 3] = t, this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize, this.normalized && (t = nd(t, this.array), n = nd(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
                }
                setXYZ(e, t, n, r) {
                    return e *= this.itemSize, this.normalized && (t = nd(t, this.array), n = nd(n, this.array), r = nd(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
                }
                setXYZW(e, t, n, r, i) {
                    return e *= this.itemSize, this.normalized && (t = nd(t, this.array), n = nd(n, this.array), r = nd(r, this.array), i = nd(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    let e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name), this.usage !== t$ && (e.usage = this.usage), (0 !== this.updateRange.offset || -1 !== this.updateRange.count) && (e.updateRange = this.updateRange), e
                }
                copyColorsArray() {
                    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
                }
                copyVector2sArray() {
                    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
                }
                copyVector3sArray() {
                    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
                }
                copyVector4sArray() {
                    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
                }
            }
            class r1 extends r0 {
                constructor(e, t, n) {
                    super(new Int8Array(e), t, n)
                }
            }
            class r2 extends r0 {
                constructor(e, t, n) {
                    super(new Uint8Array(e), t, n)
                }
            }
            class r3 extends r0 {
                constructor(e, t, n) {
                    super(new Uint8ClampedArray(e), t, n)
                }
            }
            class r4 extends r0 {
                constructor(e, t, n) {
                    super(new Int16Array(e), t, n)
                }
            }
            class r5 extends r0 {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            class r6 extends r0 {
                constructor(e, t, n) {
                    super(new Int32Array(e), t, n)
                }
            }
            class r8 extends r0 {
                constructor(e, t, n) {
                    super(new Uint32Array(e), t, n)
                }
            }
            class r7 extends r0 {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0
                }
            }
            class r9 extends r0 {
                constructor(e, t, n) {
                    super(new Float32Array(e), t, n)
                }
            }
            class ie extends r0 {
                constructor(e, t, n) {
                    super(new Float64Array(e), t, n)
                }
            }
            let it = 0,
                ir = new rd,
                ii = new rF,
                ia = new nj,
                is = new nZ,
                io = new nZ,
                il = new nj;
            class iu extends t7 {
                constructor() {
                    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                        value: it++
                    }), this.uuid = nr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new(nv(e) ? r8 : r5)(e, 1) : this.index = e, this
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t, this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e], this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, n = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                }
                applyMatrix4(e) {
                    let t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    let n = this.attributes.normal;
                    if (void 0 !== n) {
                        let r = new nm().getNormalMatrix(e);
                        n.applyNormalMatrix(r), n.needsUpdate = !0
                    }
                    let i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(e) {
                    return ir.makeRotationFromQuaternion(e), this.applyMatrix4(ir), this
                }
                rotateX(e) {
                    return ir.makeRotationX(e), this.applyMatrix4(ir), this
                }
                rotateY(e) {
                    return ir.makeRotationY(e), this.applyMatrix4(ir), this
                }
                rotateZ(e) {
                    return ir.makeRotationZ(e), this.applyMatrix4(ir), this
                }
                translate(e, t, n) {
                    return ir.makeTranslation(e, t, n), this.applyMatrix4(ir), this
                }
                scale(e, t, n) {
                    return ir.makeScale(e, t, n), this.applyMatrix4(ir), this
                }
                lookAt(e) {
                    return ii.lookAt(e), ii.updateMatrix(), this.applyMatrix4(ii.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(ia).negate(), this.translate(ia.x, ia.y, ia.z), this
                }
                setFromPoints(e) {
                    let t = [];
                    for (let n = 0, r = e.length; n < r; n++) {
                        let i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    return this.setAttribute("position", new r9(t, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new nZ);
                    let e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) {
                        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new nj(-1 / 0, -1 / 0, -1 / 0), new nj(Infinity, Infinity, Infinity));
                        return
                    }
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), t)
                            for (let n = 0, r = t.length; n < r; n++) {
                                let i = t[n];
                                is.setFromBufferAttribute(i), this.morphTargetsRelative ? (il.addVectors(this.boundingBox.min, is.min), this.boundingBox.expandByPoint(il), il.addVectors(this.boundingBox.max, is.max), this.boundingBox.expandByPoint(il)) : (this.boundingBox.expandByPoint(is.min), this.boundingBox.expandByPoint(is.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new rr);
                    let e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) {
                        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new nj, 1 / 0);
                        return
                    }
                    if (e) {
                        let n = this.boundingSphere.center;
                        if (is.setFromBufferAttribute(e), t)
                            for (let r = 0, i = t.length; r < i; r++) {
                                let a = t[r];
                                io.setFromBufferAttribute(a), this.morphTargetsRelative ? (il.addVectors(is.min, io.min), is.expandByPoint(il), il.addVectors(is.max, io.max), is.expandByPoint(il)) : (is.expandByPoint(io.min), is.expandByPoint(io.max))
                            }
                        is.getCenter(n);
                        let s = 0;
                        for (let o = 0, l = e.count; o < l; o++) il.fromBufferAttribute(e, o), s = Math.max(s, n.distanceToSquared(il));
                        if (t)
                            for (let u = 0, c = t.length; u < c; u++) {
                                let h = t[u],
                                    d = this.morphTargetsRelative;
                                for (let f = 0, p = h.count; f < p; f++) il.fromBufferAttribute(h, f), d && (ia.fromBufferAttribute(e, f), il.add(ia)), s = Math.max(s, n.distanceToSquared(il))
                            }
                        this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    let e = this.index,
                        t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) {
                        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        return
                    }
                    let n = e.array,
                        r = t.position.array,
                        i = t.normal.array,
                        a = t.uv.array,
                        s = r.length / 3;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new r0(new Float32Array(4 * s), 4));
                    let o = this.getAttribute("tangent").array,
                        l = [],
                        u = [];
                    for (let c = 0; c < s; c++) l[c] = new nj, u[c] = new nj;
                    let h = new nj,
                        d = new nj,
                        f = new nj,
                        p = new np,
                        m = new np,
                        g = new np,
                        v = new nj,
                        _ = new nj,
                        y = this.groups;
                    0 === y.length && (y = [{
                        start: 0,
                        count: n.length
                    }]);
                    for (let x = 0, b = y.length; x < b; ++x) {
                        let w = y[x],
                            S = w.start,
                            M = w.count;
                        for (let T = S, A = S + M; T < A; T += 3) ! function(e, t, n) {
                            h.fromArray(r, 3 * e), d.fromArray(r, 3 * t), f.fromArray(r, 3 * n), p.fromArray(a, 2 * e), m.fromArray(a, 2 * t), g.fromArray(a, 2 * n), d.sub(h), f.sub(h), m.sub(p), g.sub(p);
                            let i = 1 / (m.x * g.y - g.x * m.y);
                            isFinite(i) && (v.copy(d).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(i), _.copy(f).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(i), l[e].add(v), l[t].add(v), l[n].add(v), u[e].add(_), u[t].add(_), u[n].add(_))
                        }(n[T + 0], n[T + 1], n[T + 2])
                    }
                    let E = new nj,
                        C = new nj,
                        I = new nj,
                        P = new nj;

                    function R(e) {
                        I.fromArray(i, 3 * e), P.copy(I);
                        let t = l[e];
                        E.copy(t), E.sub(I.multiplyScalar(I.dot(t))).normalize(), C.crossVectors(P, t);
                        let n = C.dot(u[e]);
                        o[4 * e] = E.x, o[4 * e + 1] = E.y, o[4 * e + 2] = E.z, o[4 * e + 3] = n < 0 ? -1 : 1
                    }
                    for (let L = 0, D = y.length; L < D; ++L) {
                        let k = y[L],
                            U = k.start,
                            O = k.count;
                        for (let F = U, N = U + O; F < N; F += 3) R(n[F + 0]), R(n[F + 1]), R(n[F + 2])
                    }
                }
                computeVertexNormals() {
                    let e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new r0(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                        else
                            for (let r = 0, i = n.count; r < i; r++) n.setXYZ(r, 0, 0, 0);
                        let a = new nj,
                            s = new nj,
                            o = new nj,
                            l = new nj,
                            u = new nj,
                            c = new nj,
                            h = new nj,
                            d = new nj;
                        if (e)
                            for (let f = 0, p = e.count; f < p; f += 3) {
                                let m = e.getX(f + 0),
                                    g = e.getX(f + 1),
                                    v = e.getX(f + 2);
                                a.fromBufferAttribute(t, m), s.fromBufferAttribute(t, g), o.fromBufferAttribute(t, v), h.subVectors(o, s), d.subVectors(a, s), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, g), c.fromBufferAttribute(n, v), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(g, u.x, u.y, u.z), n.setXYZ(v, c.x, c.y, c.z)
                            } else
                                for (let _ = 0, y = t.count; _ < y; _ += 3) a.fromBufferAttribute(t, _ + 0), s.fromBufferAttribute(t, _ + 1), o.fromBufferAttribute(t, _ + 2), h.subVectors(o, s), d.subVectors(a, s), h.cross(d), n.setXYZ(_ + 0, h.x, h.y, h.z), n.setXYZ(_ + 1, h.x, h.y, h.z), n.setXYZ(_ + 2, h.x, h.y, h.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                }
                merge() {
                    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
                }
                normalizeNormals() {
                    let e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++) il.fromBufferAttribute(e, t), il.normalize(), e.setXYZ(t, il.x, il.y, il.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        let n = e.array,
                            r = e.itemSize,
                            i = e.normalized,
                            a = new n.constructor(t.length * r),
                            s = 0,
                            o = 0;
                        for (let l = 0, u = t.length; l < u; l++) {
                            s = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * r;
                            for (let c = 0; c < r; c++) a[o++] = n[s++]
                        }
                        return new r0(a, r, i)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    let t = new iu,
                        n = this.index.array,
                        r = this.attributes;
                    for (let i in r) {
                        let a = r[i],
                            s = e(a, n);
                        t.setAttribute(i, s)
                    }
                    let o = this.morphAttributes;
                    for (let l in o) {
                        let u = [],
                            c = o[l];
                        for (let h = 0, d = c.length; h < d; h++) {
                            let f = c[h],
                                p = e(f, n);
                            u.push(p)
                        }
                        t.morphAttributes[l] = u
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    let m = this.groups;
                    for (let g = 0, v = m.length; g < v; g++) {
                        let _ = m[g];
                        t.addGroup(_.start, _.count, _.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        let t = this.parameters;
                        for (let n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    let r = this.index;
                    null !== r && (e.data.index = {
                        type: r.array.constructor.name,
                        array: Array.prototype.slice.call(r.array)
                    });
                    let i = this.attributes;
                    for (let a in i) {
                        let s = i[a];
                        e.data.attributes[a] = s.toJSON(e.data)
                    }
                    let o = {},
                        l = !1;
                    for (let u in this.morphAttributes) {
                        let c = this.morphAttributes[u],
                            h = [];
                        for (let d = 0, f = c.length; d < f; d++) {
                            let p = c[d];
                            h.push(p.toJSON(e.data))
                        }
                        h.length > 0 && (o[u] = h, l = !0)
                    }
                    l && (e.data.morphAttributes = o, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    let m = this.groups;
                    m.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(m)));
                    let g = this.boundingSphere;
                    return null !== g && (e.data.boundingSphere = {
                        center: g.center.toArray(),
                        radius: g.radius
                    }), e
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    let t = {};
                    this.name = e.name;
                    let n = e.index;
                    null !== n && this.setIndex(n.clone(t));
                    let r = e.attributes;
                    for (let i in r) {
                        let a = r[i];
                        this.setAttribute(i, a.clone(t))
                    }
                    let s = e.morphAttributes;
                    for (let o in s) {
                        let l = [],
                            u = s[o];
                        for (let c = 0, h = u.length; c < h; c++) l.push(u[c].clone(t));
                        this.morphAttributes[o] = l
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    let d = e.groups;
                    for (let f = 0, p = d.length; f < p; f++) {
                        let m = d[f];
                        this.addGroup(m.start, m.count, m.materialIndex)
                    }
                    let g = e.boundingBox;
                    null !== g && (this.boundingBox = g.clone());
                    let v = e.boundingSphere;
                    return null !== v && (this.boundingSphere = v.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            let ic = new rd,
                ih = new rh,
                id = new rr,
                ip = new nj,
                im = new nj,
                ig = new nj,
                iv = new nj,
                i_ = new nj,
                iy = new nj,
                ix = new nj,
                ib = new nj,
                iw = new nj,
                iS = new np,
                iM = new np,
                iT = new np,
                iA = new nj,
                iE = new nj;
            class iC extends rF {
                constructor(e = new iu, t = new rJ) {
                    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                }
                updateMorphTargets() {
                    let e = this.geometry,
                        t = e.morphAttributes,
                        n = Object.keys(t);
                    if (n.length > 0) {
                        let r = t[n[0]];
                        if (void 0 !== r) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let i = 0, a = r.length; i < a; i++) {
                                let s = r[i].name || String(i);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = i
                            }
                        }
                    }
                }
                raycast(e, t) {
                    let n;
                    let r = this.geometry,
                        i = this.material,
                        a = this.matrixWorld;
                    if (void 0 === i || (null === r.boundingSphere && r.computeBoundingSphere(), id.copy(r.boundingSphere), id.applyMatrix4(a), !1 === e.ray.intersectsSphere(id)) || (ic.copy(a).invert(), ih.copy(e.ray).applyMatrix4(ic), null !== r.boundingBox && !1 === ih.intersectsBox(r.boundingBox))) return;
                    let s = r.index,
                        o = r.attributes.position,
                        l = r.morphAttributes.position,
                        u = r.morphTargetsRelative,
                        c = r.attributes.uv,
                        h = r.attributes.uv2,
                        d = r.groups,
                        f = r.drawRange;
                    if (null !== s) {
                        if (Array.isArray(i))
                            for (let p = 0, m = d.length; p < m; p++) {
                                let g = d[p],
                                    v = i[g.materialIndex],
                                    _ = Math.max(g.start, f.start),
                                    y = Math.min(s.count, Math.min(g.start + g.count, f.start + f.count));
                                for (let x = _; x < y; x += 3) {
                                    let b = s.getX(x),
                                        w = s.getX(x + 1),
                                        S = s.getX(x + 2);
                                    (n = iI(this, v, e, ih, o, l, u, c, h, b, w, S)) && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = g.materialIndex, t.push(n))
                                }
                            } else {
                                let M = Math.max(0, f.start),
                                    T = Math.min(s.count, f.start + f.count);
                                for (let A = M; A < T; A += 3) {
                                    let E = s.getX(A),
                                        C = s.getX(A + 1),
                                        I = s.getX(A + 2);
                                    (n = iI(this, i, e, ih, o, l, u, c, h, E, C, I)) && (n.faceIndex = Math.floor(A / 3), t.push(n))
                                }
                            }
                    } else if (void 0 !== o) {
                        if (Array.isArray(i))
                            for (let P = 0, R = d.length; P < R; P++) {
                                let L = d[P],
                                    D = i[L.materialIndex],
                                    k = Math.max(L.start, f.start),
                                    U = Math.min(o.count, Math.min(L.start + L.count, f.start + f.count));
                                for (let O = k; O < U; O += 3) {
                                    let F = O,
                                        N = O + 1,
                                        B = O + 2;
                                    (n = iI(this, D, e, ih, o, l, u, c, h, F, N, B)) && (n.faceIndex = Math.floor(O / 3), n.face.materialIndex = L.materialIndex, t.push(n))
                                }
                            } else {
                                let z = Math.max(0, f.start),
                                    G = Math.min(o.count, f.start + f.count);
                                for (let V = z; V < G; V += 3) {
                                    let W = V,
                                        H = V + 1,
                                        j = V + 2;
                                    (n = iI(this, i, e, ih, o, l, u, c, h, W, H, j)) && (n.faceIndex = Math.floor(V / 3), t.push(n))
                                }
                            }
                    }
                }
            }

            function iI(e, t, n, r, i, a, s, o, l, u, c, h) {
                ip.fromBufferAttribute(i, u), im.fromBufferAttribute(i, c), ig.fromBufferAttribute(i, h);
                let d = e.morphTargetInfluences;
                if (a && d) {
                    ix.set(0, 0, 0), ib.set(0, 0, 0), iw.set(0, 0, 0);
                    for (let f = 0, p = a.length; f < p; f++) {
                        let m = d[f],
                            g = a[f];
                        0 !== m && (iv.fromBufferAttribute(g, u), i_.fromBufferAttribute(g, c), iy.fromBufferAttribute(g, h), s ? (ix.addScaledVector(iv, m), ib.addScaledVector(i_, m), iw.addScaledVector(iy, m)) : (ix.addScaledVector(iv.sub(ip), m), ib.addScaledVector(i_.sub(im), m), iw.addScaledVector(iy.sub(ig), m)))
                    }
                    ip.add(ix), im.add(ib), ig.add(iw)
                }
                e.isSkinnedMesh && (e.boneTransform(u, ip), e.boneTransform(c, im), e.boneTransform(h, ig));
                let v = function(e, t, n, r, i, a, s, o) {
                    if (null === (t.side === x ? r.intersectTriangle(s, a, i, !0, o) : r.intersectTriangle(i, a, s, t.side !== b, o))) return null;
                    iE.copy(o), iE.applyMatrix4(e.matrixWorld);
                    let l = n.ray.origin.distanceTo(iE);
                    return l < n.near || l > n.far ? null : {
                        distance: l,
                        point: iE.clone(),
                        object: e
                    }
                }(e, t, n, r, ip, im, ig, iA);
                if (v) {
                    o && (iS.fromBufferAttribute(o, u), iM.fromBufferAttribute(o, c), iT.fromBufferAttribute(o, h), v.uv = rZ.getUV(iA, ip, im, ig, iS, iM, iT, new np)), l && (iS.fromBufferAttribute(l, u), iM.fromBufferAttribute(l, c), iT.fromBufferAttribute(l, h), v.uv2 = rZ.getUV(iA, ip, im, ig, iS, iM, iT, new np));
                    let _ = {
                        a: u,
                        b: c,
                        c: h,
                        normal: new nj,
                        materialIndex: 0
                    };
                    rZ.getNormal(ip, im, ig, _.normal), v.face = _
                }
                return v
            }
            class iP extends iu {
                constructor(e = 1, t = 1, n = 1, r = 1, i = 1, a = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: a
                    };
                    let s = this;
                    r = Math.floor(r), i = Math.floor(i), a = Math.floor(a);
                    let o = [],
                        l = [],
                        u = [],
                        c = [],
                        h = 0,
                        d = 0;

                    function f(e, t, n, r, i, a, f, p, m, g, v) {
                        let _ = a / m,
                            y = f / g,
                            x = a / 2,
                            b = f / 2,
                            w = p / 2,
                            S = m + 1,
                            M = g + 1,
                            T = 0,
                            A = 0,
                            E = new nj;
                        for (let C = 0; C < M; C++) {
                            let I = C * y - b;
                            for (let P = 0; P < S; P++) {
                                let R = P * _ - x;
                                E[e] = R * r, E[t] = I * i, E[n] = w, l.push(E.x, E.y, E.z), E[e] = 0, E[t] = 0, E[n] = p > 0 ? 1 : -1, u.push(E.x, E.y, E.z), c.push(P / m), c.push(1 - C / g), T += 1
                            }
                        }
                        for (let L = 0; L < g; L++)
                            for (let D = 0; D < m; D++) {
                                let k = h + D + S * L,
                                    U = h + D + S * (L + 1),
                                    O = h + (D + 1) + S * (L + 1),
                                    F = h + (D + 1) + S * L;
                                o.push(k, U, F), o.push(U, O, F), A += 6
                            }
                        s.addGroup(d, A, v), d += A, h += T
                    }
                    f("z", "y", "x", -1, -1, n, t, e, a, i, 0), f("z", "y", "x", 1, -1, n, t, -e, a, i, 1), f("x", "z", "y", 1, 1, e, n, t, r, a, 2), f("x", "z", "y", 1, -1, e, n, -t, r, a, 3), f("x", "y", "z", 1, -1, e, t, n, r, i, 4), f("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(o), this.setAttribute("position", new r9(l, 3)), this.setAttribute("normal", new r9(u, 3)), this.setAttribute("uv", new r9(c, 2))
                }
                static fromJSON(e) {
                    return new iP(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                }
            }

            function iR(e) {
                let t = {};
                for (let n in e)
                    for (let r in t[n] = {}, e[n]) {
                        let i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                return t
            }

            function iL(e) {
                let t = {};
                for (let n = 0; n < e.length; n++) {
                    let r = iR(e[n]);
                    for (let i in r) t[i] = r[i]
                }
                return t
            }

            function iD(e) {
                return null === e.getRenderTarget() && e.outputEncoding === tA ? tL : tD
            }
            let ik = {
                clone: iR,
                merge: iL
            };
            class iU extends r$ {
                constructor(e) {
                    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.transformFeedbackVaryings = null, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = iR(e.uniforms), this.uniformsGroups = function(e) {
                        let t = [];
                        for (let n = 0; n < e.length; n++) t.push(e[n].clone());
                        return t
                    }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    for (let n in t.glslVersion = this.glslVersion, t.uniforms = {}, this.uniforms) {
                        let r = this.uniforms[n],
                            i = r.value;
                        i && i.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: i.toJSON(e).uuid
                        } : i && i.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: i.getHex()
                        } : i && i.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: i.toArray()
                        } : i && i.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: i.toArray()
                        } : i && i.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: i.toArray()
                        } : i && i.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: i.toArray()
                        } : i && i.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: i.toArray()
                        } : t.uniforms[n] = {
                            value: i
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                    let a = {};
                    for (let s in this.extensions) !0 === this.extensions[s] && (a[s] = !0);
                    return Object.keys(a).length > 0 && (t.extensions = a), t
                }
            }
            class iO extends rF {
                constructor() {
                    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new rd, this.projectionMatrix = new rd, this.projectionMatrixInverse = new rd
                }
                copy(e, t) {
                    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    let t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class iF extends iO {
                constructor(e = 50, t = 1, n = .1, r = 2e3) {
                    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                }
                setFocalLength(e) {
                    let t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * nn * Math.atan(t), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    let e = Math.tan(.5 * nt * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * nn * Math.atan(Math.tan(.5 * nt * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                setViewOffset(e, t, n, r, i, a) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let e = this.near,
                        t = e * Math.tan(.5 * nt * this.fov) / this.zoom,
                        n = 2 * t,
                        r = this.aspect * n,
                        i = -.5 * r,
                        a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        let s = a.fullWidth,
                            o = a.fullHeight;
                        i += a.offsetX * r / s, t -= a.offsetY * n / o, r *= a.width / s, n *= a.height / o
                    }
                    let l = this.filmOffset;
                    0 !== l && (i += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }
            class iN extends rF {
                constructor(e, t, n) {
                    super(), this.type = "CubeCamera", this.renderTarget = n;
                    let r = new iF(90, 1, e, t);
                    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new nj(1, 0, 0)), this.add(r);
                    let i = new iF(90, 1, e, t);
                    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new nj(-1, 0, 0)), this.add(i);
                    let a = new iF(90, 1, e, t);
                    a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new nj(0, 1, 0)), this.add(a);
                    let s = new iF(90, 1, e, t);
                    s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new nj(0, -1, 0)), this.add(s);
                    let o = new iF(90, 1, e, t);
                    o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new nj(0, 0, 1)), this.add(o);
                    let l = new iF(90, 1, e, t);
                    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new nj(0, 0, -1)), this.add(l)
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    let n = this.renderTarget,
                        [r, i, a, s, o, l] = this.children,
                        u = e.getRenderTarget(),
                        c = e.toneMapping,
                        h = e.xr.enabled;
                    e.toneMapping = et, e.xr.enabled = !1;
                    let d = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, i), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, s), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = d, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.toneMapping = c, e.xr.enabled = h, n.texture.needsPMREMUpdate = !0
                }
            }
            class iB extends nO {
                constructor(e, t, n, r, i, a, s, o, l, u) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : el, n, r, i, a, s, o, l, u), this.isCubeTexture = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class iz extends nN {
                constructor(e, t = {}) {
                    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                    let n = {
                        width: e,
                        height: e,
                        depth: 1
                    };
                    this.texture = new iB([n, n, n, n, n, n], t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : eb
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                    let n = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				// #include <batching_pars_vertex>

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					// #include <batchingbase_vertex>

					#include <begin_vertex>
					// #include <batching_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        },
                        r = new iP(5, 5, 5),
                        i = new iU({
                            name: "CubemapFromEquirect",
                            uniforms: iR(n.uniforms),
                            vertexShader: n.vertexShader,
                            fragmentShader: n.fragmentShader,
                            side: x,
                            blending: w
                        });
                    i.uniforms.tEquirect.value = t;
                    let a = new iC(r, i),
                        s = t.minFilter;
                    t.minFilter === eM && (t.minFilter = eb);
                    let o = new iN(1, 10, this);
                    return o.update(e, a), t.minFilter = s, a.geometry.dispose(), a.material.dispose(), this
                }
                clear(e, t, n, r) {
                    let i = e.getRenderTarget();
                    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, r);
                    e.setRenderTarget(i)
                }
            }
            let iG = new nj,
                iV = new nj,
                iW = new nm;
            class iH {
                constructor(e = new nj(1, 0, 0), t = 0) {
                    this.isPlane = !0, this.normal = e, this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, n, r) {
                    return this.normal.set(e, t, n), this.constant = r, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, n) {
                    let r = iG.subVectors(n, t).cross(iV.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(r, e), this
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    let e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                }
                intersectLine(e, t) {
                    let n = e.delta(iG),
                        r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    let i = -(e.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start)
                }
                intersectsLine(e) {
                    let t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    let n = t || iW.getNormalMatrix(e),
                        r = this.coplanarPoint(iG).applyMatrix4(e),
                        i = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -r.dot(i), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let ij = new rr,
                iq = new nj;
            class iX {
                constructor(e = new iH, t = new iH, n = new iH, r = new iH, i = new iH, a = new iH) {
                    this.planes = [e, t, n, r, i, a]
                }
                set(e, t, n, r, i, a) {
                    let s = this.planes;
                    return s[0].copy(e), s[1].copy(t), s[2].copy(n), s[3].copy(r), s[4].copy(i), s[5].copy(a), this
                }
                copy(e) {
                    let t = this.planes;
                    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e) {
                    let t = this.planes,
                        n = e.elements,
                        r = n[0],
                        i = n[1],
                        a = n[2],
                        s = n[3],
                        o = n[4],
                        l = n[5],
                        u = n[6],
                        c = n[7],
                        h = n[8],
                        d = n[9],
                        f = n[10],
                        p = n[11],
                        m = n[12],
                        g = n[13],
                        v = n[14],
                        _ = n[15];
                    return t[0].setComponents(s - r, c - o, p - h, _ - m).normalize(), t[1].setComponents(s + r, c + o, p + h, _ + m).normalize(), t[2].setComponents(s + i, c + l, p + d, _ + g).normalize(), t[3].setComponents(s - i, c - l, p - d, _ - g).normalize(), t[4].setComponents(s - a, c - u, p - f, _ - v).normalize(), t[5].setComponents(s + a, c + u, p + f, _ + v).normalize(), this
                }
                intersectsObject(e) {
                    if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), ij.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                    else {
                        let t = e.geometry;
                        null === t.boundingSphere && t.computeBoundingSphere(), ij.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                    }
                    return this.intersectsSphere(ij)
                }
                intersectsSprite(e) {
                    return ij.center.set(0, 0, 0), ij.radius = .7071067811865476, ij.applyMatrix4(e.matrixWorld), this.intersectsSphere(ij)
                }
                intersectsSphere(e) {
                    let t = this.planes,
                        n = e.center,
                        r = -e.radius;
                    for (let i = 0; i < 6; i++) {
                        let a = t[i].distanceToPoint(n);
                        if (a < r) return !1
                    }
                    return !0
                }
                intersectsBox(e) {
                    let t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        let r = t[n];
                        if (iq.x = r.normal.x > 0 ? e.max.x : e.min.x, iq.y = r.normal.y > 0 ? e.max.y : e.min.y, iq.z = r.normal.z > 0 ? e.max.z : e.min.z, 0 > r.distanceToPoint(iq)) return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    let t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (0 > t[n].distanceToPoint(e)) return !1;
                    return !0
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }

            function iZ() {
                let e = null,
                    t = !1,
                    n = null,
                    r = null;

                function i(t, a) {
                    n(t, a), r = e.requestAnimationFrame(i)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(r), t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function iY(e, t) {
                let n = t.isWebGL2,
                    r = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
                    },
                    remove: function(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        let n = r.get(t);
                        n && (e.deleteBuffer(n.buffer), r.delete(t))
                    },
                    update: function(t, i) {
                        if (t.isGLBufferAttribute) {
                            let a = r.get(t);
                            (!a || a.version < t.version) && r.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            });
                            return
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        let s = r.get(t);
                        void 0 === s ? r.set(t, function(t, r) {
                            let i;
                            let a = t.array,
                                s = t.usage,
                                o = e.createBuffer();
                            if (e.bindBuffer(r, o), e.bufferData(r, a, s), t.onUploadCallback(), a instanceof Float32Array) i = 5126;
                            else if (a instanceof Uint16Array) {
                                if (t.isFloat16BufferAttribute) {
                                    if (n) i = 5131;
                                    else throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.")
                                } else i = 5123
                            } else if (a instanceof Int16Array) i = 5122;
                            else if (a instanceof Uint32Array) i = 5125;
                            else if (a instanceof Int32Array) i = 5124;
                            else if (a instanceof Int8Array) i = 5120;
                            else if (a instanceof Uint8Array) i = 5121;
                            else if (a instanceof Uint8ClampedArray) i = 5121;
                            else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: " + a);
                            return {
                                buffer: o,
                                type: i,
                                bytesPerElement: a.BYTES_PER_ELEMENT,
                                version: t.version
                            }
                        }(t, i)) : s.version < t.version && (! function(t, r, i) {
                            let a = r.array,
                                s = r.updateRange;
                            e.bindBuffer(i, t), -1 === s.count ? e.bufferSubData(i, 0, a) : (n ? e.bufferSubData(i, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : e.bufferSubData(i, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1)
                        }(s.buffer, t, i), s.version = t.version)
                    }
                }
            }
            class i$ extends iu {
                constructor(e = 1, t = 1, n = 1, r = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: r
                    };
                    let i = e / 2,
                        a = t / 2,
                        s = Math.floor(n),
                        o = Math.floor(r),
                        l = s + 1,
                        u = o + 1,
                        c = e / s,
                        h = t / o,
                        d = [],
                        f = [],
                        p = [],
                        m = [];
                    for (let g = 0; g < u; g++) {
                        let v = g * h - a;
                        for (let _ = 0; _ < l; _++) {
                            let y = _ * c - i;
                            f.push(y, -v, 0), p.push(0, 0, 1), m.push(_ / s), m.push(1 - g / o)
                        }
                    }
                    for (let x = 0; x < o; x++)
                        for (let b = 0; b < s; b++) {
                            let w = b + l * x,
                                S = b + l * (x + 1),
                                M = b + 1 + l * (x + 1),
                                T = b + 1 + l * x;
                            d.push(w, S, T), d.push(S, M, T)
                        }
                    this.setIndex(d), this.setAttribute("position", new r9(f, 3)), this.setAttribute("normal", new r9(p, 3)), this.setAttribute("uv", new r9(m, 2))
                }
                static fromJSON(e) {
                    return new i$(e.width, e.height, e.widthSegments, e.heightSegments)
                }
            }
            let iJ = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
                    batchingbase_vertex: "#ifdef USE_BATCHING\n	float id = 0.;\n	#ifdef USE_BATCHING_INSTANCING\n		id = getBatchingID(geometriesTexture);\n	#endif\n	#ifdef USE_BATCHING_ARRAYMAP\n		float idTexture = getBatchingID(textureIdsTexture);\n		vTextureId = int( idTexture - 1. );\n	#endif\n	#ifndef USE_SKINNING\n		mat4 batchingMatrix = getBatchingMatrix( id );\n	#endif\n	vDrawId = id;\n#endif",
                    batchingnormal_vertex: "#ifndef USE_SKINNING\n	#ifdef USE_BATCHING\n		objectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n		#ifdef USE_TANGENT\n			objectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n		#endif\n	#endif\n#endif",
                    batching_vertex: "#ifdef USE_BATCHING\n	#ifndef USE_SKINNING\n		transformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n	#else\n		transformed = transformed;\n	#endif\n#endif",
                    batching_pars_vertex: "#ifdef USE_BATCHING\n	uniform highp sampler2D batchingTexture;\n	uniform highp sampler2D instancePerDrawIDTexture;\n	uniform highp sampler2D geometriesTexture;\n	uniform int batchingTextureSize;\n	uniform int batchingInstanceTextureSize;\n	out float vDrawId;\n	#ifdef USE_BATCHING_ARRAYMAP\n		flat out int vTextureId;\n		uniform highp sampler2D textureIdsTexture;\n	#endif\n	#ifndef MultiDraw\n		in float drawId;\n	#endif\n	float getInstanceOffset( const in float i) {\n		float j = float(i);\n		float x = mod( j, float( batchingTextureSize ) );\n		float y = floor( j / float( batchingTextureSize ) );\n		return texelFetch(instancePerDrawIDTexture, ivec2( x, y ), 0).r;\n	}\n	float getBatchingID(sampler2D tex) {\n		float id = 0.;\n		#ifdef MultiDraw\n			id = float(gl_DrawID);\n		#else\n			id = float(drawId);\n		#endif\n		float instanceOffset = getInstanceOffset( float(id) );\n		float j = float(gl_InstanceID) + instanceOffset;\n		float x = mod( j, float( batchingInstanceTextureSize ) );\n		float y = floor( j / float( batchingInstanceTextureSize ) );\n		return texelFetch(tex, ivec2( x, y ), 0).r;\n	}\n	mat4 getBatchingMatrix( const in float i ) {\n		float j = i * 4.0;\n		int x = int(mod( j, float( batchingInstanceTextureSize ) ));\n		int y = int(floor( j / float( batchingInstanceTextureSize ) ));\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif",
                    batching_pars_uniforms_fragment: "#ifdef USE_BATCHING\n	in float vDrawId;\n	#ifdef USE_BATCHING_ARRAYMAP\n		flat in int vTextureId;\n	#endif\n#endif",
                    batching_pars_uniforms: "#ifdef USE_BATCHING\n	vec4 getBatchUniform(sampler2D batchTex, int batchSize) {\n		int j = batchSize * int(vDrawId);\n		return texelFetch(batchTex, ivec2( vDrawId, 0 ), 0);\n	}\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif",
                    iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",
                    scrata_cellshading_vertex: "#ifdef USE_CELLSHADING\n	if (isBackSide) {\n		float thickness = 0.01;\n		#ifdef CELLSHADING_THICKNESS\n			thickness += CELLSHADING_THICKNESS;\n		#endif\n		const float ratio = 1.0;\n		vec3 outlineNormal = - objectNormal;\n		vec3 transformed2 = transformed;\n		transformed2.xyz += outlineNormal;\n		vec3 norm = normalize( transformed - transformed2 );\n		transformed += norm * thickness;\n	}\n#endif",
                    scrata_cellshading_fragment: "#ifdef USE_CELLSHADING\n	if ( isBackSide ) {\n		gl_FragColor.rgb = vec3(0.);\n	}\n#endif",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, backgroundBlurriness );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform float backgroundBlurriness;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
                    lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                    lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )	(0)",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",
                    map_fragment: "#if defined(USE_MAP)\n	vec4 sampledDiffuseColor = vec4(1.);\n	#ifdef USE_BATCHING_ARRAYMAP\n		sampledDiffuseColor *= texture( map, vec3( vUv, vTextureId ) );\n	#else\n		sampledDiffuseColor *= texture2D( map, vUv );\n	#endif\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n	#ifdef USE_BATCHING_ARRAYMAP\n		precision highp sampler2DArray;\n		uniform sampler2DArray map;\n	#else\n		uniform sampler2D map;\n	#endif\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
                    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",
                    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif",
                    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",
                    shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
                    shadowmap_vertex: "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n	#ifdef USE_INSTANCING\n		int j = 4 * int(i);\n		vec4 v1 = texelFetch(boneTexture, ivec2( j, gl_InstanceID ), 0);\n		vec4 v2 = texelFetch(boneTexture, ivec2( j + 1, gl_InstanceID ), 0);\n		vec4 v3 = texelFetch(boneTexture, ivec2( j + 2, gl_InstanceID ), 0);\n		vec4 v4 = texelFetch(boneTexture, ivec2( j + 3, gl_InstanceID ), 0);\n	#elif defined(USE_BATCHING_INSTANCING)\n		float id = getBatchingID(geometriesTexture);\n		int j = 4 * int(i);\n		vec4 v1 = texelFetch(boneTexture, ivec2( j, id ), 0);\n		vec4 v2 = texelFetch(boneTexture, ivec2( j + 1, id ), 0);\n		vec4 v3 = texelFetch(boneTexture, ivec2( j + 2, id ), 0);\n		vec4 v4 = texelFetch(boneTexture, ivec2( j + 3, id ), 0);\n	#elif defined(USE_BATCHING)\n		int j = 4 * int(i);\n		vec4 v1 = texelFetch(boneTexture, ivec2( j, gl_DrawID ), 0);\n		vec4 v2 = texelFetch(boneTexture, ivec2( j + 1, gl_DrawID ), 0);\n		vec4 v3 = texelFetch(boneTexture, ivec2( j + 2, gl_DrawID ), 0);\n		vec4 v4 = texelFetch(boneTexture, ivec2( j + 3, gl_DrawID ), 0);\n	#else\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n	#endif\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <batchingbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n		#include <batchingnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <displacementmap_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <batchingbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n		#include <batchingnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <displacementmap_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING ) || defined( USE_BATCHING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <batchingbase_vertex>\n		#include <batchingnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <scrata_cellshading_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <batchingbase_vertex>\n	#include <batchingnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <displacementmap_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <batchingbase_vertex>\n	#include <batchingnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <displacementmap_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <batchingbase_vertex>\n	#include <batchingnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <displacementmap_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <batchingbase_vertex>\n	#include <batchingnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <displacementmap_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <batchingbase_vertex>\n	#include <batchingnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n	#include <displacementmap_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <skinning_pars_vertex>\n#ifdef USE_TRANSFORMFEEDBACK\n	in vec3 a_offset;\n#endif\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#ifdef USE_TRANSFORMFEEDBACK\n		transformed += a_offset;\n	#endif\n	#include <skinbase_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <scrata_cellshading_vertex>\n    #include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <batching_pars_uniforms_fragment>\n#include <batching_pars_uniforms>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <batching_pars_vertex>\n#include <skinning_pars_vertex>\n#include <batching_pars_uniforms>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <batchingbase_vertex>\n	#include <batchingnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <batching_vertex>\n    #include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <scrata_cellshading_fragment>\n    #include <fog_fragment>\n}"
                },
                iK = {
                    common: {
                        diffuse: {
                            value: new nR(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new nm
                        },
                        uv2Transform: {
                            value: new nm
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        },
                        backgroundBlurriness: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new np(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new nR(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new nR(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new nm
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new nR(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new np(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new nm
                        }
                    }
                },
                iQ = {
                    basic: {
                        uniforms: iL([iK.common, iK.specularmap, iK.envmap, iK.aomap, iK.lightmap, iK.fog]),
                        vertexShader: iJ.meshbasic_vert,
                        fragmentShader: iJ.meshbasic_frag
                    },
                    lambert: {
                        uniforms: iL([iK.common, iK.specularmap, iK.envmap, iK.aomap, iK.lightmap, iK.emissivemap, iK.bumpmap, iK.normalmap, iK.displacementmap, iK.fog, iK.lights, {
                            emissive: {
                                value: new nR(0)
                            }
                        }]),
                        vertexShader: iJ.meshlambert_vert,
                        fragmentShader: iJ.meshlambert_frag
                    },
                    phong: {
                        uniforms: iL([iK.common, iK.specularmap, iK.envmap, iK.aomap, iK.lightmap, iK.emissivemap, iK.bumpmap, iK.normalmap, iK.displacementmap, iK.fog, iK.lights, {
                            emissive: {
                                value: new nR(0)
                            },
                            specular: {
                                value: new nR(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: iJ.meshphong_vert,
                        fragmentShader: iJ.meshphong_frag
                    },
                    standard: {
                        uniforms: iL([iK.common, iK.envmap, iK.aomap, iK.lightmap, iK.emissivemap, iK.bumpmap, iK.normalmap, iK.displacementmap, iK.roughnessmap, iK.metalnessmap, iK.fog, iK.lights, {
                            emissive: {
                                value: new nR(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: iJ.meshphysical_vert,
                        fragmentShader: iJ.meshphysical_frag
                    },
                    toon: {
                        uniforms: iL([iK.common, iK.aomap, iK.lightmap, iK.emissivemap, iK.bumpmap, iK.normalmap, iK.displacementmap, iK.gradientmap, iK.fog, iK.lights, {
                            emissive: {
                                value: new nR(0)
                            }
                        }]),
                        vertexShader: iJ.meshtoon_vert,
                        fragmentShader: iJ.meshtoon_frag
                    },
                    matcap: {
                        uniforms: iL([iK.common, iK.bumpmap, iK.normalmap, iK.displacementmap, iK.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: iJ.meshmatcap_vert,
                        fragmentShader: iJ.meshmatcap_frag
                    },
                    points: {
                        uniforms: iL([iK.points, iK.fog]),
                        vertexShader: iJ.points_vert,
                        fragmentShader: iJ.points_frag
                    },
                    dashed: {
                        uniforms: iL([iK.common, iK.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: iJ.linedashed_vert,
                        fragmentShader: iJ.linedashed_frag
                    },
                    depth: {
                        uniforms: iL([iK.common, iK.displacementmap]),
                        vertexShader: iJ.depth_vert,
                        fragmentShader: iJ.depth_frag
                    },
                    normal: {
                        uniforms: iL([iK.common, iK.bumpmap, iK.normalmap, iK.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: iJ.meshnormal_vert,
                        fragmentShader: iJ.meshnormal_frag
                    },
                    sprite: {
                        uniforms: iL([iK.sprite, iK.fog]),
                        vertexShader: iJ.sprite_vert,
                        fragmentShader: iJ.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new nm
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: iJ.background_vert,
                        fragmentShader: iJ.background_frag
                    },
                    cube: {
                        uniforms: iL([iK.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: iJ.cube_vert,
                        fragmentShader: iJ.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: iJ.equirect_vert,
                        fragmentShader: iJ.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: iL([iK.common, iK.displacementmap, {
                            referencePosition: {
                                value: new nj
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: iJ.distanceRGBA_vert,
                        fragmentShader: iJ.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: iL([iK.lights, iK.fog, {
                            color: {
                                value: new nR(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: iJ.shadow_vert,
                        fragmentShader: iJ.shadow_frag
                    }
                };
            iQ.physical = {
                uniforms: iL([iQ.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new np(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new nR(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new np
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new nR(0)
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new nR(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: iJ.meshphysical_vert,
                fragmentShader: iJ.meshphysical_frag
            };
            let i0 = {
                r: 0,
                b: 0,
                g: 0
            };

            function i1(e, t, n, r, i, a, s) {
                let o, l;
                let u = new nR(0),
                    c = !0 === a ? 0 : 1,
                    h = null,
                    d = 0,
                    f = null;

                function p(t, n) {
                    t.getRGB(i0, iD(e)), r.buffers.color.setClear(i0.r, i0.g, i0.b, n, s)
                }
                return {
                    getClearColor: function() {
                        return u
                    },
                    setClearColor: function(e, t = 1) {
                        u.set(e), p(u, c = t)
                    },
                    getClearAlpha: function() {
                        return c
                    },
                    setClearAlpha: function(e) {
                        p(u, c = e)
                    },
                    render: function(r, a) {
                        let s = !1,
                            m = !0 === a.isScene ? a.background : null;
                        if (m && m.isTexture) {
                            let g = a.backgroundBlurriness > 0;
                            m = (g ? n : t).get(m)
                        }
                        let v = e.xr,
                            _ = v.getSession && v.getSession();
                        _ && "additive" === _.environmentBlendMode && (m = null), null === m ? p(u, c) : m && m.isColor && (p(m, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.mapping === ed) ? (void 0 === l && ((l = new iC(new iP(1, 1, 1), new iU({
                            name: "BackgroundCubeMaterial",
                            uniforms: iR(iQ.cube.uniforms),
                            vertexShader: iQ.cube.vertexShader,
                            fragmentShader: iQ.cube.fragmentShader,
                            side: x,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(l.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), i.update(l)), l.material.uniforms.envMap.value = m, l.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, l.material.uniforms.backgroundBlurriness.value = a.backgroundBlurriness, (h !== m || d !== m.version || f !== e.toneMapping) && (l.material.needsUpdate = !0, h = m, d = m.version, f = e.toneMapping), l.layers.enableAll(), r.unshift(l, l.geometry, l.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && ((o = new iC(new i$(2, 2), new iU({
                            name: "BackgroundMaterial",
                            uniforms: iR(iQ.background.uniforms),
                            vertexShader: iQ.background.vertexShader,
                            fragmentShader: iQ.background.fragmentShader,
                            side: y,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), i.update(o)), o.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), (h !== m || d !== m.version || f !== e.toneMapping) && (o.material.needsUpdate = !0, h = m, d = m.version, f = e.toneMapping), o.layers.enableAll(), r.unshift(o, o.geometry, o.material, 0, 0, null))
                    }
                }
            }

            function i2(e, t, n, r) {
                let i = e.getParameter(34921),
                    a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    s = r.isWebGL2 || null !== a,
                    o = {},
                    l = f(null),
                    u = l,
                    c = !1;

                function h(t) {
                    return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                }

                function d(t) {
                    return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                }

                function f(e) {
                    let t = [],
                        n = [],
                        r = [];
                    for (let a = 0; a < i; a++) t[a] = 0, n[a] = 0, r[a] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: n,
                        attributeDivisors: r,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function p() {
                    let e = u.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++) e[t] = 0
                }

                function m(e) {
                    g(e, 0)
                }

                function g(n, i) {
                    let a = u.newAttributes,
                        s = u.enabledAttributes,
                        o = u.attributeDivisors;
                    if (a[n] = 1, 0 === s[n] && (e.enableVertexAttribArray(n), s[n] = 1), o[n] !== i) {
                        let l = r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays");
                        l[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), o[n] = i
                    }
                }

                function v() {
                    let t = u.newAttributes,
                        n = u.enabledAttributes;
                    for (let r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
                }

                function _(t, n, i, a, s, o) {
                    !0 === r.isWebGL2 && (5124 === i || 5125 === i) ? e.vertexAttribIPointer(t, n, i, s, o) : e.vertexAttribPointer(t, n, i, a, s, o)
                }

                function y(i, a, s, o) {
                    if (!1 === r.isWebGL2 && (i && i.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                    p();
                    let l = o.attributes,
                        u = s.getAttributes(),
                        c = a.defaultAttributeValues;
                    for (let h in u) {
                        let d = u[h];
                        if (d.location >= 0) {
                            let f = l[h];
                            if (void 0 === f && (i && "instanceMatrix" === h && i.instanceMatrix && (f = i.instanceMatrix), i && "instanceColor" === h && i.instanceColor && (f = i.instanceColor)), void 0 !== f) {
                                let y = f.normalized,
                                    x = f.itemSize,
                                    b = n.get(f);
                                if (void 0 === b) continue;
                                let w = b.buffer,
                                    S = b.type,
                                    M = b.bytesPerElement;
                                if (f.isInterleavedBufferAttribute) {
                                    let T = f.data,
                                        A = T.stride,
                                        E = f.offset;
                                    if (T.isInstancedInterleavedBuffer) {
                                        for (let C = 0; C < d.locationSize; C++) g(d.location + C, T.meshPerAttribute);
                                        i && !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = T.meshPerAttribute * T.count)
                                    } else
                                        for (let I = 0; I < d.locationSize; I++) m(d.location + I);
                                    e.bindBuffer(34962, w);
                                    for (let P = 0; P < d.locationSize; P++) _(d.location + P, x / d.locationSize, S, y, A * M, (E + x / d.locationSize * P) * M)
                                } else {
                                    if (f.isInstancedBufferAttribute) {
                                        for (let R = 0; R < d.locationSize; R++) g(d.location + R, f.meshPerAttribute);
                                        i && !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = f.meshPerAttribute * f.count)
                                    } else
                                        for (let L = 0; L < d.locationSize; L++) m(d.location + L);
                                    e.bindBuffer(34962, w);
                                    for (let D = 0; D < d.locationSize; D++) _(d.location + D, x / d.locationSize, S, y, x * M, x / d.locationSize * D * M)
                                }
                            } else if (void 0 !== c) {
                                let k = c[h];
                                if (void 0 !== k) switch (k.length) {
                                    case 2:
                                        e.vertexAttrib2fv(d.location, k);
                                        break;
                                    case 3:
                                        e.vertexAttrib3fv(d.location, k);
                                        break;
                                    case 4:
                                        e.vertexAttrib4fv(d.location, k);
                                        break;
                                    default:
                                        e.vertexAttrib1fv(d.location, k)
                                }
                            }
                        }
                    }
                    v()
                }

                function x() {
                    b(), c = !0, u !== l && h((u = l).object)
                }

                function b() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(t, i, l, d, p) {
                        let m = !1;
                        if (s) {
                            let g = function(t, n, i) {
                                let s = !0 === i.wireframe,
                                    l = o[t.id];
                                void 0 === l && (l = {}, o[t.id] = l);
                                let u = l[n.id];
                                void 0 === u && (u = {}, l[n.id] = u);
                                let c = u[s];
                                return void 0 === c && (c = f(r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), u[s] = c), c
                            }(d, l, i);
                            u !== g && h((u = g).object), (m = function(e, t, n, r) {
                                let i = u.attributes,
                                    a = t.attributes,
                                    s = 0,
                                    o = n.getAttributes();
                                for (let l in o) {
                                    let c = o[l];
                                    if (c.location >= 0) {
                                        let h = i[l],
                                            d = a[l];
                                        if (void 0 === d && ("instanceMatrix" === l && e.instanceMatrix && (d = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (d = e.instanceColor)), void 0 === h || h.attribute !== d || d && h.data !== d.data) return !0;
                                        s++
                                    }
                                }
                                return u.attributesNum !== s || u.index !== r
                            }(t, d, l, p)) && function(e, t, n, r) {
                                let i = {},
                                    a = t.attributes,
                                    s = 0,
                                    o = n.getAttributes();
                                for (let l in o) {
                                    let c = o[l];
                                    if (c.location >= 0) {
                                        let h = a[l];
                                        void 0 === h && ("instanceMatrix" === l && e.instanceMatrix && (h = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (h = e.instanceColor));
                                        let d = {};
                                        d.attribute = h, h && h.data && (d.data = h.data), i[l] = d, s++
                                    }
                                }
                                u.attributes = i, u.attributesNum = s, u.index = r
                            }(t, d, l, p)
                        } else {
                            let v = !0 === i.wireframe;
                            (u.geometry !== d.id || u.program !== l.id || u.wireframe !== v) && (u.geometry = d.id, u.program = l.id, u.wireframe = v, m = !0)
                        }
                        null !== p && n.update(p, 34963), (m || c) && (c = !1, y(t, i, l, d), null !== p && e.bindBuffer(34963, n.get(p).buffer))
                    },
                    reset: x,
                    resetDefaultState: b,
                    dispose: function() {
                        for (let e in x(), o) {
                            let t = o[e];
                            for (let n in t) {
                                let r = t[n];
                                for (let i in r) d(r[i].object), delete r[i];
                                delete t[n]
                            }
                            delete o[e]
                        }
                    },
                    enableAttributeAndDivisor: g,
                    setupVertexAttributes: y,
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === o[e.id]) return;
                        let t = o[e.id];
                        for (let n in t) {
                            let r = t[n];
                            for (let i in r) d(r[i].object), delete r[i];
                            delete t[n]
                        }
                        delete o[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (let t in o) {
                            let n = o[t];
                            if (void 0 === n[e.id]) continue;
                            let r = n[e.id];
                            for (let i in r) d(r[i].object), delete r[i];
                            delete n[e.id]
                        }
                    },
                    initAttributes: p,
                    enableAttribute: m,
                    disableUnusedAttributes: v
                }
            }

            function i3(e, t, n, r) {
                let i;
                let a = r.isWebGL2;
                this.setMode = function(e) {
                    i = e
                }, this.render = function(t, r) {
                    e.drawArrays(i, t, r), n.update(r, i, 1)
                }, this.renderInstances = function(r, s, o) {
                    let l, u;
                    if (0 !== o) {
                        if (a) l = e, u = "drawArraysInstanced";
                        else if (l = t.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", null === l) {
                            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            return
                        }
                        l[u](i, r, s, o), n.update(s, i, o)
                    }
                }, this.renderMultiDraw = function(e, r, a) {
                    let s = t.get("WEBGL_multi_draw");
                    if (null === s) {
                        console.error("THREE.WebGLBufferRenderer: using THREE.BatchedMesh but hardware does not support extension WEBGL_multi_draw.");
                        return
                    }
                    s.multiDrawArraysWEBGL(i, e, 0, r, 0, a);
                    let o = r.reduce((e, t) => e + t, 0);
                    n.update(o, i, 1)
                }, this.renderInstancesMultiDraw = function(e, n, r, a) {
                    let s = t.get("WEBGL_multi_draw");
                    if (null === s) {
                        console.error("THREE.WebGLBufferRenderer: using THREE.BatchedMesh but hardware does not support extension WEBGL_multi_draw.");
                        return
                    }
                    s.multiDrawArraysInstancedWEBGL(i, e, 0, n, 0, r, 0, a)
                }
            }

            function i4(e, t, n) {
                let r;

                function i(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                let a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
                    s = void 0 !== n.precision ? n.precision : "highp",
                    o = i(s);
                o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
                let l = a || t.has("WEBGL_draw_buffers"),
                    u = !0 === n.logarithmicDepthBuffer,
                    c = e.getParameter(34930),
                    h = e.getParameter(35660),
                    d = e.getParameter(3379),
                    f = e.getParameter(34076),
                    p = e.getParameter(34921),
                    m = e.getParameter(36347),
                    g = e.getParameter(36348),
                    v = e.getParameter(36349),
                    _ = h > 0,
                    y = a || t.has("OES_texture_float"),
                    x = a ? e.getParameter(36183) : 0;
                return {
                    isWebGL2: a,
                    drawBuffers: l,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r) return r;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            let n = t.get("EXT_texture_filter_anisotropic");
                            r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else r = 0;
                        return r
                    },
                    getMaxPrecision: i,
                    precision: s,
                    logarithmicDepthBuffer: u,
                    maxTextures: c,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: f,
                    maxAttributes: p,
                    maxVertexUniforms: m,
                    maxVaryings: g,
                    maxFragmentUniforms: v,
                    vertexTextures: _,
                    floatFragmentTextures: y,
                    floatVertexTextures: _ && y,
                    maxSamples: x
                }
            }

            function i5(e) {
                let t = this,
                    n = null,
                    r = 0,
                    i = !1,
                    a = !1,
                    s = new iH,
                    o = new nm,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function u() {
                    l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0
                }

                function c(e, n, r, i) {
                    let a = null !== e ? e.length : 0,
                        u = null;
                    if (0 !== a) {
                        if (u = l.value, !0 !== i || null === u) {
                            let c = r + 4 * a,
                                h = n.matrixWorldInverse;
                            o.getNormalMatrix(h), (null === u || u.length < c) && (u = new Float32Array(c));
                            for (let d = 0, f = r; d !== a; ++d, f += 4) s.copy(e[d]).applyMatrix4(h, o), s.normal.toArray(u, f), u[f + 3] = s.constant
                        }
                        l.value = u, l.needsUpdate = !0
                    }
                    return t.numPlanes = a, t.numIntersection = 0, u
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, a) {
                    let s = 0 !== e.length || t || 0 !== r || i;
                    return i = t, n = c(e, a, 0), r = e.length, s
                }, this.beginShadows = function() {
                    a = !0, c(null)
                }, this.endShadows = function() {
                    a = !1, u()
                }, this.setState = function(t, s, o) {
                    let h = t.clippingPlanes,
                        d = t.clipIntersection,
                        f = t.clipShadows,
                        p = e.get(t);
                    if (i && null !== h && 0 !== h.length && (!a || f)) {
                        let m = a ? 0 : r,
                            g = 4 * m,
                            v = p.clippingState || null;
                        l.value = v, v = c(h, s, g, o);
                        for (let _ = 0; _ !== g; ++_) v[_] = n[_];
                        p.clippingState = v, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += m
                    } else a ? c(null) : u()
                }
            }

            function i6(e) {
                let t = new WeakMap;

                function n(e, t) {
                    return t === ec ? e.mapping = el : t === eh && (e.mapping = eu), e
                }

                function r(e) {
                    let n = e.target;
                    n.removeEventListener("dispose", r);
                    let i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                            let a = i.mapping;
                            if (a === ec || a === eh) {
                                if (t.has(i)) {
                                    let s = t.get(i).texture;
                                    return n(s, i.mapping)
                                } {
                                    let o = i.image;
                                    if (!o || !(o.height > 0)) return null; {
                                        let l = new iz(o.height / 2);
                                        return l.fromEquirectangularTexture(e, i), t.set(i, l), i.addEventListener("dispose", r), n(l.texture, i.mapping)
                                    }
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            class i8 extends iO {
                constructor(e = -1, t = 1, n = 1, r = -1, i = .1, a = 2e3) {
                    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = a, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                }
                setViewOffset(e, t, n, r, i, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2,
                        i = n - e,
                        a = n + e,
                        s = r + t,
                        o = r - t;
                    if (null !== this.view && this.view.enabled) {
                        let l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        i += l * this.view.offsetX, a = i + l * this.view.width, s -= u * this.view.offsetY, o = s - u * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(i, a, s, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }
            let i7 = [.125, .215, .35, .446, .526, .582],
                i9 = new i8,
                ae = new nR,
                at = null,
                an = (1 + Math.sqrt(5)) / 2,
                ar = 1 / an,
                ai = [new nj(1, 1, 1), new nj(-1, 1, 1), new nj(1, 1, -1), new nj(-1, 1, -1), new nj(0, an, ar), new nj(0, an, -ar), new nj(ar, 0, an), new nj(-ar, 0, an), new nj(an, ar, 0), new nj(-an, ar, 0)];
            class aa {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, n = .1, r = 100) {
                    at = this._renderer.getRenderTarget(), this._setSize(256);
                    let i = this._allocateTargets();
                    return i.depthBuffer = !0, this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i
                }
                fromEquirectangular(e, t = null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t = null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = au(), this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = al(), this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                }
                _setSize(e) {
                    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(at), e.scissorTest = !1, ao(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    e.mapping === el || e.mapping === eu ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), at = this._renderer.getRenderTarget();
                    let n = t || this._allocateTargets();
                    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
                }
                _allocateTargets() {
                    let e = 3 * Math.max(this._cubeSize, 112),
                        t = 4 * this._cubeSize,
                        n = {
                            magFilter: eb,
                            minFilter: eb,
                            generateMipmaps: !1,
                            type: eD,
                            format: eB,
                            encoding: tT,
                            depthBuffer: !1
                        },
                        r = as(e, t, n);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
                        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = as(e, t, n);
                        let {
                            _lodMax: i
                        } = this;
                        ({
                            sizeLods: this._sizeLods,
                            lodPlanes: this._lodPlanes,
                            sigmas: this._sigmas
                        } = function(e) {
                            let t = [],
                                n = [],
                                r = [],
                                i = e,
                                a = e - 4 + 1 + i7.length;
                            for (let s = 0; s < a; s++) {
                                let o = Math.pow(2, i);
                                n.push(o);
                                let l = 1 / o;
                                s > e - 4 ? l = i7[s - e + 4 - 1] : 0 === s && (l = 0), r.push(l);
                                let u = 1 / (o - 2),
                                    c = -u,
                                    h = 1 + u,
                                    d = [c, c, h, c, h, h, c, c, h, h, c, h],
                                    f = new Float32Array(108),
                                    p = new Float32Array(72),
                                    m = new Float32Array(36);
                                for (let g = 0; g < 6; g++) {
                                    let v = g % 3 * 2 / 3 - 1,
                                        _ = g > 2 ? 0 : -1,
                                        y = [v, _, 0, v + 2 / 3, _, 0, v + 2 / 3, _ + 1, 0, v, _, 0, v + 2 / 3, _ + 1, 0, v, _ + 1, 0];
                                    f.set(y, 18 * g), p.set(d, 12 * g);
                                    let x = [g, g, g, g, g, g];
                                    m.set(x, 6 * g)
                                }
                                let b = new iu;
                                b.setAttribute("position", new r0(f, 3)), b.setAttribute("uv", new r0(p, 2)), b.setAttribute("faceIndex", new r0(m, 1)), t.push(b), i > 4 && i--
                            }
                            return {
                                lodPlanes: t,
                                sizeLods: n,
                                sigmas: r
                            }
                        }(i)), this._blurMaterial = function(e, t, n) {
                            let r = new Float32Array(20),
                                i = new nj(0, 1, 0),
                                a = new iU({
                                    name: "SphericalGaussianBlur",
                                    defines: {
                                        n: 20,
                                        CUBEUV_TEXEL_WIDTH: 1 / t,
                                        CUBEUV_TEXEL_HEIGHT: 1 / n,
                                        CUBEUV_MAX_MIP: `${e}.0`
                                    },
                                    uniforms: {
                                        envMap: {
                                            value: null
                                        },
                                        samples: {
                                            value: 1
                                        },
                                        weights: {
                                            value: r
                                        },
                                        latitudinal: {
                                            value: !1
                                        },
                                        dTheta: {
                                            value: 0
                                        },
                                        mipInt: {
                                            value: 0
                                        },
                                        poleAxis: {
                                            value: i
                                        }
                                    },
                                    vertexShader: ac(),
                                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                                    blending: w,
                                    depthTest: !1,
                                    depthWrite: !1
                                });
                            return a
                        }(i, e, t)
                    }
                    return r
                }
                _compileMaterial(e) {
                    let t = new iC(this._lodPlanes[0], e);
                    this._renderer.compile(t, i9)
                }
                _sceneToCubeUV(e, t, n, r) {
                    let i = new iF(90, 1, t, n),
                        a = [1, -1, 1, 1, 1, 1],
                        s = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        l = o.autoClear,
                        u = o.toneMapping;
                    o.getClearColor(ae), o.toneMapping = et, o.autoClear = !1;
                    let c = new rJ({
                            name: "PMREM.Background",
                            side: x,
                            depthWrite: !1,
                            depthTest: !1
                        }),
                        h = new iC(new iP, c),
                        d = !1,
                        f = e.background;
                    f ? f.isColor && (c.color.copy(f), e.background = null, d = !0) : (c.color.copy(ae), d = !0);
                    for (let p = 0; p < 6; p++) {
                        let m = p % 3;
                        0 === m ? (i.up.set(0, a[p], 0), i.lookAt(s[p], 0, 0)) : 1 === m ? (i.up.set(0, 0, a[p]), i.lookAt(0, s[p], 0)) : (i.up.set(0, a[p], 0), i.lookAt(0, 0, s[p]));
                        let g = this._cubeSize;
                        ao(r, m * g, p > 2 ? g : 0, g, g), o.setRenderTarget(r), d && o.render(h, i), o.render(e, i)
                    }
                    h.geometry.dispose(), h.material.dispose(), o.toneMapping = u, o.autoClear = l, e.background = f
                }
                _textureToCubeUV(e, t) {
                    let n = this._renderer,
                        r = e.mapping === el || e.mapping === eu;
                    r ? (null === this._cubemapMaterial && (this._cubemapMaterial = au()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = al());
                    let i = r ? this._cubemapMaterial : this._equirectMaterial,
                        a = new iC(this._lodPlanes[0], i),
                        s = i.uniforms;
                    s.envMap.value = e;
                    let o = this._cubeSize;
                    ao(t, 0, 0, 3 * o, 2 * o), n.setRenderTarget(t), n.render(a, i9)
                }
                _applyPMREM(e) {
                    let t = this._renderer,
                        n = t.autoClear;
                    t.autoClear = !1;
                    for (let r = 1; r < this._lodPlanes.length; r++) {
                        let i = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
                            a = ai[(r - 1) % ai.length];
                        this._blur(e, r - 1, r, i, a)
                    }
                    t.autoClear = n
                }
                _blur(e, t, n, r, i) {
                    let a = this._pingPongRenderTarget;
                    this._halfBlur(e, a, t, n, r, "latitudinal", i), this._halfBlur(a, e, n, n, r, "longitudinal", i)
                }
                _halfBlur(e, t, n, r, i, a, s) {
                    let o = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                    let u = new iC(this._lodPlanes[r], l),
                        c = l.uniforms,
                        h = this._sizeLods[n] - 1,
                        d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                        f = i / d,
                        p = isFinite(i) ? 1 + Math.floor(3 * f) : 20;
                    p > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
                    let m = [],
                        g = 0;
                    for (let v = 0; v < 20; ++v) {
                        let _ = v / f,
                            y = Math.exp(-_ * _ / 2);
                        m.push(y), 0 === v ? g += y : v < p && (g += 2 * y)
                    }
                    for (let x = 0; x < m.length; x++) m[x] = m[x] / g;
                    c.envMap.value = e.texture, c.samples.value = p, c.weights.value = m, c.latitudinal.value = "latitudinal" === a, s && (c.poleAxis.value = s);
                    let {
                        _lodMax: b
                    } = this;
                    c.dTheta.value = d, c.mipInt.value = b - n;
                    let w = this._sizeLods[r],
                        S = 4 * (this._cubeSize - w);
                    ao(t, 3 * w * (r > b - 4 ? r - b + 4 : 0), S, 3 * w, 2 * w), o.setRenderTarget(t), o.render(u, i9)
                }
            }

            function as(e, t, n) {
                let r = new nN(e, t, n);
                return r.texture.mapping = ed, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
            }

            function ao(e, t, n, r, i) {
                e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
            }

            function al() {
                return new iU({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: ac(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                    blending: w,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function au() {
                return new iU({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: ac(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                    blending: w,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function ac() {
                return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
            }

            function ah(e) {
                let t = new WeakMap,
                    n = null;

                function r(e) {
                    let n = e.target;
                    n.removeEventListener("dispose", r);
                    let i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture) {
                            let a = i.mapping,
                                s = a === ec || a === eh,
                                o = a === el || a === eu;
                            if (s || o) {
                                if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                    i.needsPMREMUpdate = !1;
                                    let l = t.get(i);
                                    return null === n && (n = new aa(e)), l = s ? n.fromEquirectangular(i, l) : n.fromCubemap(i, l), t.set(i, l), l.texture
                                }
                                if (t.has(i)) return t.get(i).texture; {
                                    let u = i.image;
                                    if (!(s && u && u.height > 0 || o && u && function(e) {
                                            let t = 0;
                                            for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                            return 6 === t
                                        }(u))) return null; {
                                        null === n && (n = new aa(e));
                                        let c = s ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                        return t.set(i, c), i.addEventListener("dispose", r), c.texture
                                    }
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap, null !== n && (n.dispose(), n = null)
                    }
                }
            }

            function ad(e) {
                let t = {};

                function n(n) {
                    let r;
                    if (void 0 !== t[n]) return t[n];
                    switch (n) {
                        case "WEBGL_depth_texture":
                            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            r = e.getExtension(n)
                    }
                    return t[n] = r, r
                }
                return {
                    has: function(e) {
                        return null !== n(e)
                    },
                    init: function(e) {
                        e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(e) {
                        let t = n(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function af(e, t, n, r) {
                let i = {},
                    a = new WeakMap;

                function s(e) {
                    let o = e.target;
                    for (let l in null !== o.index && t.remove(o.index), o.attributes) t.remove(o.attributes[l]);
                    o.removeEventListener("dispose", s), delete i[o.id];
                    let u = a.get(o);
                    u && (t.remove(u), a.delete(o)), r.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
                }

                function o(e) {
                    let n = [],
                        r = e.index,
                        i = e.attributes.position,
                        s = 0;
                    if (null !== r) {
                        let o = r.array;
                        s = r.version;
                        for (let l = 0, u = o.length; l < u; l += 3) {
                            let c = o[l + 0],
                                h = o[l + 1],
                                d = o[l + 2];
                            n.push(c, h, h, d, d, c)
                        }
                    } else {
                        let f = i.array;
                        s = i.version;
                        for (let p = 0, m = f.length / 3 - 1; p < m; p += 3) {
                            let g = p + 0,
                                v = p + 1,
                                _ = p + 2;
                            n.push(g, v, v, _, _, g)
                        }
                    }
                    let y = new(nv(n) ? r8 : r5)(n, 1);
                    y.version = s;
                    let x = a.get(e);
                    x && t.remove(x), a.set(e, y)
                }
                return {
                    get: function(e, t) {
                        return !0 === i[t.id] || (t.addEventListener("dispose", s), i[t.id] = !0, n.memory.geometries++), t
                    },
                    update: function(e) {
                        let n = e.attributes;
                        for (let r in n) t.update(n[r], 34962);
                        let i = e.morphAttributes;
                        for (let a in i) {
                            let s = i[a];
                            for (let o = 0, l = s.length; o < l; o++) t.update(s[o], 34962)
                        }
                    },
                    getWireframeAttribute: function(e) {
                        let t = a.get(e);
                        if (t) {
                            let n = e.index;
                            null !== n && t.version < n.version && o(e)
                        } else o(e);
                        return a.get(e)
                    }
                }
            }

            function ap(e, t, n, r) {
                let i, a, s;
                let o = r.isWebGL2;
                this.setMode = function(e) {
                    i = e
                }, this.setIndex = function(e) {
                    a = e.type, s = e.bytesPerElement
                }, this.render = function(t, r) {
                    e.drawElements(i, r, a, t * s), n.update(r, i, 1)
                }, this.renderInstances = function(r, l, u) {
                    let c, h;
                    if (0 !== u) {
                        if (o) c = e, h = "drawElementsInstanced";
                        else if (c = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === c) {
                            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            return
                        }
                        c[h](i, l, a, r * s, u), n.update(l, i, u)
                    }
                }, this.renderMultiDraw = function(e, r, s) {
                    let o = t.get("WEBGL_multi_draw");
                    if (null === o) {
                        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.BatchedMesh but hardware does not support extension WEBGL_multi_draw.");
                        return
                    }
                    o.multiDrawElementsWEBGL(i, r, 0, a, e, 0, s);
                    let l = r.reduce((e, t) => e + t, 0);
                    n.update(l, i, 1)
                }, this.renderInstancesMultiDraw = function(e, r, o, l) {
                    let u = t.get("WEBGL_multi_draw");
                    if (null === u)
                        for (let c = 0; c < e.length; c++) this.renderInstances(e[c] / s, r[c], o[c]), n.update(r[c], i, o[c]);
                    else {
                        u.multiDrawElementsInstancedWEBGL(i, r, 0, a, e, 0, o, 0, l);
                        let h = r.reduce((e, t) => e + t, 0),
                            d = o.reduce((e, t) => e + t, 0);
                        n.update(h, i, d)
                    }
                }
            }

            function am(e) {
                let t = {
                        frame: 0,
                        calls: 0,
                        counts: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    },
                    n = {
                        frame: 0,
                        calls: 0,
                        counts: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    instance: n,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0, t.counts = 0, n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0, n.counts = 0
                    },
                    update: function(e, r, i) {
                        t.calls++;
                        let a = t;
                        switch (i > 1 && (a = n), a.counts += i, a.calls++, r) {
                            case 4:
                                a.triangles += e / 3;
                                break;
                            case 1:
                                a.lines += e / 2;
                                break;
                            case 3:
                                a.lines += e - 1;
                                break;
                            case 2:
                                a.lines += e;
                                break;
                            case 0:
                                a.points += e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }

            function ag(e, t) {
                return e[0] - t[0]
            }

            function av(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function a_(e, t, n) {
                let r = {},
                    i = new Float32Array(8),
                    a = new WeakMap,
                    s = new nF,
                    o = [];
                for (let l = 0; l < 8; l++) o[l] = [l, 0];
                return {
                    update: function(l, u, c, h) {
                        let d = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            let f = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
                                p = void 0 !== f ? f.length : 0,
                                m = a.get(u);
                            if (void 0 === m || m.count !== p) {
                                void 0 !== m && m.texture.dispose();
                                let g = void 0 !== u.morphAttributes.position,
                                    v = void 0 !== u.morphAttributes.normal,
                                    _ = void 0 !== u.morphAttributes.color,
                                    y = u.morphAttributes.position || [],
                                    x = u.morphAttributes.normal || [],
                                    b = u.morphAttributes.color || [],
                                    w = 0;
                                !0 === g && (w = 1), !0 === v && (w = 2), !0 === _ && (w = 3);
                                let S = u.attributes.position.count * w,
                                    M = 1;
                                S > t.maxTextureSize && (M = Math.ceil(S / t.maxTextureSize), S = t.maxTextureSize);
                                let T = new Float32Array(S * M * 4 * p),
                                    A = new nB(T, S, M, p);
                                A.type = eL, A.needsUpdate = !0;
                                let E = 4 * w;
                                for (let C = 0; C < p; C++) {
                                    let I = y[C],
                                        P = x[C],
                                        R = b[C],
                                        L = S * M * 4 * C;
                                    for (let D = 0; D < I.count; D++) {
                                        let k = D * E;
                                        !0 === g && (s.fromBufferAttribute(I, D), T[L + k + 0] = s.x, T[L + k + 1] = s.y, T[L + k + 2] = s.z, T[L + k + 3] = 0), !0 === v && (s.fromBufferAttribute(P, D), T[L + k + 4] = s.x, T[L + k + 5] = s.y, T[L + k + 6] = s.z, T[L + k + 7] = 0), !0 === _ && (s.fromBufferAttribute(R, D), T[L + k + 8] = s.x, T[L + k + 9] = s.y, T[L + k + 10] = s.z, T[L + k + 11] = 4 === R.itemSize ? s.w : 1)
                                    }
                                }
                                m = {
                                    count: p,
                                    texture: A,
                                    size: new np(S, M)
                                }, a.set(u, m), u.addEventListener("dispose", function e() {
                                    A.dispose(), a.delete(u), u.removeEventListener("dispose", e)
                                })
                            }
                            let U = void 0 === d ? 0 : d.length,
                                O = 0;
                            for (let F = 0; F < U; F++) O += d[F];
                            let N = u.morphTargetsRelative ? 1 : 1 - O;
                            h.getUniforms().setValue(e, "morphTargetBaseInfluence", N), void 0 !== d && h.getUniforms().setValue(e, "morphTargetInfluences", d), h.getUniforms().setValue(e, "morphTargetsTexture", m.texture, n), h.getUniforms().setValue(e, "morphTargetsTextureSize", m.size)
                        } else {
                            let B = void 0 === d ? 0 : d.length,
                                z = r[u.id];
                            if (void 0 === z || z.length !== B) {
                                z = [];
                                for (let G = 0; G < B; G++) z[G] = [G, 0];
                                r[u.id] = z
                            }
                            for (let V = 0; V < B; V++) {
                                let W = z[V];
                                W[0] = V, W[1] = d[V]
                            }
                            z.sort(av);
                            for (let H = 0; H < 8; H++) H < B && z[H][1] ? (o[H][0] = z[H][0], o[H][1] = z[H][1]) : (o[H][0] = Number.MAX_SAFE_INTEGER, o[H][1] = 0);
                            o.sort(ag);
                            let j = u.morphAttributes.position,
                                q = u.morphAttributes.normal,
                                X = 0;
                            for (let Z = 0; Z < 8; Z++) {
                                let Y = o[Z],
                                    $ = Y[0],
                                    J = Y[1];
                                $ !== Number.MAX_SAFE_INTEGER && J ? (j && u.getAttribute("morphTarget" + Z) !== j[$] && u.setAttribute("morphTarget" + Z, j[$]), q && u.getAttribute("morphNormal" + Z) !== q[$] && u.setAttribute("morphNormal" + Z, q[$]), i[Z] = J, X += J) : (j && !0 === u.hasAttribute("morphTarget" + Z) && u.deleteAttribute("morphTarget" + Z), q && !0 === u.hasAttribute("morphNormal" + Z) && u.deleteAttribute("morphNormal" + Z), i[Z] = 0)
                            }
                            let K = u.morphTargetsRelative ? 1 : 1 - X;
                            h.getUniforms().setValue(e, "morphTargetBaseInfluence", K), h.getUniforms().setValue(e, "morphTargetInfluences", i)
                        }
                    }
                }
            }

            function ay(e, t, n, r) {
                let i = new WeakMap;

                function a(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", a), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }

                function s(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", s), null !== t.textureId && n.remove(t.textureId)
                }
                return {
                    update: function(e, o) {
                        let l = r.render.frame,
                            u = o || e.geometry,
                            c = t.get(e, u);
                        return i.get(c) !== l && (t.update(c), i.set(c, l)), !o && (e.isBatchedMesh && !1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", a) && e.addEventListener("dispose", a), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962))), c
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            let ax = new nO,
                ab = new nB,
                aw = new nG,
                aS = new iB,
                aM = [],
                aT = [],
                aA = new Float32Array(16),
                aE = new Float32Array(9),
                aC = new Float32Array(4);

            function aI(e, t, n) {
                let r = e[0];
                if (r <= 0 || r > 0) return e;
                let i = t * n,
                    a = aM[i];
                if (void 0 === a && (a = new Float32Array(i), aM[i] = a), 0 !== t) {
                    r.toArray(a, 0);
                    for (let s = 1, o = 0; s !== t; ++s) o += n, e[s].toArray(a, o)
                }
                return a
            }

            function aP(e, t) {
                if (e.length !== t.length) return !1;
                for (let n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function aR(e, t) {
                for (let n = 0, r = t.length; n < r; n++) e[n] = t[n]
            }

            function aL(e, t) {
                let n = aT[t];
                void 0 === n && (n = new Int32Array(t), aT[t] = n);
                for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
                return n
            }

            function aD(e, t) {
                let n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function ak(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (aP(n, t)) return;
                    e.uniform2fv(this.addr, t), aR(n, t)
                }
            }

            function aU(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r)(n[0] !== t.r || n[1] !== t.g || n[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (aP(n, t)) return;
                    e.uniform3fv(this.addr, t), aR(n, t)
                }
            }

            function aO(e, t) {
                let n = this.cache;
                if (void 0 !== t.x)(n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (aP(n, t)) return;
                    e.uniform4fv(this.addr, t), aR(n, t)
                }
            }

            function aF(e, t) {
                let n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (aP(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), aR(n, t)
                } else {
                    if (aP(n, r)) return;
                    aC.set(r), e.uniformMatrix2fv(this.addr, !1, aC), aR(n, r)
                }
            }

            function aN(e, t) {
                let n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (aP(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), aR(n, t)
                } else {
                    if (aP(n, r)) return;
                    aE.set(r), e.uniformMatrix3fv(this.addr, !1, aE), aR(n, r)
                }
            }

            function aB(e, t) {
                let n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (aP(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), aR(n, t)
                } else {
                    if (aP(n, r)) return;
                    aA.set(r), e.uniformMatrix4fv(this.addr, !1, aA), aR(n, r)
                }
            }

            function az(e, t) {
                let n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function aG(e, t) {
                let n = this.cache;
                aP(n, t) || (e.uniform2iv(this.addr, t), aR(n, t))
            }

            function aV(e, t) {
                let n = this.cache;
                aP(n, t) || (e.uniform3iv(this.addr, t), aR(n, t))
            }

            function aW(e, t) {
                let n = this.cache;
                aP(n, t) || (e.uniform4iv(this.addr, t), aR(n, t))
            }

            function aH(e, t) {
                let n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }

            function aj(e, t) {
                let n = this.cache;
                aP(n, t) || (e.uniform2uiv(this.addr, t), aR(n, t))
            }

            function aq(e, t) {
                let n = this.cache;
                aP(n, t) || (e.uniform3uiv(this.addr, t), aR(n, t))
            }

            function aX(e, t) {
                let n = this.cache;
                aP(n, t) || (e.uniform4uiv(this.addr, t), aR(n, t))
            }

            function aZ(e, t, n) {
                let r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(t || ax, i)
            }

            function aY(e, t, n) {
                let r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || aw, i)
            }

            function a$(e, t, n) {
                let r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || aS, i)
            }

            function aJ(e, t, n) {
                let r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || ab, i)
            }

            function aK(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function aQ(e, t) {
                let n = aI(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function a0(e, t) {
                let n = aI(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function a1(e, t) {
                let n = aI(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function a2(e, t) {
                let n = aI(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function a3(e, t) {
                let n = aI(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function a4(e, t) {
                let n = aI(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function a5(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function a6(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function a8(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function a7(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function a9(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function se(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function st(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function sn(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function sr(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    a = aL(n, i);
                aP(r, a) || (e.uniform1iv(this.addr, a), aR(r, a));
                for (let s = 0; s !== i; ++s) n.setTexture2D(t[s] || ax, a[s])
            }

            function si(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    a = aL(n, i);
                aP(r, a) || (e.uniform1iv(this.addr, a), aR(r, a));
                for (let s = 0; s !== i; ++s) n.setTexture3D(t[s] || aw, a[s])
            }

            function sa(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    a = aL(n, i);
                aP(r, a) || (e.uniform1iv(this.addr, a), aR(r, a));
                for (let s = 0; s !== i; ++s) n.setTextureCube(t[s] || aS, a[s])
            }

            function ss(e, t, n) {
                let r = this.cache,
                    i = t.length,
                    a = aL(n, i);
                aP(r, a) || (e.uniform1iv(this.addr, a), aR(r, a));
                for (let s = 0; s !== i; ++s) n.setTexture2DArray(t[s] || ab, a[s])
            }
            class so {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return aD;
                            case 35664:
                                return ak;
                            case 35665:
                                return aU;
                            case 35666:
                                return aO;
                            case 35674:
                                return aF;
                            case 35675:
                                return aN;
                            case 35676:
                                return aB;
                            case 5124:
                            case 35670:
                                return az;
                            case 35667:
                            case 35671:
                                return aG;
                            case 35668:
                            case 35672:
                                return aV;
                            case 35669:
                            case 35673:
                                return aW;
                            case 5125:
                                return aH;
                            case 36294:
                                return aj;
                            case 36295:
                                return aq;
                            case 36296:
                                return aX;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return aZ;
                            case 35679:
                            case 36299:
                            case 36307:
                                return aY;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return a$;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return aJ
                        }
                    }(t.type)
                }
            }
            class sl {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return aK;
                            case 35664:
                                return aQ;
                            case 35665:
                                return a0;
                            case 35666:
                                return a1;
                            case 35674:
                                return a2;
                            case 35675:
                                return a3;
                            case 35676:
                                return a4;
                            case 5124:
                            case 35670:
                                return a5;
                            case 35667:
                            case 35671:
                                return a6;
                            case 35668:
                            case 35672:
                                return a8;
                            case 35669:
                            case 35673:
                                return a7;
                            case 5125:
                                return a9;
                            case 36294:
                                return se;
                            case 36295:
                                return st;
                            case 36296:
                                return sn;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return sr;
                            case 35679:
                            case 36299:
                            case 36307:
                                return si;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return sa;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return ss
                        }
                    }(t.type)
                }
            }
            class su {
                constructor(e) {
                    this.id = e, this.seq = [], this.map = {}
                }
                setValue(e, t, n) {
                    let r = this.seq;
                    for (let i = 0, a = r.length; i !== a; ++i) {
                        let s = r[i];
                        s.setValue(e, t[s.id], n)
                    }
                }
            }
            let sc = /(\w+)(\])?(\[|\.)?/g;

            function sh(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }
            class sd {
                constructor(e, t) {
                    this.seq = [], this.map = {};
                    let n = e.getProgramParameter(t, 35718);
                    for (let r = 0; r < n; ++r) {
                        let i = e.getActiveUniform(t, r),
                            a = e.getUniformLocation(t, i.name);
                        ! function(e, t, n) {
                            let r = e.name,
                                i = r.length;
                            for (sc.lastIndex = 0;;) {
                                let a = sc.exec(r),
                                    s = sc.lastIndex,
                                    o = a[1],
                                    l = "]" === a[2],
                                    u = a[3];
                                if (l && (o |= 0), void 0 === u || "[" === u && s + 2 === i) {
                                    sh(n, void 0 === u ? new so(o, e, t) : new sl(o, e, t));
                                    break
                                } {
                                    let c = n.map,
                                        h = c[o];
                                    void 0 === h && sh(n, h = new su(o)), n = h
                                }
                            }
                        }(i, a, this)
                    }
                }
                setValue(e, t, n, r) {
                    let i = this.map[t];
                    void 0 !== i && i.setValue(e, n, r)
                }
                setOptional(e, t, n) {
                    let r = t[n];
                    void 0 !== r && this.setValue(e, n, r)
                }
                static upload(e, t, n, r) {
                    for (let i = 0, a = t.length; i !== a; ++i) {
                        let s = t[i],
                            o = n[s.id];
                        !1 !== o.needsUpdate && s.setValue(e, o.value, r)
                    }
                }
                static seqWithValue(e, t) {
                    let n = [];
                    for (let r = 0, i = e.length; r !== i; ++r) {
                        let a = e[r];
                        a.id in t && n.push(a)
                    }
                    return n
                }
            }

            function sf(e, t, n) {
                let r = e.createShader(t);
                return e.shaderSource(r, n), e.compileShader(r), r
            }
            let sp = 0;

            function sm(e, t, n) {
                let r = e.getShaderParameter(t, 35713),
                    i = e.getShaderInfoLog(t).trim();
                if (r && "" === i) return "";
                let a = /ERROR: 0:(\d+)/.exec(i);
                if (!a) return i; {
                    let s = parseInt(a[1]);
                    return n.toUpperCase() + "\n\n" + i + "\n\n" + function(e, t) {
                        let n = e.split("\n"),
                            r = [],
                            i = Math.max(t - 6, 0),
                            a = Math.min(t + 6, n.length);
                        for (let s = i; s < a; s++) {
                            let o = s + 1;
                            r.push(`${o===t?">":" "} ${o}: ${n[s]}`)
                        }
                        return r.join("\n")
                    }(e.getShaderSource(t), s)
                }
            }

            function sg(e) {
                return "" !== e
            }

            function sv(e, t) {
                let n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function s_(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            let sy = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function sx(e) {
                return e.replace(sy, sb)
            }

            function sb(e, t) {
                let n = iJ[t];
                if (void 0 === n) throw Error("Can not resolve #include <" + t + ">");
                return sx(n)
            }
            let sw = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function sS(e) {
                return e.replace(sw, sM)
            }

            function sM(e, t, n, r) {
                let i = "";
                for (let a = parseInt(t); a < parseInt(n); a++) i += r.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
                return i
            }

            function sT(e) {
                let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function sA(e) {
                let t = "";
                if (e && Object.keys(e).length)
                    for (let n in t = "\n", e) t += "#define USE_BATCHING_UNIFORM_" + n + "\nuniform sampler2D batching_" + n + "_texture;\n";
                return t
            }

            function sE(e, t, n, r) {
                let i, a, s, o, l, u, c;
                let h = e.getContext(),
                    d = n.defines,
                    f = n.vertexShader,
                    p = n.fragmentShader,
                    m = (u = "SHADOWMAP_TYPE_BASIC", n.shadowMapType === g ? u = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === v ? u = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === _ && (u = "SHADOWMAP_TYPE_VSM"), u),
                    y = function(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case el:
                            case eu:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case ed:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    x = (c = "ENVMAP_MODE_REFLECTION", n.envMap && n.envMapMode === eu && (c = "ENVMAP_MODE_REFRACTION"), c),
                    b = function(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case K:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case Q:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case ee:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    w = function(e) {
                        let t = e.envMapCubeUVHeight;
                        if (null === t) return null;
                        let n = Math.log2(t) - 2;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                            texelHeight: 1 / t,
                            maxMip: n
                        }
                    }(n),
                    S = n.isWebGL2 ? "" : function(e) {
                        let t = [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                        return t.filter(sg).join("\n")
                    }(n),
                    M = function(e) {
                        let t = [];
                        for (let n in e) {
                            let r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(d),
                    T = h.createProgram(),
                    A = n.glslVersion ? "#version " + n.glslVersion + "\n" : "",
                    E = n.numMultiviewViews;
                n.isRawShaderMaterial ? ((i = [M].filter(sg).join("\n")).length > 0 && (i += "\n"), (a = [S, M].filter(sg).join("\n")).length > 0 && (a += "\n")) : (i = [sT(n), "#define SHADER_NAME " + n.shaderName, M, n.transformFeedback ? "#define USE_TRANSFORMFEEDBACK" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingInstancing ? "#define USE_BATCHING_INSTANCING" : "", n.batchingArrayMap ? "#define USE_BATCHING_ARRAYMAP" : "", sA(n.batchUniforms), n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + x : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.cellShading ? "#define USE_CELLSHADING" : "", n.cellShading ? "uniform bool isBackSide;" : "", n.cellShadingThickness ? "#define CELLSHADING_THICKNESS " + n.cellShadingThickness.toFixed(2) : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(sg).join("\n"), a = [S, sT(n), "#define SHADER_NAME " + n.shaderName, M, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingInstancing ? "#define USE_BATCHING_INSTANCING" : "", n.batchingArrayMap ? "#define USE_BATCHING_ARRAYMAP" : "", sA(n.batchUniforms), n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + y : "", n.envMap ? "#define " + x : "", n.envMap ? "#define " + b : "", w ? "#define CUBEUV_TEXEL_WIDTH " + w.texelWidth : "", w ? "#define CUBEUV_TEXEL_HEIGHT " + w.texelHeight : "", w ? "#define CUBEUV_MAX_MIP " + w.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.cellShading ? "#define USE_CELLSHADING" : "", n.cellShading ? "uniform bool isBackSide;" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== et ? "#define TONE_MAPPING" : "", n.toneMapping !== et ? iJ.tonemapping_pars_fragment : "", n.toneMapping !== et ? function(e, t) {
                    let n;
                    switch (t) {
                        case en:
                            n = "Linear";
                            break;
                        case er:
                            n = "Reinhard";
                            break;
                        case ei:
                            n = "OptimizedCineon";
                            break;
                        case ea:
                            n = "ACESFilmic";
                            break;
                        case es:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", iJ.encodings_pars_fragment, function(e, t) {
                    let n = function(e) {
                        switch (e) {
                            case tT:
                                return ["Linear", "( value )"];
                            case tA:
                                return ["sRGB", "( value )"];
                            default:
                                return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
                        }
                    }(t);
                    return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                }("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(sg).join("\n")), f = s_(f = sv(f = sx(f), n), n), p = s_(p = sv(p = sx(p), n), n), f = sS(f), p = sS(p), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (A = "#version 300 es\n", i = [n.rendererExtensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "", n.rendererExtensionMultiDraw ? "#define MultiDraw" : "", "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, a = ["#define varying in", n.glslVersion === t6 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === t6 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + a, E > 0 && (i = (i = "#extension GL_OVR_multiview : require\n" + i + ["layout(num_views = " + E + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n") + "\n").replace("uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;", ["uniform mat4 modelViewMatrices[" + E + "];", "uniform mat4 projectionMatrices[" + E + "];", "uniform mat4 viewMatrices[" + E + "];", "uniform mat3 normalMatrices[" + E + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), a = (a = "#extension GL_OVR_multiview : require\n#define VIEW_ID gl_ViewID_OVR\n" + a).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + E + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n"))));
                let C = A + i + f,
                    I = A + a + p,
                    P = sf(h, 35633, C),
                    R = sf(h, 35632, I);
                if (h.attachShader(T, P), h.attachShader(T, R), void 0 !== n.index0AttributeName ? h.bindAttribLocation(T, 0, n.index0AttributeName) : !0 === n.morphTargets && h.bindAttribLocation(T, 0, "position"), n.sortAttributes) {
                    let L = Object.values(n.sortAttributes);
                    for (let D = 0; D < L.length; D++) h.bindAttribLocation(T, D, L[D]);
                    h.bindAttribLocation(T, L.length + 1, "position")
                }

                function k() {
                    if (e.debug.checkShaderErrors) {
                        let t = h.getProgramInfoLog(T).trim(),
                            r = h.getShaderInfoLog(P).trim(),
                            l = h.getShaderInfoLog(R).trim(),
                            u = !0,
                            c = !0;
                        if (!1 === h.getProgramParameter(T, 35714)) {
                            u = !1;
                            let d = sm(h, P, "vertex"),
                                f = sm(h, R, "fragment");
                            console.error("THREE.WebGLProgram: " + n.shaderName + " Shader Error " + h.getError() + " - VALIDATE_STATUS " + h.getProgramParameter(T, 35715) + "\n\nProgram Info Log: " + t + "\n" + d + "\n" + f)
                        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : ("" === r || "" === l) && (c = !1);
                        c && (this.diagnostics = {
                            runnable: u,
                            programLog: t,
                            vertexShader: {
                                log: r,
                                prefix: i
                            },
                            fragmentShader: {
                                log: l,
                                prefix: a
                            }
                        })
                    }
                    h.deleteShader(P), h.deleteShader(R), s = new sd(h, T), o = function(e, t) {
                        let n = {},
                            r = e.getProgramParameter(t, 35721);
                        for (let i = 0; i < r; i++) {
                            let a = e.getActiveAttrib(t, i),
                                s = a.name,
                                o = 1;
                            35674 === a.type && (o = 2), 35675 === a.type && (o = 3), 35676 === a.type && (o = 4), n[s] = {
                                type: a.type,
                                location: e.getAttribLocation(t, s),
                                locationSize: o
                            }
                        }
                        return n
                    }(h, T)
                }
                n.transformFeedbackVaryings && h.transformFeedbackVaryings(T, Object.keys(n.transformFeedbackVaryings), h.INTERLEAVED_ATTRIBS), h.linkProgram(T), n.transformFeedbackVaryings && (this.transformFeedback = h.createTransformFeedback()), this.getUniforms = function() {
                    return void 0 === s && k.call(this), s
                }, this.getAttributes = function() {
                    return void 0 === o && k.call(this), o
                }, this.getFeedbackVaryings = function() {
                    return k.call(this), l
                };
                let U = !n.rendererExtensionParallelShaderCompile;
                return this.isReady = function() {
                    return U || (U = h.getProgramParameter(T, 37297)), U
                }, this.destroy = function() {
                    r.releaseStatesOfProgram(this), h.deleteProgram(T), this.program = void 0, this.transformFeedbackVaryings && h.deleteTransformFeedback(this.transformFeedback)
                }, this.name = n.shaderName, this.id = sp++, this.cacheKey = t, this.usedTimes = 1, this.program = T, this.vertexShader = P, this.fragmentShader = R, this.numMultiviewViews = E, this
            }
            let sC = 0;
            class sI {
                constructor() {
                    this.shaderCache = new Map, this.materialCache = new Map
                }
                update(e) {
                    let t = e.vertexShader,
                        n = e.fragmentShader,
                        r = this._getShaderStage(t),
                        i = this._getShaderStage(n),
                        a = this._getShaderCacheForMaterial(e);
                    return !1 === a.has(r) && (a.add(r), r.usedTimes++), !1 === a.has(i) && (a.add(i), i.usedTimes++), this
                }
                remove(e) {
                    let t = this.materialCache.get(e);
                    for (let n of t) n.usedTimes--, 0 === n.usedTimes && this.shaderCache.delete(n.code);
                    return this.materialCache.delete(e), this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(), this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    let t = this.materialCache,
                        n = t.get(e);
                    return void 0 === n && (n = new Set, t.set(e, n)), n
                }
                _getShaderStage(e) {
                    let t = this.shaderCache,
                        n = t.get(e);
                    return void 0 === n && (n = new sP(e), t.set(e, n)), n
                }
            }
            class sP {
                constructor(e) {
                    this.id = sC++, this.code = e, this.usedTimes = 0
                }
            }

            function sR(e, t, n, r, i, a, s) {
                let o = new rS,
                    l = new sI,
                    u = [],
                    c = i.isWebGL2,
                    h = i.logarithmicDepthBuffer,
                    d = i.vertexTextures,
                    f = i.precision,
                    p = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };
                return {
                    getParameters: function(a, o, u, m, g) {
                        let v, _, y, w;
                        let M = m.fog,
                            T = g && g.geometry,
                            A = a.isMeshStandardMaterial ? m.environment : null,
                            E = (a.isMeshStandardMaterial ? n : t).get(a.envMap || A),
                            C = E && E.mapping === ed ? E.image.height : null,
                            I = p[a.type];
                        null !== a.precision && (f = i.getMaxPrecision(a.precision)) !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", f, "instead.");
                        let P = T ? T.morphAttributes.position || T.morphAttributes.normal || T.morphAttributes.color : void 0,
                            R = void 0 !== P ? P.length : 0,
                            L = 0;
                        if (T && void 0 !== T.morphAttributes.position && (L = 1), T && void 0 !== T.morphAttributes.normal && (L = 2), T && void 0 !== T.morphAttributes.color && (L = 3), I) {
                            let D = iQ[I];
                            v = D.vertexShader, _ = D.fragmentShader
                        } else v = a.vertexShader, _ = a.fragmentShader, l.update(a), y = l.getVertexShaderID(a), w = l.getFragmentShaderID(a);
                        let k = e.getRenderTarget(),
                            U = a.alphaTest > 0,
                            O = a.clearcoat > 0,
                            F = a.iridescence > 0,
                            N = k && k.isWebGLMultiviewRenderTarget ? k.numViews : 0,
                            B = {
                                isWebGL2: c,
                                shaderID: I,
                                shaderName: a.type,
                                vertexShader: v,
                                fragmentShader: _,
                                defines: a.defines,
                                numMultiviewViews: N,
                                customVertexShaderID: y,
                                customFragmentShaderID: w,
                                isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                                glslVersion: a.glslVersion,
                                precision: f,
                                instancing: g && !0 === g.isInstancedMesh,
                                instancingColor: g && !0 === g.isInstancedMesh && null !== g.instanceColor,
                                supportsVertexTextures: d,
                                outputEncoding: null === k ? e.outputEncoding : !0 === k.isXRRenderTarget ? k.texture.encoding : tT,
                                map: !!a.map,
                                matcap: !!a.matcap,
                                envMap: !!E,
                                envMapMode: E && E.mapping,
                                envMapCubeUVHeight: C,
                                lightMap: !!a.lightMap,
                                aoMap: !!a.aoMap,
                                emissiveMap: !!a.emissiveMap,
                                bumpMap: !!a.bumpMap,
                                normalMap: !!a.normalMap,
                                objectSpaceNormalMap: a.normalMapType === tP,
                                tangentSpaceNormalMap: a.normalMapType === tI,
                                decodeVideoTexture: !!a.map && !0 === a.map.isVideoTexture && a.map.encoding === tA,
                                clearcoat: O,
                                clearcoatMap: O && !!a.clearcoatMap,
                                clearcoatRoughnessMap: O && !!a.clearcoatRoughnessMap,
                                clearcoatNormalMap: O && !!a.clearcoatNormalMap,
                                iridescence: F,
                                iridescenceMap: F && !!a.iridescenceMap,
                                iridescenceThicknessMap: F && !!a.iridescenceThicknessMap,
                                displacementMap: !!a.displacementMap,
                                roughnessMap: !!a.roughnessMap,
                                metalnessMap: !!a.metalnessMap,
                                specularMap: !!a.specularMap,
                                specularIntensityMap: !!a.specularIntensityMap,
                                specularColorMap: !!a.specularColorMap,
                                opaque: !1 === a.transparent && a.blending === S,
                                alphaMap: !!a.alphaMap,
                                alphaTest: U,
                                gradientMap: !!a.gradientMap,
                                sheen: a.sheen > 0,
                                sheenColorMap: !!a.sheenColorMap,
                                sheenRoughnessMap: !!a.sheenRoughnessMap,
                                transmission: a.transmission > 0,
                                transmissionMap: !!a.transmissionMap,
                                thicknessMap: !!a.thicknessMap,
                                combine: a.combine,
                                vertexTangents: !!a.normalMap && !!T && T.attributes.tangent,
                                vertexColors: a.vertexColors,
                                vertexAlphas: !0 === a.vertexColors && !!T && T.attributes.color && 4 === T.attributes.color.itemSize,
                                vertexUvs: !!a.map || !!a.bumpMap || !!a.normalMap || !!a.specularMap || !!a.alphaMap || !!a.emissiveMap || !!a.roughnessMap || !!a.metalnessMap || !!a.clearcoatMap || !!a.clearcoatRoughnessMap || !!a.clearcoatNormalMap || !!a.iridescenceMap || !!a.iridescenceThicknessMap || !!a.displacementMap || !!a.transmissionMap || !!a.thicknessMap || !!a.specularIntensityMap || !!a.specularColorMap || !!a.sheenColorMap || !!a.sheenRoughnessMap,
                                uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.iridescenceMap || a.iridescenceThicknessMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheen > 0 || a.sheenColorMap || a.sheenRoughnessMap) && !!a.displacementMap,
                                fog: !!M,
                                useFog: !0 === a.fog,
                                fogExp2: M && M.isFogExp2,
                                flatShading: !!a.flatShading,
                                sizeAttenuation: a.sizeAttenuation,
                                logarithmicDepthBuffer: h,
                                skinning: g && !0 === g.isSkinnedMesh,
                                cellShading: !0 === a.cellShading,
                                cellShadingThickness: a.cellShadingThickness,
                                morphTargets: T && void 0 !== T.morphAttributes.position,
                                morphNormals: T && void 0 !== T.morphAttributes.normal,
                                morphColors: T && void 0 !== T.morphAttributes.color,
                                morphTargetsCount: R,
                                morphTextureStride: L,
                                numDirLights: o.directional.length,
                                numPointLights: o.point.length,
                                numSpotLights: o.spot.length,
                                numSpotLightMaps: o.spotLightMap.length,
                                numRectAreaLights: o.rectArea.length,
                                numHemiLights: o.hemi.length,
                                numDirLightShadows: o.directionalShadowMap.length,
                                numPointLightShadows: o.pointShadowMap.length,
                                numSpotLightShadows: o.spotShadowMap.length,
                                numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                                numClippingPlanes: s.numPlanes,
                                numClipIntersection: s.numIntersection,
                                dithering: a.dithering,
                                shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                                shadowMapType: e.shadowMap.type,
                                toneMapping: a.toneMapped ? e.toneMapping : et,
                                physicallyCorrectLights: e.physicallyCorrectLights,
                                premultipliedAlpha: a.premultipliedAlpha,
                                doubleSided: a.side === b,
                                flipSided: a.side === x,
                                useDepthPacking: !!a.depthPacking,
                                depthPacking: a.depthPacking || 0,
                                batching: g && !0 === g.isBatchedMesh,
                                batchingInstancing: g && !0 === g.isBatchedInstanceMesh,
                                batchingArrayMap: a.map && (a.map.isDataArrayTexture || a.map.isCompressedArrayTexture),
                                batchUniforms: g && g.batchUniforms,
                                index0AttributeName: a.index0AttributeName,
                                extensionDerivatives: a.extensions && a.extensions.derivatives,
                                extensionFragDepth: a.extensions && a.extensions.fragDepth,
                                extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
                                extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth: c || r.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers: c || r.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod: c || r.has("EXT_shader_texture_lod"),
                                rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                                rendererExtensionMultiDraw: r.has("WEBGL_multi_draw") && g && !g.useSplit,
                                transformFeedbackVaryings: a.transformFeedbackVaryings,
                                transformFeedback: g && (g.isTransformFeedback || g.isTransformFeedbackInstance),
                                sortAttributes: g && g._sortAttributes ? g._sortAttributes : null,
                                customProgramCacheKey: a.customProgramCacheKey()
                            };
                        return B
                    },
                    getProgramCacheKey: function(t) {
                        let n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (let r in t.defines) n.push(r), n.push(t.defines[r]);
                        return !1 === t.isRawShaderMaterial && (n.push(t.precision), n.push(t.outputEncoding), n.push(t.envMapMode), n.push(t.envMapCubeUVHeight), n.push(t.combine), n.push(t.vertexUvs), n.push(t.fogExp2), n.push(t.sizeAttenuation), n.push(t.morphTargetsCount), n.push(t.morphAttributeCount), n.push(t.numDirLights), n.push(t.numPointLights), n.push(t.numSpotLights), n.push(t.numSpotLightMaps), n.push(t.numHemiLights), n.push(t.numRectAreaLights), n.push(t.numDirLightShadows), n.push(t.numPointLightShadows), n.push(t.numSpotLightShadows), n.push(t.numSpotLightShadowsWithMaps), n.push(t.shadowMapType), n.push(t.toneMapping), n.push(t.numClippingPlanes), n.push(t.numClipIntersection), n.push(t.depthPacking), n.push(t.transformFeedback), o.disableAll(), t.isWebGL2 && o.enable(0), t.supportsVertexTextures && o.enable(1), t.instancing && o.enable(2), t.instancingColor && o.enable(3), t.map && o.enable(4), t.matcap && o.enable(5), t.envMap && o.enable(6), t.lightMap && o.enable(7), t.aoMap && o.enable(8), t.emissiveMap && o.enable(9), t.bumpMap && o.enable(10), t.normalMap && o.enable(11), t.objectSpaceNormalMap && o.enable(12), t.tangentSpaceNormalMap && o.enable(13), t.clearcoat && o.enable(14), t.clearcoatMap && o.enable(15), t.clearcoatRoughnessMap && o.enable(16), t.clearcoatNormalMap && o.enable(17), t.iridescence && o.enable(18), t.iridescenceMap && o.enable(19), t.iridescenceThicknessMap && o.enable(20), t.displacementMap && o.enable(21), t.specularMap && o.enable(22), t.roughnessMap && o.enable(23), t.metalnessMap && o.enable(24), t.gradientMap && o.enable(25), t.alphaMap && o.enable(26), t.alphaTest && o.enable(27), t.vertexColors && o.enable(28), t.vertexAlphas && o.enable(29), t.vertexUvs && o.enable(30), t.batching && o.enable(31), t.cellShading && o.enable(32), t.cellShadingThickness && o.enable(33), t.numMultiviewViews && o.enable(34), t.vertexTangents && o.enable(35), t.uvsVertexOnly && o.enable(36), t.batchingArrayMap && o.enable(37), n.push(o.mask), o.disableAll(), t.fog && o.enable(0), t.useFog && o.enable(1), t.flatShading && o.enable(2), t.logarithmicDepthBuffer && o.enable(3), t.skinning && o.enable(4), t.morphTargets && o.enable(5), t.morphNormals && o.enable(6), t.morphColors && o.enable(7), t.premultipliedAlpha && o.enable(8), t.shadowMapEnabled && o.enable(9), t.physicallyCorrectLights && o.enable(10), t.doubleSided && o.enable(11), t.flipSided && o.enable(12), t.useDepthPacking && o.enable(13), t.dithering && o.enable(14), t.specularIntensityMap && o.enable(15), t.specularColorMap && o.enable(16), t.transmission && o.enable(17), t.transmissionMap && o.enable(18), t.thicknessMap && o.enable(19), t.sheen && o.enable(20), t.sheenColorMap && o.enable(21), t.sheenRoughnessMap && o.enable(22), t.decodeVideoTexture && o.enable(23), t.opaque && o.enable(24), n.push(o.mask), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), t.batching && t.batchUniforms && n.push(Object.keys(t.batchUniforms).length), n.join()
                    },
                    getUniforms: function(e) {
                        let t;
                        let n = p[e.type];
                        if (n) {
                            let r = iQ[n];
                            t = ik.clone(r.uniforms)
                        } else t = e.uniforms;
                        return t
                    },
                    acquireProgram: function(t, n) {
                        let r;
                        for (let i = 0, s = u.length; i < s; i++) {
                            let o = u[i];
                            if (o.cacheKey === n) {
                                r = o, ++r.usedTimes;
                                break
                            }
                        }
                        return void 0 === r && (r = new sE(e, n, t, a), u.push(r)), r
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            let t = u.indexOf(e);
                            u[t] = u[u.length - 1], u.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        l.remove(e)
                    },
                    programs: u,
                    dispose: function() {
                        l.dispose()
                    }
                }
            }

            function sL() {
                let e = new WeakMap;
                return {
                    get: function(t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, n, r) {
                        e.get(t)[n] = r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function sD(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function sk(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function sU() {
                let e = [],
                    t = 0,
                    n = [],
                    r = [],
                    i = [];

                function a(n, r, i, a, s, o) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: r,
                        material: i,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: s,
                        group: o
                    }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = s, l.group = o), t++, l
                }
                return {
                    opaque: n,
                    transmissive: r,
                    transparent: i,
                    init: function() {
                        t = 0, n.length = 0, r.length = 0, i.length = 0
                    },
                    push: function(e, t, s, o, l, u) {
                        let c = a(e, t, s, o, l, u);
                        s.transmission > 0 ? r.push(c) : !0 === s.transparent ? i.push(c) : n.push(c)
                    },
                    unshift: function(e, t, s, o, l, u) {
                        let c = a(e, t, s, o, l, u);
                        s.transmission > 0 ? r.unshift(c) : !0 === s.transparent ? i.unshift(c) : n.unshift(c)
                    },
                    finish: function() {
                        for (let n = t, r = e.length; n < r; n++) {
                            let i = e[n];
                            if (null === i.id) break;
                            i.id = null, i.object = null, i.geometry = null, i.material = null, i.group = null
                        }
                    },
                    sort: function(e, t) {
                        n.length > 1 && n.sort(e || sD), r.length > 1 && r.sort(t || sk), i.length > 1 && i.sort(t || sk)
                    }
                }
            }

            function sO() {
                let e = new WeakMap;
                return {
                    get: function(t, n) {
                        let r;
                        let i = e.get(t);
                        return void 0 === i ? (r = new sU, e.set(t, [r])) : n >= i.length ? (r = new sU, i.push(r)) : r = i[n], r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function sF() {
                let e = {};
                return {
                    get: function(t) {
                        let n;
                        if (void 0 !== e[t.id]) return e[t.id];
                        switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new nj,
                                    color: new nR
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new nj,
                                    direction: new nj,
                                    color: new nR,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new nj,
                                    color: new nR,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new nj,
                                    skyColor: new nR,
                                    groundColor: new nR
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new nR,
                                    position: new nj,
                                    halfWidth: new nj,
                                    halfHeight: new nj
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }
            let sN = 0;

            function sB(e, t) {
                return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
            }

            function sz(e, t) {
                let n = new sF,
                    r = function() {
                        let e = {};
                        return {
                            get: function(t) {
                                let n;
                                if (void 0 !== e[t.id]) return e[t.id];
                                switch (t.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new np
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new np,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return e[t.id] = n, n
                            }
                        }
                    }(),
                    i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0
                    };
                for (let a = 0; a < 9; a++) i.probe.push(new nj);
                let s = new nj,
                    o = new rd,
                    l = new rd;
                return {
                    setup: function(a, s) {
                        let o = 0,
                            l = 0,
                            u = 0;
                        for (let c = 0; c < 9; c++) i.probe[c].set(0, 0, 0);
                        let h = 0,
                            d = 0,
                            f = 0,
                            p = 0,
                            m = 0,
                            g = 0,
                            v = 0,
                            _ = 0,
                            y = 0,
                            x = 0;
                        a.sort(sB);
                        let b = !0 !== s ? Math.PI : 1;
                        for (let w = 0, S = a.length; w < S; w++) {
                            let M = a[w],
                                T = M.color,
                                A = M.intensity,
                                E = M.distance,
                                C = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
                            if (M.isAmbientLight) o += T.r * A * b, l += T.g * A * b, u += T.b * A * b;
                            else if (M.isLightProbe)
                                for (let I = 0; I < 9; I++) i.probe[I].addScaledVector(M.sh.coefficients[I], A);
                            else if (M.isDirectionalLight) {
                                let P = n.get(M);
                                if (P.color.copy(M.color).multiplyScalar(M.intensity * b), M.castShadow) {
                                    let R = M.shadow,
                                        L = r.get(M);
                                    L.shadowBias = R.bias, L.shadowNormalBias = R.normalBias, L.shadowRadius = R.radius, L.shadowMapSize = R.mapSize, i.directionalShadow[h] = L, i.directionalShadowMap[h] = C, i.directionalShadowMatrix[h] = M.shadow.matrix, g++
                                }
                                i.directional[h] = P, h++
                            } else if (M.isSpotLight) {
                                let D = n.get(M);
                                D.position.setFromMatrixPosition(M.matrixWorld), D.color.copy(T).multiplyScalar(A * b), D.distance = E, D.coneCos = Math.cos(M.angle), D.penumbraCos = Math.cos(M.angle * (1 - M.penumbra)), D.decay = M.decay, i.spot[f] = D;
                                let k = M.shadow;
                                if (M.map && (i.spotLightMap[y] = M.map, y++, k.updateMatrices(M), M.castShadow && x++), i.spotLightMatrix[f] = k.matrix, M.castShadow) {
                                    let U = r.get(M);
                                    U.shadowBias = k.bias, U.shadowNormalBias = k.normalBias, U.shadowRadius = k.radius, U.shadowMapSize = k.mapSize, i.spotShadow[f] = U, i.spotShadowMap[f] = C, _++
                                }
                                f++
                            } else if (M.isRectAreaLight) {
                                let O = n.get(M);
                                O.color.copy(T).multiplyScalar(A), O.halfWidth.set(.5 * M.width, 0, 0), O.halfHeight.set(0, .5 * M.height, 0), i.rectArea[p] = O, p++
                            } else if (M.isPointLight) {
                                let F = n.get(M);
                                if (F.color.copy(M.color).multiplyScalar(M.intensity * b), F.distance = M.distance, F.decay = M.decay, M.castShadow) {
                                    let N = M.shadow,
                                        B = r.get(M);
                                    B.shadowBias = N.bias, B.shadowNormalBias = N.normalBias, B.shadowRadius = N.radius, B.shadowMapSize = N.mapSize, B.shadowCameraNear = N.camera.near, B.shadowCameraFar = N.camera.far, i.pointShadow[d] = B, i.pointShadowMap[d] = C, i.pointShadowMatrix[d] = M.shadow.matrix, v++
                                }
                                i.point[d] = F, d++
                            } else if (M.isHemisphereLight) {
                                let z = n.get(M);
                                z.skyColor.copy(M.color).multiplyScalar(A * b), z.groundColor.copy(M.groundColor).multiplyScalar(A * b), i.hemi[m] = z, m++
                            }
                        }
                        p > 0 && (t.isWebGL2 ? (i.rectAreaLTC1 = iK.LTC_FLOAT_1, i.rectAreaLTC2 = iK.LTC_FLOAT_2) : !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = iK.LTC_FLOAT_1, i.rectAreaLTC2 = iK.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = iK.LTC_HALF_1, i.rectAreaLTC2 = iK.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = o, i.ambient[1] = l, i.ambient[2] = u;
                        let G = i.hash;
                        (G.directionalLength !== h || G.pointLength !== d || G.spotLength !== f || G.rectAreaLength !== p || G.hemiLength !== m || G.numDirectionalShadows !== g || G.numPointShadows !== v || G.numSpotShadows !== _ || G.numSpotMaps !== y) && (i.directional.length = h, i.spot.length = f, i.rectArea.length = p, i.point.length = d, i.hemi.length = m, i.directionalShadow.length = g, i.directionalShadowMap.length = g, i.pointShadow.length = v, i.pointShadowMap.length = v, i.spotShadow.length = _, i.spotShadowMap.length = _, i.directionalShadowMatrix.length = g, i.pointShadowMatrix.length = v, i.spotLightMatrix.length = _ + y - x, i.spotLightMap.length = y, i.numSpotLightShadowsWithMaps = x, G.directionalLength = h, G.pointLength = d, G.spotLength = f, G.rectAreaLength = p, G.hemiLength = m, G.numDirectionalShadows = g, G.numPointShadows = v, G.numSpotShadows = _, G.numSpotMaps = y, i.version = sN++)
                    },
                    setupView: function(e, t) {
                        let n = 0,
                            r = 0,
                            a = 0,
                            u = 0,
                            c = 0,
                            h = t.matrixWorldInverse;
                        for (let d = 0, f = e.length; d < f; d++) {
                            let p = e[d];
                            if (p.isDirectionalLight) {
                                let m = i.directional[n];
                                m.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), m.direction.sub(s), m.direction.transformDirection(h), n++
                            } else if (p.isSpotLight) {
                                let g = i.spot[a];
                                g.position.setFromMatrixPosition(p.matrixWorld), g.position.applyMatrix4(h), g.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), g.direction.sub(s), g.direction.transformDirection(h), a++
                            } else if (p.isRectAreaLight) {
                                let v = i.rectArea[u];
                                v.position.setFromMatrixPosition(p.matrixWorld), v.position.applyMatrix4(h), l.identity(), o.copy(p.matrixWorld), o.premultiply(h), l.extractRotation(o), v.halfWidth.set(.5 * p.width, 0, 0), v.halfHeight.set(0, .5 * p.height, 0), v.halfWidth.applyMatrix4(l), v.halfHeight.applyMatrix4(l), u++
                            } else if (p.isPointLight) {
                                let _ = i.point[r];
                                _.position.setFromMatrixPosition(p.matrixWorld), _.position.applyMatrix4(h), r++
                            } else if (p.isHemisphereLight) {
                                let y = i.hemi[c];
                                y.direction.setFromMatrixPosition(p.matrixWorld), y.direction.transformDirection(h), c++
                            }
                        }
                    },
                    state: i
                }
            }

            function sG(e, t) {
                let n = new sz(e, t),
                    r = [],
                    i = [];
                return {
                    init: function() {
                        r.length = 0, i.length = 0
                    },
                    state: {
                        lightsArray: r,
                        shadowsArray: i,
                        lights: n
                    },
                    setupLights: function(e) {
                        n.setup(r, e)
                    },
                    setupLightsView: function(e) {
                        n.setupView(r, e)
                    },
                    pushLight: function(e) {
                        r.push(e)
                    },
                    pushShadow: function(e) {
                        i.push(e)
                    }
                }
            }

            function sV(e, t) {
                let n = new WeakMap;
                return {
                    get: function(r, i = 0) {
                        let a;
                        let s = n.get(r);
                        return void 0 === s ? (a = new sG(e, t), n.set(r, [a])) : i >= s.length ? (a = new sG(e, t), s.push(a)) : a = s[i], a
                    },
                    dispose: function() {
                        n = new WeakMap
                    }
                }
            }
            class sW extends r$ {
                constructor(e) {
                    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = tE, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                }
            }
            class sH extends r$ {
                constructor(e) {
                    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new nj, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                }
            }

            function sj(e, t, n) {
                let r = new iX,
                    i = new np,
                    a = new np,
                    s = new nF,
                    o = new sW({
                        depthPacking: tC
                    }),
                    l = new sH,
                    u = {},
                    c = n.maxTextureSize,
                    h = {
                        0: x,
                        1: y,
                        2: b
                    },
                    d = new iU({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new np
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    f = d.clone();
                f.defines.HORIZONTAL_PASS = 1;
                let p = new iu;
                p.setAttribute("position", new r0(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                let m = new iC(p, d),
                    v = this;

                function S(t, n, r, i, a, s) {
                    let c = null,
                        d = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (c = void 0 !== d ? d : !0 === r.isPointLight ? l : o, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                        let f = c.uuid,
                            p = n.uuid,
                            m = u[f];
                        void 0 === m && (m = {}, u[f] = m);
                        let g = m[p];
                        void 0 === g && (g = c.clone(), m[p] = g), c = g
                    }
                    return c.visible = n.visible, c.wireframe = n.wireframe, s === _ ? c.side = null !== n.shadowSide ? n.shadowSide : n.side : c.side = null !== n.shadowSide ? n.shadowSide : h[n.side], c.alphaMap = n.alphaMap, c.map = n.map, c.alphaTest = n.alphaTest, c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.displacementMap = n.displacementMap, c.displacementScale = n.displacementScale, c.displacementBias = n.displacementBias, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = i, c.farDistance = a), c
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = g, this.render = function(n, o, l, u) {
                    if (!1 === v.enabled || !1 === v.autoUpdate && !1 === v.needsUpdate && void 0 === u || 0 === n.length) return;
                    let h = e.getRenderTarget(),
                        p = e.getActiveCubeFace(),
                        g = e.getActiveMipmapLevel(),
                        y = e.state;
                    y.setBlending(w), y.buffers.color.setClear(1, 1, 1, 1), y.buffers.depth.setTest(!0), y.setScissorTest(!1);
                    for (let x = 0, b = n.length; x < b; x++) {
                        let M = n[x],
                            T = M.shadow;
                        if (void 0 === T) {
                            console.warn("THREE.WebGLShadowMap:", M, "has no shadow.");
                            continue
                        }
                        if (!1 === T.autoUpdate && !1 === T.needsUpdate && void 0 === u) continue;
                        i.copy(T.mapSize);
                        let A = T.getFrameExtents();
                        if (i.multiply(A), a.copy(T.mapSize), (i.x > c || i.y > c) && (i.x > c && (a.x = Math.floor(c / A.x), i.x = a.x * A.x, T.mapSize.x = a.x), i.y > c && (a.y = Math.floor(c / A.y), i.y = a.y * A.y, T.mapSize.y = a.y)), null === T.map) {
                            let E = this.type !== _ ? {
                                minFilter: eg,
                                magFilter: eg
                            } : {};
                            T.map = new nN(i.x, i.y, E), T.map.texture.name = M.name + ".shadowMap", T.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(T.map), e.clear();
                        let C = T.getViewportCount(),
                            I = Array.isArray(o) ? o : [o];
                        for (let P = 0; P < C; P++) {
                            let R = T.getViewport(P);
                            s.set(a.x * R.x, a.y * R.y, a.x * R.z, a.y * R.w), y.viewport(s), T.updateMatrices(M, P), r = T.getFrustum();
                            for (let L = 0; L < I.length; L++) {
                                let D = I[L];
                                (function n(i, a, s, o, l) {
                                    if (!1 === i.visible) return;
                                    let u = i.layers.test(a.layers);
                                    if (u && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && l === _) && (!i.frustumCulled || r.intersectsObject(i) || i.inViewport)) {
                                        i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
                                        let c = t.update(i),
                                            h = i.material;
                                        if (Array.isArray(h)) {
                                            let d = c.groups;
                                            for (let f = 0, p = d.length; f < p; f++) {
                                                let m = d[f],
                                                    g = h[m.materialIndex];
                                                if (g && g.visible) {
                                                    let v = S(i, g, o, s.near, s.far, l);
                                                    e.renderBufferDirect(s, null, c, v, i, m)
                                                }
                                            }
                                        } else if (h.visible) {
                                            let y = S(i, h, o, s.near, s.far, l);
                                            e.renderBufferDirect(s, null, c, y, i, null)
                                        }
                                    }
                                    let x = i.children;
                                    for (let b = 0, w = x.length; b < w; b++) n(x[b], a, s, o, l)
                                })(D, l, T.camera, M, this.type)
                            }
                        }!0 !== T.isPointLightShadow && this.type === _ && function(n, r) {
                            let a = t.update(m);
                            d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), null === n.mapPass && (n.mapPass = new nN(i.x, i.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, a, d, m, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, a, f, m, null)
                        }(T, l), T.needsUpdate = !1
                    }
                    v.needsUpdate = !1, e.setRenderTarget(h, p, g)
                }
            }

            function sq(e, t, n) {
                let r = n.isWebGL2,
                    i = new function() {
                        let t = !1,
                            n = new nF,
                            r = null,
                            i = new nF(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                r === n || t || (e.colorMask(n, n, n, n), r = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, r, a, s, o) {
                                !0 === o && (t *= s, r *= s, a *= s), n.set(t, r, a, s), !1 === i.equals(n) && (e.clearColor(t, r, a, s), i.copy(n))
                            },
                            reset: function() {
                                t = !1, r = null, i.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    a = new function() {
                        let t = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function(e) {
                                e ? ex(2929) : eb(2929)
                            },
                            setMask: function(r) {
                                n === r || t || (e.depthMask(r), n = r)
                            },
                            setFunc: function(t) {
                                if (r !== t) {
                                    switch (t) {
                                        case H:
                                            e.depthFunc(512);
                                            break;
                                        case j:
                                            e.depthFunc(519);
                                            break;
                                        case q:
                                            e.depthFunc(513);
                                            break;
                                        case X:
                                            e.depthFunc(515);
                                            break;
                                        case Z:
                                            e.depthFunc(514);
                                            break;
                                        case Y:
                                            e.depthFunc(518);
                                            break;
                                        case $:
                                            e.depthFunc(516);
                                            break;
                                        case J:
                                            e.depthFunc(517);
                                            break;
                                        default:
                                            e.depthFunc(515)
                                    }
                                    r = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                i !== t && (e.clearDepth(t), i = t)
                            },
                            reset: function() {
                                t = !1, n = null, r = null, i = null
                            }
                        }
                    },
                    s = new function() {
                        let t = !1,
                            n = null,
                            r = null,
                            i = null,
                            a = null,
                            s = null,
                            o = null,
                            l = null,
                            u = null;
                        return {
                            setTest: function(e) {
                                t || (e ? ex(2960) : eb(2960))
                            },
                            setMask: function(r) {
                                n === r || t || (e.stencilMask(r), n = r)
                            },
                            setFunc: function(t, n, s) {
                                (r !== t || i !== n || a !== s) && (e.stencilFunc(t, n, s), r = t, i = n, a = s)
                            },
                            setOp: function(t, n, r) {
                                (s !== t || o !== n || l !== r) && (e.stencilOp(t, n, r), s = t, o = n, l = r)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                u !== t && (e.clearStencil(t), u = t)
                            },
                            reset: function() {
                                t = !1, n = null, r = null, i = null, a = null, s = null, o = null, l = null, u = null
                            }
                        }
                    },
                    o = new WeakMap,
                    l = new WeakMap,
                    u = {},
                    c = {},
                    p = new WeakMap,
                    m = [],
                    g = null,
                    v = !1,
                    _ = null,
                    y = null,
                    K = null,
                    Q = null,
                    ee = null,
                    et = null,
                    en = null,
                    er = !1,
                    ei = null,
                    ea = null,
                    es = null,
                    eo = null,
                    el = null,
                    eu = e.getParameter(35661),
                    ec = !1,
                    eh = e.getParameter(7938); - 1 !== eh.indexOf("WebGL") ? ec = parseFloat(/^WebGL (\d)/.exec(eh)[1]) >= 1 : -1 !== eh.indexOf("OpenGL ES") && (ec = parseFloat(/^OpenGL ES (\d)/.exec(eh)[1]) >= 2);
                let ed = null,
                    ef = {},
                    ep = e.getParameter(3088),
                    em = e.getParameter(2978),
                    eg = new nF().fromArray(ep),
                    ev = new nF().fromArray(em);

                function e_(t, n, r) {
                    let i = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (let s = 0; s < r; s++) e.texImage2D(n + s, 0, 6408, 1, 1, 0, 6408, 5121, i);
                    return a
                }
                let ey = {};

                function ex(t) {
                    !0 !== u[t] && (e.enable(t), u[t] = !0)
                }

                function eb(t) {
                    !1 !== u[t] && (e.disable(t), u[t] = !1)
                }
                ey[3553] = e_(3553, 3553, 1), ey[34067] = e_(34067, 34069, 6), i.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), ex(2929), a.setFunc(X), eA(!1), eE(d), ex(2884), eT(w);
                let ew = {
                    [C]: 32774,
                    [I]: 32778,
                    [P]: 32779
                };
                if (r) ew[R] = 32775, ew[L] = 32776;
                else {
                    let eS = t.get("EXT_blend_minmax");
                    null !== eS && (ew[R] = eS.MIN_EXT, ew[L] = eS.MAX_EXT)
                }
                let eM = {
                    [D]: 0,
                    [k]: 1,
                    [U]: 768,
                    [F]: 770,
                    [W]: 776,
                    [G]: 774,
                    [B]: 772,
                    [O]: 769,
                    [N]: 771,
                    [V]: 775,
                    [z]: 773
                };

                function eT(t, n, r, i, a, s, o, l) {
                    if (t === w) {
                        !0 === v && (eb(3042), v = !1);
                        return
                    }
                    if (!1 === v && (ex(3042), v = !0), t !== E) {
                        if (t !== _ || l !== er) {
                            if ((y !== C || ee !== C) && (e.blendEquation(32774), y = C, ee = C), l) switch (t) {
                                case S:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case M:
                                    e.blendFunc(1, 1);
                                    break;
                                case T:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case A:
                                    e.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                                case S:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case M:
                                    e.blendFunc(770, 1);
                                    break;
                                case T:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case A:
                                    e.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            K = null, Q = null, et = null, en = null, _ = t, er = l
                        }
                        return
                    }
                    a = a || n, s = s || r, o = o || i, (n !== y || a !== ee) && (e.blendEquationSeparate(ew[n], ew[a]), y = n, ee = a), (r !== K || i !== Q || s !== et || o !== en) && (e.blendFuncSeparate(eM[r], eM[i], eM[s], eM[o]), K = r, Q = i, et = s, en = o), _ = t, er = !1
                }

                function eA(t) {
                    ei !== t && (t ? e.frontFace(2304) : e.frontFace(2305), ei = t)
                }

                function eE(t) {
                    t !== h ? (ex(2884), t !== ea && (t === d ? e.cullFace(1029) : t === f ? e.cullFace(1028) : e.cullFace(1032))) : eb(2884), ea = t
                }

                function eC(t, n, r) {
                    t ? (ex(32823), (eo !== n || el !== r) && (e.polygonOffset(n, r), eo = n, el = r)) : eb(32823)
                }
                return {
                    buffers: {
                        color: i,
                        depth: a,
                        stencil: s
                    },
                    enable: ex,
                    disable: eb,
                    bindFramebuffer: function(t, n) {
                        return c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, r && (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)), !0)
                    },
                    drawBuffers: function(r, i) {
                        let a = m,
                            s = !1;
                        if (r) {
                            if (void 0 === (a = p.get(i)) && (a = [], p.set(i, a)), r.isWebGLMultipleRenderTargets) {
                                let o = r.texture;
                                if (a.length !== o.length || 36064 !== a[0]) {
                                    for (let l = 0, u = o.length; l < u; l++) a[l] = 36064 + l;
                                    a.length = o.length, s = !0
                                }
                            } else 36064 !== a[0] && (a[0] = 36064, s = !0)
                        } else 1029 !== a[0] && (a[0] = 1029, s = !0);
                        s && (n.isWebGL2 ? e.drawBuffers(a) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))
                    },
                    useProgram: function(t) {
                        return g !== t && (e.useProgram(t), g = t, !0)
                    },
                    setBlending: eT,
                    setMaterial: function(e, t) {
                        e.side === b ? eb(2884) : ex(2884);
                        let n = e.side === x;
                        t && (n = !n), eA(n), e.blending === S && !1 === e.transparent ? eT(w) : eT(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), i.setMask(e.colorWrite);
                        let r = e.stencilWrite;
                        s.setTest(r), r && (s.setMask(e.stencilWriteMask), s.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), s.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), eC(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? ex(32926) : eb(32926)
                    },
                    setFlipSided: eA,
                    setCullFace: eE,
                    setLineWidth: function(t) {
                        t !== es && (ec && e.lineWidth(t), es = t)
                    },
                    setPolygonOffset: eC,
                    setScissorTest: function(e) {
                        e ? ex(3089) : eb(3089)
                    },
                    activeTexture: function(t) {
                        void 0 === t && (t = 33984 + eu - 1), ed !== t && (e.activeTexture(t), ed = t)
                    },
                    bindTexture: function(t, n, r) {
                        void 0 === r && (r = null === ed ? 33984 + eu - 1 : ed);
                        let i = ef[r];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, ef[r] = i), (i.type !== t || i.texture !== n) && (ed !== r && (e.activeTexture(r), ed = r), e.bindTexture(t, n || ey[t]), i.type = t, i.texture = n)
                    },
                    unbindTexture: function() {
                        let t = ef[ed];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    compressedTexImage3D: function() {
                        try {
                            e.compressedTexImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    updateUBOMapping: function(t, n) {
                        let r = l.get(n);
                        void 0 === r && (r = new WeakMap, l.set(n, r));
                        let i = r.get(t);
                        void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i))
                    },
                    uniformBlockBinding: function(t, n) {
                        let r = l.get(n),
                            i = r.get(t);
                        o.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex), o.set(n, i))
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    compressedTexSubImage3D: function() {
                        try {
                            e.compressedTexSubImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function(t) {
                        !1 === eg.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), eg.copy(t))
                    },
                    viewport: function(t) {
                        !1 === ev.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ev.copy(t))
                    },
                    reset: function() {
                        e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === r && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), u = {}, ed = null, ef = {}, c = {}, p = new WeakMap, m = [], g = null, v = !1, _ = null, y = null, K = null, Q = null, ee = null, et = null, en = null, er = !1, ei = null, ea = null, es = null, eo = null, el = null, eg.set(0, 0, e.canvas.width, e.canvas.height), ev.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), a.reset(), s.reset()
                    }
                }
            }

            function sX(e, t, n, r, i, a, s) {
                let o;
                let l = i.isWebGL2,
                    u = i.maxTextures,
                    c = i.maxCubemapSize,
                    h = i.maxTextureSize,
                    d = i.maxSamples,
                    f = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                    p = /OculusBrowser/g.test("undefined" == typeof navigator ? "" : navigator.userAgent),
                    m = new WeakMap,
                    g = new WeakMap,
                    v = !1;
                try {
                    v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (_) {}

                function y(e, t) {
                    return v ? new OffscreenCanvas(e, t) : nx("canvas")
                }

                function x(e, t, n, r) {
                    let i = 1;
                    if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            let a = t ? nc : Math.floor,
                                s = a(i * e.width),
                                l = a(i * e.height);
                            void 0 === o && (o = y(s, l));
                            let u = n ? y(s, l) : o;
                            u.width = s, u.height = l;
                            let c = u.getContext("2d");
                            return c.drawImage(e, 0, 0, s, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + l + ")."), u
                        }
                        "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").")
                    }
                    return e
                }

                function b(e) {
                    return nl(e.width) && nl(e.height)
                }

                function w(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== eg && e.minFilter !== eb
                }

                function S(t) {
                    e.generateMipmap(t)
                }

                function M(n, r, i, a, s = !1) {
                    if (!1 === l) return r;
                    if (null !== n) {
                        if (void 0 !== e[n]) return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let o = r;
                    return 6403 === r && (5126 === i && (o = 33326), 5131 === i && (o = 33325), 5121 === i && (o = 33321)), 33319 === r && (5126 === i && (o = 33328), 5131 === i && (o = 33327), 5121 === i && (o = 33323)), 6408 === r && (5126 === i && (o = 34836), 5131 === i && (o = 34842), 5121 === i && (o = a === tA && !1 === s ? 35907 : 32856), 32819 === i && (o = 32854), 32820 === i && (o = 32855)), (33325 === o || 33326 === o || 33327 === o || 33328 === o || 34842 === o || 34836 === o) && t.get("EXT_color_buffer_float"), o
                }

                function T(e, t, n) {
                    return !0 === w(e, n) || e.isFramebufferTexture && e.minFilter !== eg && e.minFilter !== eb ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function A(e) {
                    return e === eg || e === ev || e === ey ? 9728 : 9729
                }

                function E(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", E),
                        function(e) {
                            let t = r.get(e);
                            if (void 0 === t.__webglInit) return;
                            let n = e.source,
                                i = g.get(n);
                            if (i) {
                                let a = i[t.__cacheKey];
                                a.usedTimes--, 0 === a.usedTimes && I(e), 0 === Object.keys(i).length && g.delete(n)
                            }
                            r.remove(e)
                        }(t), t.isVideoTexture && m.delete(t)
                }

                function C(t) {
                    let n = t.target;
                    n.removeEventListener("dispose", C),
                        function(t) {
                            let n = t.texture,
                                i = r.get(t),
                                a = r.get(n);
                            if (void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture), s.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                                for (let o = 0; o < 6; o++) e.deleteFramebuffer(i.__webglFramebuffer[o]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[o]);
                            else {
                                if (e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer)
                                    for (let l = 0; l < i.__webglColorRenderbuffer.length; l++) i.__webglColorRenderbuffer[l] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[l]);
                                i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer)
                            }
                            if (t.isWebGLMultipleRenderTargets)
                                for (let u = 0, c = n.length; u < c; u++) {
                                    let h = r.get(n[u]);
                                    h.__webglTexture && (e.deleteTexture(h.__webglTexture), s.memory.textures--), r.remove(n[u])
                                }
                            r.remove(n), r.remove(t)
                        }(n)
                }

                function I(t) {
                    let n = r.get(t);
                    e.deleteTexture(n.__webglTexture);
                    let i = t.source,
                        a = g.get(i);
                    delete a[n.__cacheKey], s.memory.textures--
                }
                let P = 0;

                function R(e, t) {
                    let i = r.get(e);
                    if (e.isVideoTexture && function(e) {
                            let t = s.render.frame;
                            m.get(e) !== t && (m.set(e, t), e.update())
                        }(e), !1 === e.isRenderTargetTexture && e.version > 0 && i.__version !== e.version) {
                        let a = e.image;
                        if (null === a) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else if (!1 === a.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                        else {
                            O(i, e, t);
                            return
                        }
                    }
                    n.bindTexture(3553, i.__webglTexture, 33984 + t)
                }
                let L = {
                        [ef]: 10497,
                        [ep]: 33071,
                        [em]: 33648
                    },
                    D = {
                        [eg]: 9728,
                        [ev]: 9984,
                        [ey]: 9986,
                        [eb]: 9729,
                        [ew]: 9985,
                        [eM]: 9987
                    };

                function k(n, a, s) {
                    if (s ? (e.texParameteri(n, 10242, L[a.wrapS]), e.texParameteri(n, 10243, L[a.wrapT]), (32879 === n || 35866 === n) && e.texParameteri(n, 32882, L[a.wrapR]), e.texParameteri(n, 10240, D[a.magFilter]), e.texParameteri(n, 10241, D[a.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), (32879 === n || 35866 === n) && e.texParameteri(n, 32882, 33071), (a.wrapS !== ep || a.wrapT !== ep) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, A(a.magFilter)), e.texParameteri(n, 10241, A(a.minFilter)), a.minFilter !== eg && a.minFilter !== eb && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        let o = t.get("EXT_texture_filter_anisotropic");
                        a.magFilter !== eg && (a.minFilter === ey || a.minFilter === eM) && (a.type !== eL || !1 !== t.has("OES_texture_float_linear")) && (!1 !== l || a.type !== eD || !1 !== t.has("OES_texture_half_float_linear")) && (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function U(t, n) {
                    let r = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", E));
                    let i = n.source,
                        a = g.get(i);
                    void 0 === a && (a = {}, g.set(i, a));
                    let o = function(e) {
                        let t = [];
                        return t.push(e.wrapS), t.push(e.wrapT), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.encoding), t.join()
                    }(n);
                    if (o !== t.__cacheKey) {
                        void 0 === a[o] && (a[o] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        }, s.memory.textures++, r = !0), a[o].usedTimes++;
                        let l = a[t.__cacheKey];
                        void 0 !== l && (a[t.__cacheKey].usedTimes--, 0 === l.usedTimes && I(n)), t.__cacheKey = o, t.__webglTexture = a[o].texture
                    }
                    return r
                }

                function O(t, i, s) {
                    let o = 3553;
                    (i.isDataArrayTexture || i.isCompressedArrayTexture) && (o = 35866), i.isData3DTexture && (o = 32879);
                    let u = U(t, i),
                        c = i.source;
                    n.bindTexture(o, t.__webglTexture, 33984 + s);
                    let d = r.get(c);
                    if (c.version !== d.__version || !0 === u) {
                        let f;
                        n.activeTexture(33984 + s), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
                        let p = !l && (i.wrapS !== ep || i.wrapT !== ep || i.minFilter !== eg && i.minFilter !== eb) && !1 === b(i.image),
                            m = x(i.image, p, !1, h);
                        m = V(i, m);
                        let g = b(m) || l,
                            v = a.convert(i.format, i.encoding),
                            _ = a.convert(i.type),
                            y = M(i.internalFormat, v, _, i.encoding, i.isVideoTexture);
                        k(o, i, g);
                        let A = i.mipmaps,
                            E = l && !0 !== i.isVideoTexture,
                            C = void 0 === d.__version || !0 === u,
                            I = T(i, m, g);
                        if (i.isDepthTexture) y = 6402, l ? y = i.type === eL ? 36012 : i.type === eR ? 33190 : i.type === eO ? 35056 : 33189 : i.type === eL && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === eV && 6402 === y && i.type !== eI && i.type !== eR && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = eR, _ = a.convert(i.type)), i.format === eW && 6402 === y && (y = 34041, i.type !== eO && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = eO, _ = a.convert(i.type))), C && (E ? n.texStorage2D(3553, 1, y, m.width, m.height) : n.texImage2D(3553, 0, y, m.width, m.height, 0, v, _, null));
                        else if (i.isDataTexture) {
                            if (A.length > 0 && g) {
                                E && C && n.texStorage2D(3553, I, y, A[0].width, A[0].height);
                                for (let P = 0, R = A.length; P < R; P++) f = A[P], E ? n.texSubImage2D(3553, P, 0, 0, f.width, f.height, v, _, f.data) : n.texImage2D(3553, P, y, f.width, f.height, 0, v, _, f.data);
                                i.generateMipmaps = !1
                            } else E ? (C && n.texStorage2D(3553, I, y, m.width, m.height), n.texSubImage2D(3553, 0, 0, 0, m.width, m.height, v, _, m.data)) : n.texImage2D(3553, 0, y, m.width, m.height, 0, v, _, m.data)
                        } else if (i.isCompressedTexture) {
                            if (i.isCompressedArrayTexture) {
                                E && C && n.texStorage3D(35866, I, y, A[0].width, A[0].height, m.depth);
                                for (let L = 0, D = A.length; L < D; L++) f = A[L], i.format !== eB ? null !== v ? E ? n.compressedTexSubImage3D(35866, L, 0, 0, 0, f.width, f.height, m.depth, v, f.data, 0, 0) : n.compressedTexImage3D(35866, L, y, f.width, f.height, m.depth, 0, f.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : E ? n.texSubImage3D(35866, L, 0, 0, 0, f.width, f.height, m.depth, v, _, f.data) : n.texImage3D(35866, L, y, f.width, f.height, m.depth, 0, v, _, f.data)
                            } else {
                                E && C && n.texStorage2D(3553, I, y, A[0].width, A[0].height);
                                for (let O = 0, F = A.length; O < F; O++) f = A[O], i.format !== eB ? null !== v ? E ? n.compressedTexSubImage2D(3553, O, 0, 0, f.width, f.height, v, f.data) : n.compressedTexImage2D(3553, O, y, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : E ? n.texSubImage2D(3553, O, 0, 0, f.width, f.height, v, _, f.data) : n.texImage2D(3553, O, y, f.width, f.height, 0, v, _, f.data)
                            }
                        } else if (i.isDataArrayTexture) E ? (C && n.texStorage3D(35866, I, y, m.width, m.height, m.depth), n.texSubImage3D(35866, 0, 0, 0, 0, m.width, m.height, m.depth, v, _, m.data)) : n.texImage3D(35866, 0, y, m.width, m.height, m.depth, 0, v, _, m.data);
                        else if (i.isData3DTexture) E ? (C && n.texStorage3D(32879, I, y, m.width, m.height, m.depth), n.texSubImage3D(32879, 0, 0, 0, 0, m.width, m.height, m.depth, v, _, m.data)) : n.texImage3D(32879, 0, y, m.width, m.height, m.depth, 0, v, _, m.data);
                        else if (i.isFramebufferTexture) {
                            if (C) {
                                if (E) n.texStorage2D(3553, I, y, m.width, m.height);
                                else {
                                    let N = m.width,
                                        B = m.height;
                                    for (let z = 0; z < I; z++) n.texImage2D(3553, z, y, N, B, 0, v, _, null), N >>= 1, B >>= 1
                                }
                            }
                        } else if (A.length > 0 && g) {
                            E && C && n.texStorage2D(3553, I, y, A[0].width, A[0].height);
                            for (let G = 0, W = A.length; G < W; G++) f = A[G], E ? n.texSubImage2D(3553, G, 0, 0, v, _, f) : n.texImage2D(3553, G, y, v, _, f);
                            i.generateMipmaps = !1
                        } else E ? (C && n.texStorage2D(3553, I, y, m.width, m.height), n.texSubImage2D(3553, 0, 0, 0, v, _, m)) : n.texImage2D(3553, 0, y, v, _, m);
                        w(i, g) && S(o), d.__version = c.version, i.onUpdate && i.onUpdate(i)
                    }
                    t.__version = i.version
                }

                function F(t, i, s, o, l) {
                    let u = a.convert(s.format, s.encoding),
                        c = a.convert(s.type),
                        h = M(s.internalFormat, u, c, s.encoding),
                        d = r.get(i);
                    d.__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, i.width, i.height, i.depth, 0, u, c, null) : n.texImage2D(l, 0, h, i.width, i.height, 0, u, c, null)), n.bindFramebuffer(36160, t), G(i) ? f.framebufferTexture2DMultisampleEXT(36160, o, l, r.get(s).__webglTexture, 0, z(i)) : e.framebufferTexture2D(36160, o, l, r.get(s).__webglTexture, 0), n.bindFramebuffer(36160, null)
                }

                function N(t, n, r) {
                    if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                        let i = 33189;
                        if (r || G(n)) {
                            let s = n.depthTexture;
                            s && s.isDepthTexture && (s.type === eL ? i = 36012 : s.type === eR && (i = 33190));
                            let o = z(n);
                            G(n) ? f.renderbufferStorageMultisampleEXT(36161, o, i, n.width, n.height) : e.renderbufferStorageMultisample(36161, o, i, n.width, n.height)
                        } else e.renderbufferStorage(36161, i, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        let l = z(n);
                        r && !1 === G(n) ? e.renderbufferStorageMultisample(36161, l, 35056, n.width, n.height) : G(n) ? f.renderbufferStorageMultisampleEXT(36161, l, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        let u = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                        for (let c = 0; c < u.length; c++) {
                            let h = u[c],
                                d = a.convert(h.format, h.encoding),
                                p = a.convert(h.type),
                                m = M(h.internalFormat, d, p, h.encoding),
                                g = z(n);
                            r && !1 === G(n) ? e.renderbufferStorageMultisample(36161, g, m, n.width, n.height) : G(n) ? f.renderbufferStorageMultisampleEXT(36161, g, m, n.width, n.height) : e.renderbufferStorage(36161, m, n.width, n.height)
                        }
                    }
                    e.bindRenderbuffer(36161, null)
                }

                function B(t) {
                    let i = r.get(t),
                        a = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                        if (a) throw Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, i) {
                            let a = i && i.isWebGLCubeRenderTarget;
                            if (a) throw Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(36160, t), !(i.depthTexture && i.depthTexture.isDepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), R(i.depthTexture, 0);
                            let s = r.get(i.depthTexture).__webglTexture,
                                o = z(i);
                            if (i.depthTexture.format === eV) G(i) ? f.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                            else if (i.depthTexture.format === eW) G(i) ? f.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : e.framebufferTexture2D(36160, 33306, 3553, s, 0);
                            else throw Error("Unknown depthTexture format")
                        }(i.__webglFramebuffer, t)
                    } else if (a) {
                        i.__webglDepthbuffer = [];
                        for (let s = 0; s < 6; s++) n.bindFramebuffer(36160, i.__webglFramebuffer[s]), i.__webglDepthbuffer[s] = e.createRenderbuffer(), N(i.__webglDepthbuffer[s], t, !1)
                    } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), N(i.__webglDepthbuffer, t, !1);
                    n.bindFramebuffer(36160, null)
                }

                function z(e) {
                    return Math.min(d, e.samples)
                }

                function G(e) {
                    let n = r.get(e);
                    return l && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                }

                function V(e, n) {
                    let r = e.encoding,
                        i = e.format,
                        a = e.type;
                    return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === t8 || r !== tT && (r === tA ? !1 === l ? !0 === t.has("EXT_sRGB") && i === eB ? (e.format = t8, e.minFilter = eb, e.generateMipmaps = !1) : n = nL.sRGBToLinear(n) : (i !== eB || a !== eA) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", r)), n
                }
                this.allocateTextureUnit = function() {
                    let e = P;
                    return e >= u && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + u), P += 1, e
                }, this.resetTextureUnits = function() {
                    P = 0
                }, this.setTexture2D = R, this.setTexture2DArray = function(e, t) {
                    let i = r.get(e);
                    if (e.version > 0 && i.__version !== e.version) {
                        O(i, e, t);
                        return
                    }
                    n.bindTexture(35866, i.__webglTexture, 33984 + t)
                }, this.setTexture3D = function(e, t) {
                    let i = r.get(e);
                    if (e.version > 0 && i.__version !== e.version) {
                        O(i, e, t);
                        return
                    }
                    n.bindTexture(32879, i.__webglTexture, 33984 + t)
                }, this.setTextureCube = function(t, i) {
                    let s = r.get(t);
                    if (t.version > 0 && s.__version !== t.version) {
                        (function(t, i, s) {
                            if (6 !== i.image.length) return;
                            let o = U(t, i),
                                u = i.source;
                            n.bindTexture(34067, t.__webglTexture, 33984 + s);
                            let h = r.get(u);
                            if (u.version !== h.__version || !0 === o) {
                                let d;
                                n.activeTexture(33984 + s), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
                                let f = i.isCompressedTexture || i.image[0].isCompressedTexture,
                                    p = i.image[0] && i.image[0].isDataTexture,
                                    m = [];
                                for (let g = 0; g < 6; g++) f || p ? m[g] = p ? i.image[g].image : i.image[g] : m[g] = x(i.image[g], !1, !0, c), m[g] = V(i, m[g]);
                                let v = m[0],
                                    _ = b(v) || l,
                                    y = a.convert(i.format, i.encoding),
                                    A = a.convert(i.type),
                                    E = M(i.internalFormat, y, A, i.encoding),
                                    C = l && !0 !== i.isVideoTexture,
                                    I = void 0 === h.__version || !0 === o,
                                    P = T(i, v, _);
                                if (k(34067, i, _), f) {
                                    C && I && n.texStorage2D(34067, P, E, v.width, v.height);
                                    for (let R = 0; R < 6; R++) {
                                        d = m[R].mipmaps;
                                        for (let L = 0; L < d.length; L++) {
                                            let D = d[L];
                                            i.format !== eB ? null !== y ? C ? n.compressedTexSubImage2D(34069 + R, L, 0, 0, D.width, D.height, y, D.data) : n.compressedTexImage2D(34069 + R, L, E, D.width, D.height, 0, D.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : C ? n.texSubImage2D(34069 + R, L, 0, 0, D.width, D.height, y, A, D.data) : n.texImage2D(34069 + R, L, E, D.width, D.height, 0, y, A, D.data)
                                        }
                                    }
                                } else {
                                    d = i.mipmaps, C && I && (d.length > 0 && P++, n.texStorage2D(34067, P, E, m[0].width, m[0].height));
                                    for (let O = 0; O < 6; O++)
                                        if (p) {
                                            C ? n.texSubImage2D(34069 + O, 0, 0, 0, m[O].width, m[O].height, y, A, m[O].data) : n.texImage2D(34069 + O, 0, E, m[O].width, m[O].height, 0, y, A, m[O].data);
                                            for (let F = 0; F < d.length; F++) {
                                                let N = d[F],
                                                    B = N.image[O].image;
                                                C ? n.texSubImage2D(34069 + O, F + 1, 0, 0, B.width, B.height, y, A, B.data) : n.texImage2D(34069 + O, F + 1, E, B.width, B.height, 0, y, A, B.data)
                                            }
                                        } else {
                                            C ? n.texSubImage2D(34069 + O, 0, 0, 0, y, A, m[O]) : n.texImage2D(34069 + O, 0, E, y, A, m[O]);
                                            for (let z = 0; z < d.length; z++) {
                                                let G = d[z];
                                                C ? n.texSubImage2D(34069 + O, z + 1, 0, 0, y, A, G.image[O]) : n.texImage2D(34069 + O, z + 1, E, y, A, G.image[O])
                                            }
                                        }
                                }
                                w(i, _) && S(34067), h.__version = u.version, i.onUpdate && i.onUpdate(i)
                            }
                            t.__version = i.version
                        })(s, t, i);
                        return
                    }
                    n.bindTexture(34067, s.__webglTexture, 33984 + i)
                }, this.rebindTextures = function(e, t, n) {
                    let i = r.get(e);
                    void 0 !== t && F(i.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && B(e)
                }, this.setupRenderTarget = function(t) {
                    let o = t.texture,
                        u = r.get(t),
                        c = r.get(o);
                    t.addEventListener("dispose", C), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = e.createTexture()), c.__version = o.version, s.memory.textures++);
                    let h = !0 === t.isWebGLCubeRenderTarget,
                        d = !0 === t.isWebGLMultipleRenderTargets,
                        f = b(t) || l;
                    if (h) {
                        u.__webglFramebuffer = [];
                        for (let p = 0; p < 6; p++) u.__webglFramebuffer[p] = e.createFramebuffer()
                    } else {
                        if (u.__webglFramebuffer = e.createFramebuffer(), d) {
                            if (i.drawBuffers) {
                                let m = t.texture;
                                for (let g = 0, v = m.length; g < v; g++) {
                                    let _ = r.get(m[g]);
                                    void 0 === _.__webglTexture && (_.__webglTexture = e.createTexture(), s.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")
                        }
                        if (l && t.samples > 0 && !1 === G(t)) {
                            let y = d ? o : [o];
                            u.__webglMultisampledFramebuffer = e.createFramebuffer(), u.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer);
                            for (let x = 0; x < y.length; x++) {
                                let T = y[x];
                                u.__webglColorRenderbuffer[x] = e.createRenderbuffer(), e.bindRenderbuffer(36161, u.__webglColorRenderbuffer[x]);
                                let A = a.convert(T.format, T.encoding),
                                    E = a.convert(T.type),
                                    I = M(T.internalFormat, A, E, T.encoding, !0 === t.isXRRenderTarget),
                                    P = z(t);
                                e.renderbufferStorageMultisample(36161, P, I, t.width, t.height), e.framebufferRenderbuffer(36160, 36064 + x, 36161, u.__webglColorRenderbuffer[x])
                            }
                            e.bindRenderbuffer(36161, null), t.depthBuffer && (u.__webglDepthRenderbuffer = e.createRenderbuffer(), N(u.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null)
                        }
                    }
                    if (h) {
                        n.bindTexture(34067, c.__webglTexture), k(34067, o, f);
                        for (let R = 0; R < 6; R++) F(u.__webglFramebuffer[R], t, o, 36064, 34069 + R);
                        w(o, f) && S(34067), n.unbindTexture()
                    } else if (d) {
                        let L = t.texture;
                        for (let D = 0, U = L.length; D < U; D++) {
                            let O = L[D],
                                V = r.get(O);
                            n.bindTexture(3553, V.__webglTexture), k(3553, O, f), F(u.__webglFramebuffer, t, O, 36064 + D, 3553), w(O, f) && S(3553)
                        }
                        n.unbindTexture()
                    } else {
                        let W = 3553;
                        (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (l ? W = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(W, c.__webglTexture), k(W, o, f), F(u.__webglFramebuffer, t, o, 36064, W), w(o, f) && S(W), n.unbindTexture()
                    }
                    t.depthBuffer && B(t)
                }, this.updateRenderTargetMipmap = function(e) {
                    let t = b(e) || l,
                        i = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                    for (let a = 0, s = i.length; a < s; a++) {
                        let o = i[a];
                        if (w(o, t)) {
                            let u = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                                c = r.get(o).__webglTexture;
                            n.bindTexture(u, c), S(u), n.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(t) {
                    if (l && t.samples > 0 && !1 === G(t)) {
                        let i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
                            a = t.width,
                            s = t.height,
                            o = 16384,
                            u = [],
                            c = t.stencilBuffer ? 33306 : 36096,
                            h = r.get(t),
                            d = !0 === t.isWebGLMultipleRenderTargets;
                        if (d)
                            for (let f = 0; f < i.length; f++) n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + f, 36161, null), n.bindFramebuffer(36160, h.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + f, 3553, null, 0);
                        n.bindFramebuffer(36008, h.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, h.__webglFramebuffer);
                        for (let m = 0; m < i.length; m++) {
                            u.push(36064 + m), t.depthBuffer && u.push(c);
                            let g = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                            if (!1 === g && (t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024)), d && e.framebufferRenderbuffer(36008, 36064, 36161, h.__webglColorRenderbuffer[m]), !0 === g && (e.invalidateFramebuffer(36008, [c]), e.invalidateFramebuffer(36009, [c])), d) {
                                let v = r.get(i[m]).__webglTexture;
                                e.framebufferTexture2D(36009, 36064, 3553, v, 0)
                            }
                            e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, 9728), p && e.invalidateFramebuffer(36008, u)
                        }
                        if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), d)
                            for (let _ = 0; _ < i.length; _++) {
                                n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + _, 36161, h.__webglColorRenderbuffer[_]);
                                let y = r.get(i[_]).__webglTexture;
                                n.bindFramebuffer(36160, h.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + _, 3553, y, 0)
                            }
                        n.bindFramebuffer(36009, h.__webglMultisampledFramebuffer)
                    }
                }, this.setupDepthRenderbuffer = B, this.setupFrameBufferTexture = F, this.useMultisampledRTT = G
            }

            function sZ(e, t, n, r) {
                let i = {},
                    a = {},
                    s = [],
                    o = n.isWebGL2 ? e.getParameter(35375) : 0;

                function l(e) {
                    let t = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t
                }

                function u(t) {
                    let n = t.target;
                    n.removeEventListener("dispose", u);
                    let r = s.indexOf(n.__bindingPointIndex);
                    s.splice(r, 1), e.deleteBuffer(i[n.id]), delete i[n.id], delete a[n.id]
                }
                return {
                    bind: function(e, t) {
                        let n = t.program;
                        r.uniformBlockBinding(e, n)
                    },
                    update: function(n, c) {
                        let h = i[n.id],
                            d = n.__size;
                        n.uniforms.length !== n.__cacheCount && function(e) {
                            let t = e.uniforms,
                                n = 0,
                                r = 0;
                            for (let i = 0, a = t.length; i < a; i++) {
                                let s = t[i],
                                    o = {
                                        boundary: 0,
                                        storage: 0
                                    },
                                    u = Array.isArray(s.value) ? s.value : [s.value];
                                for (let c = 0, h = u.length; c < h; c++) {
                                    let d = u[c],
                                        f = l(d);
                                    o.boundary += f.boundary, o.storage += f.storage
                                }
                                if (s.__data || (s.__data = new Float32Array(o.storage / Float32Array.BYTES_PER_ELEMENT), s.__offset = n), i > 0) {
                                    r = n % 16;
                                    let p = 16 - r;
                                    0 !== r && p - o.boundary < 0 && (n += 16 - r, s.__offset = n)
                                }
                                n += o.storage
                            }(r = n % 16) > 0 && (n += 16 - r), e.__size = n, e.__cache || (e.__cache = {});
                            let m = e.uniforms.length;
                            e.__cacheCount = m, e.__sizeChanged = !0
                        }(n), void 0 === h && (h = function(t) {
                            let n = function() {
                                for (let e = 0; e < o; e++)
                                    if (-1 === s.indexOf(e)) return s.push(e), e;
                                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                            }();
                            t.__bindingPointIndex = n;
                            let r = e.createBuffer(),
                                i = t.__size * t.count,
                                a = t.usage;
                            return e.bindBuffer(35345, r), e.bufferData(35345, i, a), e.bindBuffer(35345, null), e.bindBufferBase(35345, n, r), r
                        }(n), i[n.id] = h, n.addEventListener("dispose", u));
                        let f = c.program;
                        r.updateUBOMapping(n, f);
                        let p = t.render.frame;
                        a[n.id] !== p && d > 0 && (function(t) {
                            let n = i[t.id],
                                r = t.uniforms,
                                a = t.__cache;
                            e.bindBuffer(35345, n);
                            for (let s = 0, o = r.length; s < o; s++) {
                                let u = r[s];
                                if (!0 === function(e, t, n) {
                                        let r = e.value;
                                        if (void 0 === n[t]) {
                                            if ("number" == typeof r) n[t] = r;
                                            else {
                                                let i = Array.isArray(r) ? r : [r],
                                                    a = [];
                                                for (let s = 0; s < i.length; s++) a.push(i[s].clone());
                                                n[t] = a
                                            }
                                            return !0
                                        }
                                        if ("number" == typeof r) {
                                            if (n[t] !== r) return n[t] = r, !0
                                        } else {
                                            let o = Array.isArray(n[t]) ? n[t] : [n[t]],
                                                l = Array.isArray(r) ? r : [r];
                                            for (let u = 0; u < o.length; u++) {
                                                let c = o[u];
                                                if (!1 === c.equals(l[u])) return c.copy(l[u]), !0
                                            }
                                        }
                                        return !1
                                    }(u, s, a) || !0 === t.__sizeChanged) {
                                    let c = Array.isArray(u.value) ? u.value : [u.value],
                                        h = 0;
                                    for (let d = 0; d < c.length; d++) {
                                        let f = c[d],
                                            p = l(f);
                                        "number" == typeof f ? (u.__data[0] = f, e.bufferSubData(35345, h, u.__data)) : f.isMatrix3 ? (u.__data[0] = f.elements[0], u.__data[1] = f.elements[1], u.__data[2] = f.elements[2], u.__data[3] = f.elements[0], u.__data[4] = f.elements[3], u.__data[5] = f.elements[4], u.__data[6] = f.elements[5], u.__data[7] = f.elements[0], u.__data[8] = f.elements[6], u.__data[9] = f.elements[7], u.__data[10] = f.elements[8], u.__data[11] = f.elements[0]) : (f.toArray(u.__data, h), h += p.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    t.__offsetNeedsUpdate.push([u.__offset, u.__data])
                                }
                            }
                            for (let m = t.__offsetNeedsUpdate.length - 1; m >= 0; m--) {
                                let g = t.__offsetNeedsUpdate[m];
                                e.bufferSubData(35345, g[0], g[1]), t.__offsetNeedsUpdate.pop()
                            }
                            t.__sizeChanged = !1, e.bindBuffer(35345, null)
                        }(n), a[n.id] = p)
                    },
                    dispose: function() {
                        for (let t in i) e.deleteBuffer(i[t]);
                        s = [], i = {}, a = {}
                    }
                }
            }

            function sY(e, t, n) {
                let r = n.isWebGL2;
                return {
                    convert: function(n, i = null) {
                        let a;
                        if (n === eA) return 5121;
                        if (n === ek) return 32819;
                        if (n === eU) return 32820;
                        if (n === eE) return 5120;
                        if (n === eC) return 5122;
                        if (n === eI) return 5123;
                        if (n === eP) return 5124;
                        if (n === eR) return 5125;
                        if (n === eL) return 5126;
                        if (n === eD) return r ? 5131 : null !== (a = t.get("OES_texture_half_float")) ? a.HALF_FLOAT_OES : null;
                        if (n === eF) return 6406;
                        if (n === eB) return 6408;
                        if (n === ez) return 6409;
                        if (n === eG) return 6410;
                        if (n === eV) return 6402;
                        if (n === eW) return 34041;
                        if (n === eH) return 6403;
                        if (n === eN) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                        if (n === t8) return null !== (a = t.get("EXT_sRGB")) ? a.SRGB_ALPHA_EXT : null;
                        if (n === ej) return 36244;
                        if (n === eq) return 33319;
                        if (n === eX) return 33320;
                        if (n === eZ) return 36249;
                        if (n === eY || n === e$ || n === eJ || n === eK) {
                            if (i === tA) {
                                if (null === (a = t.get("WEBGL_compressed_texture_s3tc_srgb"))) return null;
                                if (n === eY) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (n === e$) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (n === eJ) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (n === eK) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (null === (a = t.get("WEBGL_compressed_texture_s3tc"))) return null;
                                if (n === eY) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (n === e$) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (n === eJ) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (n === eK) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        }
                        if (n === eQ || n === e0 || n === e1 || n === e2) {
                            if (null === (a = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (n === eQ) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === e0) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === e1) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === e2) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (n === e3) return null !== (a = t.get("WEBGL_compressed_texture_etc1")) ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (n === e4 || n === e5) {
                            if (null === (a = t.get("WEBGL_compressed_texture_etc"))) return null;
                            if (n === e4) return i === tA ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                            if (n === e5) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (n === e6 || n === e8 || n === e7 || n === e9 || n === te || n === tt || n === tn || n === tr || n === ti || n === ta || n === ts || n === to || n === tl || n === tu) {
                            if (null === (a = t.get("WEBGL_compressed_texture_astc"))) return null;
                            if (n === e6) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (n === e8) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (n === e7) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (n === e9) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (n === te) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (n === tt) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (n === tn) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (n === tr) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (n === ti) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (n === ta) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (n === ts) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (n === to) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (n === tl) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (n === tu) return i === tA ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (n === tc) {
                            if (null === (a = t.get("EXT_texture_compression_bptc"))) return null;
                            if (n === tc) return i === tA ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
                        }
                        return n === eO ? r ? 34042 : null !== (a = t.get("WEBGL_depth_texture")) ? a.UNSIGNED_INT_24_8_WEBGL : null : void 0 !== e[n] ? e[n] : null
                    }
                }
            }
            class s$ extends iF {
                constructor(e = []) {
                    super(), this.isArrayCamera = !0, this.cameras = e
                }
            }
            class sJ extends nN {
                constructor(e, t, n, r = {}) {
                    super(e, t, r), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = n
                }
                copy(e) {
                    return super.copy(e), this.numViews = e.numViews, this
                }
            }
            sJ.prototype.isWebGLMultiviewRenderTarget = !0;
            class sK extends rF {
                constructor() {
                    super(), this.isGroup = !0, this.type = "Group"
                }
            }
            let sQ = {
                type: "move"
            };
            class s0 {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new sK, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new sK, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new nj, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new nj), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new sK, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new nj, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new nj), this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(e, t, n) {
                    let r = null,
                        i = null,
                        a = null,
                        s = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState) {
                        if (l && e.hand) {
                            for (let u of (a = !0, e.hand.values())) {
                                let c = t.getJointPose(u, n);
                                if (void 0 === l.joints[u.jointName]) {
                                    let h = new sK;
                                    h.matrixAutoUpdate = !1, h.visible = !1, l.joints[u.jointName] = h, l.add(h)
                                }
                                let d = l.joints[u.jointName];
                                null !== c && (d.matrix.fromArray(c.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), d.jointRadius = c.radius), d.visible = null !== c
                            }
                            let f = l.joints["index-finger-tip"],
                                p = l.joints["thumb-tip"],
                                m = f.position.distanceTo(p.position);
                            l.inputState.pinching && m > .025 ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && m <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else null !== o && e.gripSpace && null !== (i = t.getPose(e.gripSpace, n)) && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1);
                        null !== s && (null === (r = t.getPose(e.targetRaySpace, n)) && null !== i && (r = i), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), r.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = !1, r.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(sQ)))
                    }
                    return null !== s && (s.visible = null !== r), null !== o && (o.visible = null !== i), null !== l && (l.visible = null !== a), this
                }
            }
            class s1 extends nO {
                constructor(e, t, n, r, i, a, s, o, l, u) {
                    if ((u = void 0 !== u ? u : eV) !== eV && u !== eW) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && u === eV && (n = eR), void 0 === n && u === eW && (n = eO), super(null, r, i, a, s, o, u, n, l), this.isDepthTexture = !0, this.image = {
                        width: e,
                        height: t
                    }, this.magFilter = void 0 !== s ? s : eg, this.minFilter = void 0 !== o ? o : eg, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            class s2 extends t7 {
                constructor(e, t, n, r) {
                    super();
                    let i = this,
                        a = null,
                        s = 1,
                        o = null,
                        l = "local-floor",
                        u = null,
                        c = null,
                        h = null,
                        d = null,
                        f = null,
                        p = null,
                        m = t.getContextAttributes(),
                        g = null,
                        v = null,
                        _ = [],
                        y = [],
                        x = new iF;
                    x.layers.enable(1), x.viewport = new nF;
                    let b = new iF;
                    b.layers.enable(2), b.viewport = new nF;
                    let w = [x, b],
                        S = new s$;
                    S.layers.enable(1), S.layers.enable(2);
                    let M = null,
                        T = null;

                    function A(e) {
                        let t = y.indexOf(e.inputSource);
                        if (-1 === t) return;
                        let n = _[t];
                        void 0 !== n && n.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        })
                    }

                    function E() {
                        a.removeEventListener("select", A), a.removeEventListener("selectstart", A), a.removeEventListener("selectend", A), a.removeEventListener("squeeze", A), a.removeEventListener("squeezestart", A), a.removeEventListener("squeezeend", A), a.removeEventListener("end", E), a.removeEventListener("inputsourceschange", C);
                        for (let t = 0; t < _.length; t++) {
                            let n = y[t];
                            null !== n && (y[t] = null, _[t].disconnect(n))
                        }
                        M = null, T = null, e.setRenderTarget(g), f = null, d = null, h = null, a = null, v = null, D.stop(), i.isPresenting = !1, i.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function C(e) {
                        for (let t = 0; t < e.removed.length; t++) {
                            let n = e.removed[t],
                                r = y.indexOf(n);
                            r >= 0 && (y[r] = null, _[r].dispatchEvent({
                                type: "disconnected",
                                data: n
                            }))
                        }
                        for (let i = 0; i < e.added.length; i++) {
                            let a = e.added[i],
                                s = y.indexOf(a);
                            if (-1 === s) {
                                for (let o = 0; o < _.length; o++) {
                                    if (o >= y.length) {
                                        y.push(a), s = o;
                                        break
                                    }
                                    if (null === y[o]) {
                                        y[o] = a, s = o;
                                        break
                                    }
                                }
                                if (-1 === s) break
                            }
                            let l = _[s];
                            l && l.dispatchEvent({
                                type: "connected",
                                data: a
                            })
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.isMultiview = !1, this.getController = function(e) {
                        let t = _[e];
                        return void 0 === t && (t = new s0, _[e] = t), t.getTargetRaySpace()
                    }, this.getControllerGrip = function(e) {
                        let t = _[e];
                        return void 0 === t && (t = new s0, _[e] = t), t.getGripSpace()
                    }, this.getHand = function(e) {
                        let t = _[e];
                        return void 0 === t && (t = new s0, _[e] = t), t.getHandSpace()
                    }, this.setFramebufferScaleFactor = function(e) {
                        s = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function(e) {
                        l = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function() {
                        return u || o
                    }, this.setReferenceSpace = function(e) {
                        u = e
                    }, this.getBaseLayer = function() {
                        return null !== d ? d : f
                    }, this.getBinding = function() {
                        return h
                    }, this.getFrame = function() {
                        return p
                    }, this.getSession = function() {
                        return a
                    }, this.setSession = async function(c) {
                        if (null !== (a = c)) {
                            if (g = e.getRenderTarget(), a.addEventListener("select", A), a.addEventListener("selectstart", A), a.addEventListener("selectend", A), a.addEventListener("squeeze", A), a.addEventListener("squeezestart", A), a.addEventListener("squeezeend", A), a.addEventListener("end", E), a.addEventListener("inputsourceschange", C), !0 !== m.xrCompatible && await t.makeXRCompatible(), void 0 === a.renderState.layers || !1 === e.capabilities.isWebGL2) {
                                let p = {
                                    antialias: void 0 !== a.renderState.layers || m.antialias,
                                    alpha: m.alpha,
                                    depth: m.depth,
                                    stencil: m.stencil,
                                    framebufferScaleFactor: s
                                };
                                f = new XRWebGLLayer(a, t, p), a.updateRenderState({
                                    baseLayer: f
                                }), v = new nN(f.framebufferWidth, f.framebufferHeight, {
                                    format: eB,
                                    type: eA,
                                    encoding: e.outputEncoding,
                                    stencilBuffer: m.stencil
                                })
                            } else {
                                let _ = null,
                                    y = null,
                                    x = null;
                                m.depth && (x = m.stencil ? 35056 : 33190, _ = m.stencil ? eW : eV, y = m.stencil ? eO : eR), i.isMultiview = r && n.has("OCULUS_multiview");
                                let b = {
                                    colorFormat: 32856,
                                    depthFormat: x,
                                    scaleFactor: s
                                };
                                i.isMultiview && (b.textureType = "texture-array"), d = (h = new XRWebGLBinding(a, t)).createProjectionLayer(b), a.updateRenderState({
                                    layers: [d]
                                });
                                let w = {
                                    format: eB,
                                    type: eA,
                                    depthTexture: new s1(d.textureWidth, d.textureHeight, y, void 0, void 0, void 0, void 0, void 0, void 0, _),
                                    stencilBuffer: m.stencil,
                                    encoding: e.outputEncoding,
                                    samples: m.antialias ? 4 : 0
                                };
                                if (i.isMultiview) {
                                    let S = n.get("OCULUS_multiview");
                                    this.maxNumViews = t.getParameter(S.MAX_VIEWS_OVR), v = new sJ(d.textureWidth, d.textureHeight, 2, w)
                                } else v = new nN(d.textureWidth, d.textureHeight, w);
                                let M = e.properties.get(v);
                                M.__ignoreDepthValues = d.ignoreDepthValues
                            }
                            v.isXRRenderTarget = !0, this.setFoveation(1), u = null, o = await a.requestReferenceSpace(l), D.setContext(a), D.start(), i.isPresenting = !0, i.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    };
                    let I = new nj,
                        P = new nj;

                    function R(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === a) return;
                        S.near = b.near = x.near = e.near, S.far = b.far = x.far = e.far, (M !== S.near || T !== S.far) && (a.updateRenderState({
                            depthNear: S.near,
                            depthFar: S.far
                        }), M = S.near, T = S.far);
                        let t = e.parent,
                            n = S.cameras;
                        R(S, t);
                        for (let r = 0; r < n.length; r++) R(n[r], t);
                        S.matrixWorld.decompose(S.position, S.quaternion, S.scale), e.matrix.copy(S.matrix), e.matrix.decompose(e.position, e.quaternion, e.scale);
                        let i = e.children;
                        for (let s = 0, o = i.length; s < o; s++) i[s].updateMatrixWorld(!0);
                        2 === n.length ? function(e, t, n) {
                            I.setFromMatrixPosition(t.matrixWorld), P.setFromMatrixPosition(n.matrixWorld);
                            let r = I.distanceTo(P),
                                i = t.projectionMatrix.elements,
                                a = n.projectionMatrix.elements,
                                s = i[14] / (i[10] - 1),
                                o = i[14] / (i[10] + 1),
                                l = (i[9] + 1) / i[5],
                                u = (i[9] - 1) / i[5],
                                c = (i[8] - 1) / i[0],
                                h = (a[8] + 1) / a[0],
                                d = r / (-c + h),
                                f = -(d * c);
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(d), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            let p = s + d,
                                m = o + d;
                            e.projectionMatrix.makePerspective(s * c - f, s * h + (r - f), l * o / m * p, u * o / m * p, p, m)
                        }(S, x, b) : S.projectionMatrix.copy(x.projectionMatrix)
                    }, this.getCamera = function() {
                        return S
                    }, this.getFoveation = function() {
                        return null !== d ? d.fixedFoveation : null !== f ? f.fixedFoveation : void 0
                    }, this.setFoveation = function(e) {
                        null !== d && (d.fixedFoveation = e), null !== f && void 0 !== f.fixedFoveation && (f.fixedFoveation = e)
                    };
                    let L = null,
                        D = new iZ;
                    D.setAnimationLoop(function(t, n) {
                        if (c = n.getViewerPose(u || o), p = n, null !== c) {
                            let r = c.views;
                            null !== f && (e.setRenderTargetFramebuffer(v, f.framebuffer), e.setRenderTarget(v));
                            let i = !1;
                            r.length !== S.cameras.length && (S.cameras.length = 0, i = !0);
                            for (let a = 0; a < r.length; a++) {
                                let s = r[a],
                                    l = null;
                                if (null !== f) l = f.getViewport(s);
                                else {
                                    let m = h.getViewSubImage(d, s);
                                    l = m.viewport, 0 === a && (e.setRenderTargetTextures(v, m.colorTexture, d.ignoreDepthValues ? void 0 : m.depthStencilTexture), e.setRenderTarget(v))
                                }
                                let g = w[a];
                                void 0 === g && ((g = new iF).layers.enable(a), g.viewport = new nF, w[a] = g), g.matrix.fromArray(s.transform.matrix), g.projectionMatrix.fromArray(s.projectionMatrix), g.viewport.set(l.x, l.y, l.width, l.height), 0 === a && S.matrix.copy(g.matrix), !0 === i && S.cameras.push(g)
                            }
                        }
                        for (let x = 0; x < _.length; x++) {
                            let b = y[x],
                                M = _[x];
                            null !== b && void 0 !== M && M.update(b, n, u || o)
                        }
                        L && L(t, n), p = null
                    }), this.setAnimationLoop = function(e) {
                        L = e
                    }, this.dispose = function() {}
                }
            }

            function s3(e, t) {
                function n(n, r) {
                    let i, a;
                    n.opacity.value = r.opacity, r.color && n.diffuse.value.copy(r.color), r.emissive && n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (n.map.value = r.map), r.alphaMap && (n.alphaMap.value = r.alphaMap), r.bumpMap && (n.bumpMap.value = r.bumpMap, n.bumpScale.value = r.bumpScale, r.side === x && (n.bumpScale.value *= -1)), r.displacementMap && (n.displacementMap.value = r.displacementMap, n.displacementScale.value = r.displacementScale, n.displacementBias.value = r.displacementBias), r.emissiveMap && (n.emissiveMap.value = r.emissiveMap), r.normalMap && (n.normalMap.value = r.normalMap, n.normalScale.value.copy(r.normalScale), r.side === x && n.normalScale.value.negate()), r.specularMap && (n.specularMap.value = r.specularMap), r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
                    let s = t.get(r).envMap;
                    if (s && (n.envMap.value = s, n.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = r.reflectivity, n.ior.value = r.ior, n.refractionRatio.value = r.refractionRatio), r.lightMap) {
                        n.lightMap.value = r.lightMap;
                        let o = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
                        n.lightMapIntensity.value = r.lightMapIntensity * o
                    }
                    r.aoMap && (n.aoMap.value = r.aoMap, n.aoMapIntensity.value = r.aoMapIntensity), r.map ? i = r.map : r.specularMap ? i = r.specularMap : r.displacementMap ? i = r.displacementMap : r.normalMap ? i = r.normalMap : r.bumpMap ? i = r.bumpMap : r.roughnessMap ? i = r.roughnessMap : r.metalnessMap ? i = r.metalnessMap : r.alphaMap ? i = r.alphaMap : r.emissiveMap ? i = r.emissiveMap : r.clearcoatMap ? i = r.clearcoatMap : r.clearcoatNormalMap ? i = r.clearcoatNormalMap : r.clearcoatRoughnessMap ? i = r.clearcoatRoughnessMap : r.iridescenceMap ? i = r.iridescenceMap : r.iridescenceThicknessMap ? i = r.iridescenceThicknessMap : r.specularIntensityMap ? i = r.specularIntensityMap : r.specularColorMap ? i = r.specularColorMap : r.transmissionMap ? i = r.transmissionMap : r.thicknessMap ? i = r.thicknessMap : r.sheenColorMap ? i = r.sheenColorMap : r.sheenRoughnessMap && (i = r.sheenRoughnessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), n.uvTransform.value.copy(i.matrix)), r.aoMap ? a = r.aoMap : r.lightMap && (a = r.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), n.uv2Transform.value.copy(a.matrix))
                }
                return {
                    refreshFogUniforms: function(t, n) {
                        n.color.getRGB(t.fogColor.value, iD(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                    },
                    refreshMaterialUniforms: function(e, r, i, a, s) {
                        var o, l, u, c, h, d, f, p, m;
                        let g, v;
                        r.isMeshBasicMaterial ? n(e, r) : r.isMeshLambertMaterial ? n(e, r) : r.isMeshToonMaterial ? (n(e, r), o = e, r.gradientMap && (o.gradientMap.value = r.gradientMap)) : r.isMeshPhongMaterial ? (n(e, r), (l = e).specular.value.copy(r.specular), l.shininess.value = Math.max(r.shininess, 1e-4)) : r.isMeshStandardMaterial ? (n(e, r), function(e, n) {
                            e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap);
                            let r = t.get(n).envMap;
                            r && (e.envMapIntensity.value = n.envMapIntensity)
                        }(e, r), r.isMeshPhysicalMaterial && ((u = e).ior.value = r.ior, r.sheen > 0 && (u.sheenColor.value.copy(r.sheenColor).multiplyScalar(r.sheen), u.sheenRoughness.value = r.sheenRoughness, r.sheenColorMap && (u.sheenColorMap.value = r.sheenColorMap), r.sheenRoughnessMap && (u.sheenRoughnessMap.value = r.sheenRoughnessMap)), r.clearcoat > 0 && (u.clearcoat.value = r.clearcoat, u.clearcoatRoughness.value = r.clearcoatRoughness, r.clearcoatMap && (u.clearcoatMap.value = r.clearcoatMap), r.clearcoatRoughnessMap && (u.clearcoatRoughnessMap.value = r.clearcoatRoughnessMap), r.clearcoatNormalMap && (u.clearcoatNormalScale.value.copy(r.clearcoatNormalScale), u.clearcoatNormalMap.value = r.clearcoatNormalMap, r.side === x && u.clearcoatNormalScale.value.negate())), r.iridescence > 0 && (u.iridescence.value = r.iridescence, u.iridescenceIOR.value = r.iridescenceIOR, u.iridescenceThicknessMinimum.value = r.iridescenceThicknessRange[0], u.iridescenceThicknessMaximum.value = r.iridescenceThicknessRange[1], r.iridescenceMap && (u.iridescenceMap.value = r.iridescenceMap), r.iridescenceThicknessMap && (u.iridescenceThicknessMap.value = r.iridescenceThicknessMap)), r.transmission > 0 && (u.transmission.value = r.transmission, u.transmissionSamplerMap.value = s.texture, u.transmissionSamplerSize.value.set(s.width, s.height), r.transmissionMap && (u.transmissionMap.value = r.transmissionMap), u.thickness.value = r.thickness, r.thicknessMap && (u.thicknessMap.value = r.thicknessMap), u.attenuationDistance.value = r.attenuationDistance, u.attenuationColor.value.copy(r.attenuationColor)), u.specularIntensity.value = r.specularIntensity, u.specularColor.value.copy(r.specularColor), r.specularIntensityMap && (u.specularIntensityMap.value = r.specularIntensityMap), r.specularColorMap && (u.specularColorMap.value = r.specularColorMap))) : r.isMeshMatcapMaterial ? (n(e, r), c = e, r.matcap && (c.matcap.value = r.matcap)) : r.isMeshDepthMaterial ? n(e, r) : r.isMeshDistanceMaterial ? (n(e, r), (h = e).referencePosition.value.copy(r.referencePosition), h.nearDistance.value = r.nearDistance, h.farDistance.value = r.farDistance) : r.isMeshNormalMaterial ? n(e, r) : r.isLineBasicMaterial ? ((d = e).diffuse.value.copy(r.color), d.opacity.value = r.opacity, r.isLineDashedMaterial && ((f = e).dashSize.value = r.dashSize, f.totalSize.value = r.dashSize + r.gapSize, f.scale.value = r.scale)) : r.isPointsMaterial ? ((p = e).diffuse.value.copy(r.color), p.opacity.value = r.opacity, p.size.value = r.size * i, p.scale.value = .5 * a, r.map && (p.map.value = r.map), r.alphaMap && (p.alphaMap.value = r.alphaMap), r.alphaTest > 0 && (p.alphaTest.value = r.alphaTest), r.map ? g = r.map : r.alphaMap && (g = r.alphaMap), void 0 !== g && (!0 === g.matrixAutoUpdate && g.updateMatrix(), p.uvTransform.value.copy(g.matrix))) : r.isSpriteMaterial ? ((m = e).diffuse.value.copy(r.color), m.opacity.value = r.opacity, m.rotation.value = r.rotation, r.map && (m.map.value = r.map), r.alphaMap && (m.alphaMap.value = r.alphaMap), r.alphaTest > 0 && (m.alphaTest.value = r.alphaTest), r.map ? v = r.map : r.alphaMap && (v = r.alphaMap), void 0 !== v && (!0 === v.matrixAutoUpdate && v.updateMatrix(), m.uvTransform.value.copy(v.matrix))) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                    }
                }
            }
            class s4 {
                constructor(e, t, n) {
                    if (this.renderer = e, this.DEFAULT_NUMVIEWS = 2, this.maxNumViews = 0, this.gl = n, this.extensions = t, this.available = this.extensions.has("OCULUS_multiview"), this.available) {
                        let r = this.extensions.get("OCULUS_multiview");
                        this.maxNumViews = this.gl.getParameter(r.MAX_VIEWS_OVR), this.mat4 = [], this.mat3 = [], this.cameraArray = [];
                        for (var i = 0; i < this.maxNumViews; i++) this.mat4[i] = new rd, this.mat3[i] = new nm
                    }
                }
                getCameraArray(e) {
                    return e.isArrayCamera ? e.cameras : (this.cameraArray[0] = e, this.cameraArray)
                }
                updateCameraProjectionMatricesUniform(e, t) {
                    for (var n = this.getCameraArray(e), r = 0; r < n.length; r++) this.mat4[r].copy(n[r].projectionMatrix);
                    t.setValue(this.gl, "projectionMatrices", this.mat4)
                }
                updateCameraViewMatricesUniform(e, t) {
                    for (var n = this.getCameraArray(e), r = 0; r < n.length; r++) this.mat4[r].copy(n[r].matrixWorldInverse);
                    t.setValue(this.gl, "viewMatrices", this.mat4)
                }
                updateObjectMatricesUniforms(e, t, n) {
                    for (var r = this.getCameraArray(t), i = 0; i < r.length; i++) this.mat4[i].multiplyMatrices(r[i].matrixWorldInverse, e.matrixWorld), this.mat3[i].getNormalMatrix(this.mat4[i]);
                    n.setValue(this.gl, "modelViewMatrices", this.mat4), n.setValue(this.gl, "normalMatrices", this.mat3)
                }
            }

            function s5(e = {}) {
                let t, n, r, i, a, s, o, u, c, h, d, f, p, m, g, v, _, w, S, M, T, A, E, C, I, P;
                this.isWebGLRenderer = !0;
                let R = void 0 !== e.canvas ? e.canvas : function() {
                        let e = nx("canvas");
                        return e.style.display = "block", e
                    }(),
                    L = void 0 !== e.context ? e.context : null,
                    D = void 0 === e.depth || e.depth,
                    k = void 0 === e.stencil || e.stencil,
                    U = void 0 !== e.antialias && e.antialias,
                    O = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    F = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    N = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    B = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
                    z = void 0 !== e.multiviewStereo && e.multiviewStereo;
                t = null !== L ? L.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
                let G = null,
                    V = null,
                    W = [],
                    H = [];
                this.domElement = R, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = tT, this.physicallyCorrectLights = !1, this.toneMapping = et, this.toneMappingExposure = 1, Object.defineProperties(this, {
                    gammaFactor: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                        }
                    }
                });
                let j = this,
                    q = !1,
                    X = 0,
                    Z = 0,
                    Y = null,
                    $ = -1,
                    J = null,
                    K = new nF,
                    Q = new nF,
                    ee = null,
                    en = R.width,
                    er = R.height,
                    ei = 1,
                    ea = null,
                    es = null,
                    eo = new nF(0, 0, en, er),
                    el = new nF(0, 0, en, er),
                    eu = !1,
                    ec = new iX,
                    eh = !1,
                    ed = !1,
                    ef = null,
                    ep = new rd,
                    em = new np,
                    eg = new nj,
                    ev = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function e_() {
                    return null === Y ? ei : 1
                }
                let ey = L;

                function ex(e, t) {
                    for (let n = 0; n < e.length; n++) {
                        let r = e[n],
                            i = R.getContext(r, t);
                        if (null !== i) return i
                    }
                    return null
                }
                try {
                    if ("setAttribute" in R && R.setAttribute("data-engine", `three.js r${l}`), R.addEventListener("webglcontextlost", eE, !1), R.addEventListener("webglcontextrestored", eC, !1), R.addEventListener("webglcontextcreationerror", eI, !1), null === ey) {
                        let eb = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === j.isWebGL1Renderer && eb.shift(), ey = ex(eb, {
                                alpha: !0,
                                depth: D,
                                stencil: k,
                                antialias: U,
                                premultipliedAlpha: O,
                                preserveDrawingBuffer: F,
                                powerPreference: N,
                                failIfMajorPerformanceCaveat: B
                            }), null === ey) {
                            if (ex(eb)) throw Error("Error creating WebGL context with your selected attributes.");
                            throw Error("Error creating WebGL context.")
                        }
                    }
                    void 0 === ey.getShaderPrecisionFormat && (ey.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (ew) {
                    throw console.error("THREE.WebGLRenderer: " + ew.message), ew
                }

                function eS() {
                    n = new ad(ey), r = new i4(ey, n, e), n.init(r), C = new sY(ey, n, r), i = new sq(ey, n, r), a = new am, s = new sL, o = new sX(ey, n, i, s, r, C, a), u = new i6(j), c = new ah(j), h = new iY(ey, r), I = new i2(ey, n, h, r), d = new af(ey, h, a, I), f = new ay(ey, d, h, a), T = new a_(ey, r, o), _ = new i5(s), p = new sR(j, u, c, n, r, I, _), m = new s3(j, s), g = new sO, v = new sV(n, r), M = new i1(j, u, c, i, f, t, O), S = new s4(j, n, ey), w = new sj(j, f, r), P = new sZ(ey, a, r, i), A = new i3(ey, n, a, r), E = new ap(ey, n, a, r), a.programs = p.programs, j.capabilities = r, j.extensions = n, j.properties = s, j.renderLists = g, j.shadowMap = w, j.state = i, j.info = a
                }
                eS();
                let eT = new s2(j, ey, n, z);

                function eE(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), q = !0
                }

                function eC() {
                    console.log("THREE.WebGLRenderer: Context Restored."), q = !1;
                    let e = a.autoReset,
                        t = w.enabled,
                        n = w.autoUpdate,
                        r = w.needsUpdate,
                        i = w.type;
                    eS(), a.autoReset = e, w.enabled = t, w.autoUpdate = n, w.needsUpdate = r, w.type = i
                }

                function eI(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }

                function eP(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", eP),
                        function(e) {
                            let t = s.get(e).programs;
                            void 0 !== t && (t.forEach(function(e) {
                                p.releaseProgram(e)
                            }), e.isShaderMaterial && p.releaseShaderCache(e))
                        }(t), s.remove(t)
                }
                this.xr = eT, this.getContext = function() {
                    return ey
                }, this.getContextAttributes = function() {
                    return ey.getContextAttributes()
                }, this.forceContextLoss = function() {
                    let e = n.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    let e = n.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return ei
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (ei = e, this.setSize(en, er, !1))
                }, this.getSize = function(e) {
                    return e.set(en, er)
                }, this.setSize = function(e, t, n) {
                    if (eT.isPresenting) {
                        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                        return
                    }
                    en = e, er = t, R.width = Math.floor(e * ei), R.height = Math.floor(t * ei), !1 !== n && (R.style.width = e + "px", R.style.height = t + "px"), this.setViewport(0, 0, e, t)
                }, this.getDrawingBufferSize = function(e) {
                    return e.set(en * ei, er * ei).floor()
                }, this.setDrawingBufferSize = function(e, t, n) {
                    en = e, er = t, ei = n, R.width = Math.floor(e * n), R.height = Math.floor(t * n), this.setViewport(0, 0, e, t)
                }, this.getCurrentViewport = function(e) {
                    return e.copy(K)
                }, this.getViewport = function(e) {
                    return e.copy(eo)
                }, this.setViewport = function(e, t, n, r) {
                    e.isVector4 ? eo.set(e.x, e.y, e.z, e.w) : eo.set(e, t, n, r), i.viewport(K.copy(eo).multiplyScalar(ei).floor())
                }, this.getScissor = function(e) {
                    return e.copy(el)
                }, this.setScissor = function(e, t, n, r) {
                    e.isVector4 ? el.set(e.x, e.y, e.z, e.w) : el.set(e, t, n, r), i.scissor(Q.copy(el).multiplyScalar(ei).floor())
                }, this.getScissorTest = function() {
                    return eu
                }, this.setScissorTest = function(e) {
                    i.setScissorTest(eu = e)
                }, this.setOpaqueSort = function(e) {
                    ea = e
                }, this.setTransparentSort = function(e) {
                    es = e
                }, this.getClearColor = function(e) {
                    return e.copy(M.getClearColor())
                }, this.setClearColor = function() {
                    M.setClearColor.apply(M, arguments)
                }, this.getClearAlpha = function() {
                    return M.getClearAlpha()
                }, this.setClearAlpha = function() {
                    M.setClearAlpha.apply(M, arguments)
                }, this.clear = function(e = !0, t = !0, n = !0) {
                    let r = 0;
                    e && (r |= 16384), t && (r |= 256), n && (r |= 1024), ey.clear(r)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    R.removeEventListener("webglcontextlost", eE, !1), R.removeEventListener("webglcontextrestored", eC, !1), R.removeEventListener("webglcontextcreationerror", eI, !1), g.dispose(), v.dispose(), s.dispose(), u.dispose(), c.dispose(), f.dispose(), I.dispose(), P.dispose(), p.dispose(), eT.dispose(), eT.removeEventListener("sessionstart", ek), eT.removeEventListener("sessionend", eU), ef && (ef.dispose(), ef = null), eO.stop()
                }, this.renderProgram = function(e, t, n, r, a, s) {
                    let o, l = t.index,
                        u = r.isTransformFeedback ? r : t.attributes.position;
                    if (null === l) {
                        if (void 0 === u || 0 === u.count) return
                    } else if (0 === l.count) return;
                    let c = 1;
                    !0 === n.wireframe && (!r.isBatchedMesh || r.useSplit) && (l = d.getWireframeAttribute(t), c = 2), I.setup(r, n, e, t, l);
                    let f = A;
                    null !== l && (o = h.get(l), (f = E).setIndex(o));
                    let p = null !== l ? l.count : u.count,
                        m = t.drawRange.start * c,
                        g = t.drawRange.count * c,
                        v = null !== a ? a.start * c : 0,
                        _ = null !== a ? a.count * c : 1 / 0,
                        y = Math.max(m, v),
                        x = Math.max(0, Math.min(p, m + g, v + _) - 1 - y + 1);
                    if (0 !== x) {
                        if (r.isPoints) f.setMode(0);
                        else if (r.isMesh) !0 === n.wireframe ? (i.setLineWidth(n.wireframeLinewidth * e_()), f.setMode(1)) : f.setMode(4);
                        else if (r.isLine) {
                            let b = n.linewidth;
                            void 0 === b && (b = 1), i.setLineWidth(b * e_()), r.isLineSegments ? f.setMode(1) : r.isLineLoop ? f.setMode(2) : f.setMode(3)
                        } else r.isSprite && f.setMode(4);
                        if (r.isInstancedMesh || r.isTransformFeedbackInstance) f.renderInstances(y, x, r.count);
                        else if (t.isInstancedBufferGeometry) {
                            let w = Math.min(t.instanceCount, t._maxInstanceCount);
                            f.renderInstances(y, x, w)
                        } else r.isBatchedMesh ? r._starts.length > 0 && (r.isBatchedInstanceMesh ? r.useSplit ? f.renderInstances(0, r._counts[s], r._instances[s]) : f.renderInstancesMultiDraw(r._starts, r._counts, r._instances, r._starts.length) : f.renderMultiDraw(r._starts, r._counts, r._starts.length)) : f.render(y, x)
                    }
                }, this.renderBufferDirect = function(e, t, n, a, l, h) {
                    null === t && (t = ev);
                    let d = l.isMesh && 0 > l.matrixWorld.determinant(),
                        f = function(e, t, n, a, l) {
                            var h, d;
                            !0 !== t.isScene && (t = ev), o.resetTextureUnits();
                            let f = t.fog,
                                p = a.isMeshStandardMaterial ? t.environment : null,
                                g = null === Y ? j.outputEncoding : !0 === Y.isXRRenderTarget ? Y.texture.encoding : tT,
                                v = (a.isMeshStandardMaterial ? c : u).get(a.envMap || p),
                                y = !0 === a.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                b = !!a.normalMap && !!n.attributes.tangent,
                                w = !!n.morphAttributes.position,
                                M = !!n.morphAttributes.normal,
                                A = !!n.morphAttributes.color,
                                E = a.toneMapped ? j.toneMapping : et,
                                C = Y && Y.isWebGLMultiviewRenderTarget ? Y.numViews : 0,
                                I = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                R = void 0 !== I ? I.length : 0,
                                L = s.get(a),
                                D = V.state.lights;
                            if (!0 === eh && (!0 === ed || e !== J)) {
                                let k = e === J && a.id === $;
                                _.setState(a, e, k)
                            }
                            let U = !1;
                            a.version === L.__version ? L.needsLights && L.lightsStateVersion !== D.state.version ? U = !0 : L.outputEncoding !== g ? U = !0 : l.isInstancedMesh && !1 === L.instancing ? U = !0 : l.isBatchedMesh && !1 === L.batching ? U = !0 : (l.isBatchedMesh || !0 !== L.batching) && (l.isInstancedMesh || !0 !== L.instancing) ? l.isSkinnedMesh && !1 === L.skinning ? U = !0 : l.isSkinnedMesh || !0 !== L.skinning ? L.envMap !== v ? U = !0 : !0 === a.fog && L.fog !== f ? U = !0 : void 0 !== L.numClippingPlanes && (L.numClippingPlanes !== _.numPlanes || L.numIntersection !== _.numIntersection) ? U = !0 : L.vertexAlphas !== y ? U = !0 : L.vertexTangents !== b ? U = !0 : L.morphTargets !== w ? U = !0 : L.morphNormals !== M ? U = !0 : L.morphColors !== A ? U = !0 : L.toneMapping !== E ? U = !0 : !0 === r.isWebGL2 && L.morphTargetsCount !== R ? U = !0 : L.numMultiviewViews !== C && (U = !0) : U = !0 : U = !0 : (U = !0, L.__version = a.version);
                            let O = L.currentProgram;
                            !0 === U && (O = ez(a, t, l));
                            let F = !1,
                                N = !1,
                                B = !1,
                                z = O.getUniforms(),
                                G = L.uniforms;
                            if (i.useProgram(O.program) && (F = !0, N = !0, B = !0), a.id !== $ && ($ = a.id, N = !0), a.cellShading && z.setValue(ey, "isBackSide", a.side === x), F || J !== e) {
                                if (O.numMultiviewViews > 0 ? S.updateCameraProjectionMatricesUniform(e, z) : z.setValue(ey, "projectionMatrix", e.projectionMatrix), r.logarithmicDepthBuffer && z.setValue(ey, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), J !== e && (J = e, N = !0, B = !0), a.isShaderMaterial || a.isMeshPhongMaterial || a.isMeshToonMaterial || a.isMeshStandardMaterial || a.envMap) {
                                    let W = z.map.cameraPosition;
                                    void 0 !== W && W.setValue(ey, eg.setFromMatrixPosition(e.matrixWorld))
                                }(a.isMeshPhongMaterial || a.isMeshToonMaterial || a.isMeshLambertMaterial || a.isMeshBasicMaterial || a.isMeshStandardMaterial || a.isShaderMaterial) && z.setValue(ey, "isOrthographic", !0 === e.isOrthographicCamera), (a.isMeshPhongMaterial || a.isMeshToonMaterial || a.isMeshLambertMaterial || a.isMeshBasicMaterial || a.isMeshStandardMaterial || a.isShaderMaterial || a.isShadowMaterial || l.isSkinnedMesh) && (O.numMultiviewViews > 0 ? S.updateCameraViewMatricesUniform(e, z) : z.setValue(ey, "viewMatrix", e.matrixWorldInverse))
                            }
                            if (l.isSkinnedMesh) {
                                z.setOptional(ey, l, "bindMatrix"), z.setOptional(ey, l, "bindMatrixInverse");
                                let H = l.skeleton;
                                if (H && r.floatVertexTextures) {
                                    if (null === H.boneTexture) {
                                        if (l.isInstancedMesh || l.isBatchedMesh) {
                                            let q = l.isBatchedMesh ? l._maxInstanceCount : l.count;
                                            q > 0 && H.computeInstancedBoneTexture(l.instanceBones, q)
                                        } else H.computeBoneTexture()
                                    }
                                    z.setValue(ey, "boneTexture", H.boneTexture, o), z.setValue(ey, "boneTextureSize", H.boneTextureSize)
                                }
                            }
                            let X = n.morphAttributes;
                            if ((void 0 !== X.position || void 0 !== X.normal || void 0 !== X.color && !0 === r.isWebGL2) && T.update(l, n, a, O), l.isBatchedMesh) {
                                if (l.isSkinnedMesh || z.setValue(ey, "batchingTexture", l.matricesTexture, o), l.geometriesTexture && (z.setValue(ey, "geometriesTexture", l.geometriesTexture, o), z.setValue(ey, "instancePerDrawIDTexture", l.instancePerDrawIDTexture, o), l.textureIdsTexture && z.setValue(ey, "textureIdsTexture", l.textureIdsTexture, o)), l.batchUniforms && Object.keys(l.batchUniforms).length)
                                    for (let Z in l.batchUniforms) {
                                        let K = l.batchUniforms[Z];
                                        z.setValue(ey, "batching_" + Z + "_texture", K.texture, o)
                                    }
                                z.setValue(ey, "batchingTextureSize", l.matricesTextureSize), z.setValue(ey, "batchingInstanceTextureSize", l.matricesInstanceTextureSize)
                            }
                            if ((N || L.receiveShadow !== l.receiveShadow) && (L.receiveShadow = l.receiveShadow, z.setValue(ey, "receiveShadow", l.receiveShadow)), a.isMeshGouraudMaterial && null !== a.envMap && (G.envMap.value = v, G.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1), N && (z.setValue(ey, "toneMappingExposure", j.toneMappingExposure), L.needsLights && (h = G, d = B, h.ambientLightColor.needsUpdate = d, h.lightProbe.needsUpdate = d, h.directionalLights.needsUpdate = d, h.directionalLightShadows.needsUpdate = d, h.pointLights.needsUpdate = d, h.pointLightShadows.needsUpdate = d, h.spotLights.needsUpdate = d, h.spotLightShadows.needsUpdate = d, h.rectAreaLights.needsUpdate = d, h.hemisphereLights.needsUpdate = d), f && !0 === a.fog && m.refreshFogUniforms(G, f), m.refreshMaterialUniforms(G, a, ei, er, ef), sd.upload(ey, eG(L), G, o)), a.isShaderMaterial && !0 === a.uniformsNeedUpdate && (sd.upload(ey, eG(L), G, o), a.uniformsNeedUpdate = !1), a.isSpriteMaterial && z.setValue(ey, "center", l.center), O.numMultiviewViews > 0 ? S.updateObjectMatricesUniforms(l, e, z) : (z.setValue(ey, "modelViewMatrix", l.modelViewMatrix), z.setValue(ey, "normalMatrix", l.normalMatrix)), z.setValue(ey, "modelMatrix", l.matrixWorld), a.isShaderMaterial || a.isRawShaderMaterial) {
                                let Q = a.uniformsGroups;
                                for (let ee = 0, en = Q.length; ee < en; ee++)
                                    if (r.isWebGL2) {
                                        let ea = Q[ee];
                                        P.update(ea, O), P.bind(ea, O)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return O
                        }(e, t, n, a, l);
                    if (i.setMaterial(a, d), l.isBatchedInstanceMesh && l.useSplit)
                        for (let p = 0; p < l._geometries.length; p++) {
                            let g = l._geometries[p];
                            this.renderProgram(f, g, a, l, h, p)
                        } else this.renderProgram(f, n, a, l, h)
                }, this.compile = function(e, t) {
                    function n(e, t, n) {
                        !0 === e.transparent && e.side === b ? (e.side = x, e.needsUpdate = !0, ez(e, t, n), e.side = y, e.needsUpdate = !0, ez(e, t, n), e.side = b) : ez(e, t, n)
                    }(V = v.get(e)).init(), H.push(V), t && e.traverseVisible(function(e) {
                        e.isLight && e.layers.test(t.layers) && (V.pushLight(e), e.castShadow && V.pushShadow(e))
                    }), V.setupLights(j.physicallyCorrectLights), e.traverse(function(t) {
                        let r = t.material;
                        if (r) {
                            if (Array.isArray(r))
                                for (let i = 0; i < r.length; i++) {
                                    let a = r[i];
                                    n(a, e, t)
                                } else n(r, e, t)
                        }
                    }), V = null
                }, this.compileAsync = function(e, t = null, r) {
                    if (!n.has("KHR_parallel_shader_compile")) {
                        console.warn("KHR_parallel_shader_compile is not supported. Use WebGLRenderer.compile() instead."), this.compile(e);
                        return
                    }
                    t || (t = e), (V = v.get(t)).init(), H.push(V);
                    let i = e === t;
                    t.traverseVisible(function(t) {
                        t === e && (i = !0), t.isLight && (V.pushLight(t), t.castShadow && V.pushShadow(t))
                    }), i || e.traverseVisible(function(e) {
                        e.isLight && (V.pushLight(e), e.castShadow && V.pushShadow(e))
                    }), V.setupLights(j.physicallyCorrectLights);
                    let a = new Set;
                    return e.traverse(function(e) {
                        let n = e.material;
                        if (n) {
                            if (Array.isArray(n))
                                for (let i = 0; i < n.length; i++) {
                                    let s = n[i];
                                    void 0 === r && (e.isMaterialCompiling = !0), ez(s, t, e), a.add([e, s])
                                } else void 0 === r && (e.isMaterialCompiling = !0), ez(n, t, e), a.add([e, n])
                        }
                    }), V = null, new Promise(t => {
                        function r() {
                            if (a.forEach(function(e) {
                                    let [t, n] = e, r = s.get(n), i = r.currentProgram;
                                    i && i.isReady() && (t.isMaterialCompiling = !1, a.delete(e))
                                }), 0 === a.size) {
                                t(e);
                                return
                            }
                            setTimeout(r, 10)
                        }
                        null !== n.get("KHR_parallel_shader_compile") ? r() : setTimeout(r, 10)
                    })
                }, this.processTransformFeedback = function(e, t, n, r) {
                    if (q || 0 === Object.keys(t.attributes) || 0 === Object.keys(n.attributes)) return;
                    let a = s.get(r),
                        o = a.currentProgram;
                    if (!o) {
                        V = v.get(e), d.update(t), d.update(n);
                        let l = Object.keys(r.transformFeedbackVaryings),
                            u = {};
                        for (var c = 0, f = l.length; c < f; c++) u[r.transformFeedbackVaryings[l[c]]] = c;
                        a.varyings = u, r.needsUpdate = !0, ez(r, e, null);
                        return
                    }
                    var p = o.program,
                        m = o.transformFeedback,
                        g = o.getUniforms();
                    let _ = a.varyings;
                    i.useProgram(p);
                    let y = {
                        name: "",
                        buffer: null
                    };
                    for (var x in n.attributes) {
                        if (y.buffer) break;
                        void 0 !== _[x] && void 0 !== h.get(n.attributes[x]) && (y = {
                            name: x,
                            buffer: h.get(n.attributes[x]).buffer
                        })
                    }
                    if (y.buffer) {
                        for (var x in ey.bindBuffer(34962, null), ey.bindTransformFeedback(ey.TRANSFORM_FEEDBACK, m), ey.bindBuffer(34962, null), ey.enable(ey.RASTERIZER_DISCARD), ey.bindBufferBase(ey.TRANSFORM_FEEDBACK_BUFFER, 0, y.buffer), I.setup(e, r, o, t, null, !0), n.attributes) {
                            if (void 0 === _[x]) continue;
                            let b = _[x];
                            ey.vertexAttribDivisor(b, 0)
                        }
                        for (var w in r.uniforms) {
                            let S = r.uniforms[w].value;
                            g.setValue(ey, w, S)
                        }
                        ey.beginTransformFeedback(0), ey.drawArrays(0, 0, e.count), ey.endTransformFeedback(), ey.bindBufferBase(ey.TRANSFORM_FEEDBACK_BUFFER, 0, null), ey.disable(ey.RASTERIZER_DISCARD), ey.bindTransformFeedback(ey.TRANSFORM_FEEDBACK, null)
                    }
                }, this.getBufferContents = (e, t, n = 10) => {
                    e || (e = 34962);
                    let r = ey.fenceSync(ey.SYNC_GPU_COMMANDS_COMPLETE, 0),
                        i = () => {
                            let n = ey.clientWaitSync(r, ey.SYNC_FLUSH_COMMANDS_BIT, 0);
                            if (n === ey.TIMEOUT_EXPIRED);
                            else if (n === ey.WAIT_FAILED) console.error("Wait failed");
                            else {
                                let i = new Float32Array(2 * t.count);
                                ey.bindBuffer(e, h.get(t).buffer), ey.getBufferSubData(e, 0, i), console.log(i)
                            }
                        };
                    setTimeout(i, n)
                };
                let eR = null;

                function ek() {
                    eO.stop()
                }

                function eU() {
                    eO.start()
                }
                let eO = new iZ;

                function eF(e, t, a, s) {
                    let l = e.opaque,
                        u = e.transmissive,
                        c = e.transparent;
                    V.setupLightsView(a), u.length > 0 && function(e, t, i) {
                        let a = r.isWebGL2;
                        null === ef && (ef = new nN(1, 1, {
                            generateMipmaps: !0,
                            type: n.has("EXT_color_buffer_half_float") ? eD : eA,
                            minFilter: eM,
                            samples: a && !0 === U ? 4 : 0
                        })), j.getDrawingBufferSize(em), a ? ef.setSize(em.x, em.y) : ef.setSize(nc(em.x), nc(em.y));
                        let s = j.getRenderTarget();
                        j.setRenderTarget(ef), j.clear();
                        let l = j.toneMapping;
                        j.toneMapping = et, eN(e, t, i), j.toneMapping = l, o.updateMultisampleRenderTarget(ef), o.updateRenderTargetMipmap(ef), j.setRenderTarget(s)
                    }(l, t, a), s && i.viewport(K.copy(s)), l.length > 0 && eN(l, t, a), u.length > 0 && eN(u, t, a), c.length > 0 && eN(c, t, a), i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), i.setPolygonOffset(!1)
                }

                function eN(e, t, n) {
                    let r = !0 === t.isScene ? t.overrideMaterial : null,
                        i = !0 === t.isScene ? t.loadingMaterial : null;
                    for (let a = 0, s = e.length; a < s; a++) {
                        var o;
                        let l = e[a],
                            u = l.object,
                            c = l.geometry,
                            h = null === r ? i && l.object.isMaterialCompiling ? i : l.material : r,
                            d = l.group;
                        u.layers.test(n.layers) && (o = h, u.onBeforeRender(j, t, n, c, o, d), u.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, u.matrixWorld), u.normalMatrix.getNormalMatrix(u.modelViewMatrix), o.onBeforeRender(j, t, n, c, u, d), o.cellShading ? (o.side = x, o.needsUpdate = !0, j.renderBufferDirect(n, t, c, o, u, d), o.side = y, o.needsUpdate = !0, j.renderBufferDirect(n, t, c, o, u, d)) : !0 === o.transparent && o.side === b ? (o.side = x, o.needsUpdate = !0, j.renderBufferDirect(n, t, c, o, u, d), o.side = y, o.needsUpdate = !0, j.renderBufferDirect(n, t, c, o, u, d), o.side = b) : j.renderBufferDirect(n, t, c, o, u, d), u.onAfterRender(j, t, n, c, o, d))
                    }
                }

                function ez(e, t, n) {
                    !0 !== t.isScene && (t = ev);
                    let r = s.get(e),
                        i = V.state.lights,
                        a = V.state.shadowsArray,
                        o = i.state.version,
                        l = p.getParameters(e, i.state, a, t, n),
                        h = p.getProgramCacheKey(l),
                        d = r.programs;
                    r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? c : u).get(e.envMap || r.environment), void 0 === d && (e.addEventListener("dispose", eP), d = new Map, r.programs = d);
                    let f = d.get(h);
                    if (void 0 !== f) {
                        if (r.currentProgram === f && r.lightsStateVersion === o) return eV(e, l), f
                    } else l.uniforms = p.getUniforms(e), n && e.onBuild(n, l, j), e.onBeforeCompile(l, j), f = p.acquireProgram(l, h), d.set(h, f), r.uniforms = l.uniforms;
                    let m = r.uniforms;
                    return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (m.clippingPlanes = _.uniform), eV(e, l), r.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, r.lightsStateVersion = o, r.needsLights && (m.ambientLightColor.value = i.state.ambient, m.lightProbe.value = i.state.probe, m.directionalLights.value = i.state.directional, m.directionalLightShadows.value = i.state.directionalShadow, m.spotLights.value = i.state.spot, m.spotLightShadows.value = i.state.spotShadow, m.rectAreaLights.value = i.state.rectArea, m.ltc_1.value = i.state.rectAreaLTC1, m.ltc_2.value = i.state.rectAreaLTC2, m.pointLights.value = i.state.point, m.pointLightShadows.value = i.state.pointShadow, m.hemisphereLights.value = i.state.hemi, m.directionalShadowMap.value = i.state.directionalShadowMap, m.directionalShadowMatrix.value = i.state.directionalShadowMatrix, m.spotShadowMap.value = i.state.spotShadowMap, m.spotLightMatrix.value = i.state.spotLightMatrix, m.spotLightMap.value = i.state.spotLightMap, m.pointShadowMap.value = i.state.pointShadowMap, m.pointShadowMatrix.value = i.state.pointShadowMatrix), r.currentProgram = f, r.uniformsList = null, f
                }

                function eG(e) {
                    if (null === e.uniformsList) {
                        let t = e.currentProgram.getUniforms();
                        e.uniformsList = sd.seqWithValue(t.seq, e.uniforms)
                    }
                    return e.uniformsList
                }

                function eV(e, t) {
                    let n = s.get(e);
                    n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.batching = t.batching, n.batchingInstancing = t.batchingInstancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping, n.numMultiviewViews = t.numMultiviewViews
                }
                eO.setAnimationLoop(function(e) {
                    eR && eR(e)
                }), "undefined" != typeof self && eO.setContext(self), this.setAnimationLoop = function(e) {
                    eR = e, eT.setAnimationLoop(e), null === e ? eO.stop() : eO.start()
                }, eT.addEventListener("sessionstart", ek), eT.addEventListener("sessionend", eU), this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera) {
                        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        return
                    }
                    if (!0 === q) return;
                    !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === eT.enabled && !0 === eT.isPresenting && (!0 === eT.cameraAutoUpdate && eT.updateCamera(t), t = eT.getCamera()), !0 === e.isScene && e.onBeforeRender(j, e, t, Y), (V = v.get(e, H.length)).init(), H.push(V), ep.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ec.setFromProjectionMatrix(ep), ed = this.localClippingEnabled, eh = _.init(this.clippingPlanes, ed, t), (G = g.get(e, W.length)).init(), W.push(G),
                        function e(t, n, r, i) {
                            if (!1 === t.visible) return;
                            let s = t.layers.test(n.layers);
                            if (s) {
                                if (t.isGroup) r = t.renderOrder;
                                else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                                else if (t.isLight) V.pushLight(t), t.castShadow && V.pushShadow(t);
                                else if (t.isSprite) {
                                    if (!t.frustumCulled || ec.intersectsSprite(t)) {
                                        i && eg.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ep);
                                        let o = f.update(t),
                                            l = t.material;
                                        l.visible && G.push(t, o, l, r, eg.z, null)
                                    }
                                } else if (t.isBatchedMesh) {
                                    if (t.isSkinnedMesh || t.resetCullingStatus(), !t.frustumCulled || (t.isSkinnedMesh ? t.inViewport : t.intersectsFrustum(ec))) {
                                        i && eg.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ep), t.updateBatches();
                                        let u = f.update(t);
                                        if (t.useSplit)
                                            for (let c = 0; c < t.storedGeometries.length; c++) {
                                                let h = t.storedGeometries[c];
                                                f.update(null, h)
                                            }
                                        let d = t.material;
                                        d.visible && G.push(t, u, d, r, eg.z, null)
                                    }
                                } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== a.render.frame && !0 !== t.isInstancedMesh && !0 !== t.isBatchedMesh && (t.skeleton.update(), t.skeleton.frame = a.render.frame), !t.frustumCulled || ec.intersectsObject(t))) {
                                    i && eg.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ep);
                                    let p = f.update(t),
                                        m = t.material;
                                    if (Array.isArray(m)) {
                                        let g = p.groups;
                                        for (let v = 0, _ = g.length; v < _; v++) {
                                            let y = g[v],
                                                x = m[y.materialIndex];
                                            x && x.visible && G.push(t, p, x, r, eg.z, y)
                                        }
                                    } else m.visible && G.push(t, p, m, r, eg.z, null)
                                }
                            }
                            let b = t.children;
                            for (let w = 0, S = b.length; w < S; w++) e(b[w], n, r, i)
                        }(e, t, 0, j.sortObjects), G.finish(), !0 === j.sortObjects && G.sort(ea, es), !0 === eh && _.beginShadows();
                    let n = V.state.shadowsArray;
                    if (w.render(n, e, t), !0 === eh && _.endShadows(), !0 === this.info.autoReset && this.info.reset(), M.render(G, e), V.setupLights(j.physicallyCorrectLights), t.isArrayCamera) {
                        if (eT.enabled && eT.isMultiview) o.deferTextureUploads = !0, eF(G, e, t, t.cameras[0].viewport);
                        else {
                            let r = t.cameras;
                            for (let i = 0, s = r.length; i < s; i++) {
                                let l = r[i];
                                eF(G, e, l, l.viewport)
                            }
                        }
                    } else eF(G, e, t);
                    null !== Y && (o.updateMultisampleRenderTarget(Y), o.updateRenderTargetMipmap(Y)), !0 === e.isScene && e.onAfterRender(j, e, t), I.resetDefaultState(), $ = -1, J = null, H.pop(), V = H.length > 0 ? H[H.length - 1] : null, W.pop(), G = W.length > 0 ? W[W.length - 1] : null
                }, this.renderShadowMap = function(e, t, n, r) {
                    !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === n.parent && n.updateMatrixWorld(), (V = v.get(t, H.length)).init(), H.push(V), ed = this.localClippingEnabled, !0 === (eh = _.init(this.clippingPlanes, ed, n)) && _.beginShadows(), w.needsUpdate = !0, w.render(e, t, n, r), !0 === eh && _.endShadows(n), H.pop(), V = H.length > 0 ? H[H.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return X
                }, this.getActiveMipmapLevel = function() {
                    return Z
                }, this.getRenderTarget = function() {
                    return Y
                }, this.setRenderTargetTextures = function(e, t, r) {
                    s.get(e.texture).__webglTexture = t, s.get(e.depthTexture).__webglTexture = r;
                    let i = s.get(e);
                    i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === r, i.__autoAllocateDepthBuffer || Y.isWebGLMultiviewRenderTarget || !0 !== n.has("WEBGL_multisampled_render_to_texture") || (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1)
                }, this.setRenderTargetFramebuffer = function(e, t) {
                    let n = s.get(e);
                    n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function(e, t = 0, n = 0) {
                    Y = e, X = t, Z = n;
                    let a = !0;
                    if (e) {
                        let l = s.get(e);
                        void 0 !== l.__useDefaultFramebuffer ? (i.bindFramebuffer(36160, null), a = !1) : void 0 === l.__webglFramebuffer ? o.setupRenderTarget(e) : l.__hasExternalTextures && o.rebindTextures(e, s.get(e.texture).__webglTexture, s.get(e.depthTexture).__webglTexture)
                    }
                    let u = null,
                        c = !1,
                        h = !1;
                    if (e) {
                        let d = e.texture;
                        (d.isData3DTexture || d.isDataArrayTexture || d.isCompressedArrayTexture) && (h = !0);
                        let f = s.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (u = f[t], c = !0) : u = r.isWebGL2 && e.samples > 0 && !1 === o.useMultisampledRTT(e) ? s.get(e).__webglMultisampledFramebuffer : f, K.copy(e.viewport), Q.copy(e.scissor), ee = e.scissorTest
                    } else K.copy(eo).multiplyScalar(ei).floor(), Q.copy(el).multiplyScalar(ei).floor(), ee = eu;
                    let p = i.bindFramebuffer(36160, u);
                    if (p && r.drawBuffers && a && i.drawBuffers(e, u), i.viewport(K), i.scissor(Q), i.setScissorTest(ee), c) {
                        let m = s.get(e.texture);
                        ey.framebufferTexture2D(36160, 36064, 34069 + t, m.__webglTexture, n)
                    } else if (h) {
                        let g = s.get(e.texture);
                        ey.framebufferTextureLayer(36160, 36064, g.__webglTexture, n || 0, t || 0)
                    }
                    $ = -1
                }, this.readRenderTargetPixels = function(e, t, a, o, l, u, c) {
                    if (!(e && e.isWebGLRenderTarget)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        return
                    }
                    let h = s.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== c && (h = h[c]), h) {
                        i.bindFramebuffer(36160, h);
                        try {
                            let d = e.texture,
                                f = d.format,
                                p = d.type;
                            if (f !== eB && C.convert(f) !== ey.getParameter(35739)) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                return
                            }
                            let m = p === eD && (n.has("EXT_color_buffer_half_float") || r.isWebGL2 && n.has("EXT_color_buffer_float"));
                            if (p !== eA && C.convert(p) !== ey.getParameter(35738) && !(p === eL && (r.isWebGL2 || n.has("OES_texture_float") || n.has("WEBGL_color_buffer_float"))) && !m) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                return
                            }
                            t >= 0 && t <= e.width - o && a >= 0 && a <= e.height - l && ey.readPixels(t, a, o, l, C.convert(f), C.convert(p), u)
                        } finally {
                            let g = null !== Y ? s.get(Y).__webglFramebuffer : null;
                            i.bindFramebuffer(36160, g)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t, n = 0) {
                    let r = Math.pow(2, -n),
                        a = Math.floor(t.image.width * r),
                        s = Math.floor(t.image.height * r);
                    o.setTexture2D(t, 0), ey.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, a, s), i.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, n, r = 0, a = 0) {
                    let s = t.image.width,
                        l = t.image.height,
                        u = C.convert(n.format),
                        c = C.convert(n.type);
                    o.setTexture2D(n, a), ey.pixelStorei(37440, n.flipY), ey.pixelStorei(37441, n.premultiplyAlpha), ey.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? ey.texSubImage2D(3553, r, e.x, e.y, s, l, u, c, t.image.data) : t.isCompressedTexture ? ey.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, u, t.mipmaps[0].data) : ey.texSubImage2D(3553, r, e.x, e.y, u, c, t.image), 0 === r && n.generateMipmaps && ey.generateMipmap(3553), i.unbindTexture()
                }, this.copyTextureToTexture3D = function(e, t, n, r, a = 0, s = 0) {
                    let l;
                    if (j.isWebGL1Renderer) {
                        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        return
                    }
                    let u = e.max.x - e.min.x,
                        c = e.max.y - e.min.y,
                        h = e.max.z - e.min.z + 1,
                        d = C.convert(r.format, r.encoding),
                        f = C.convert(r.type);
                    if (r.isData3DTexture) o.setTexture3D(r, s), l = 32879;
                    else if (r.isDataArrayTexture || r.isCompressedArrayTexture) o.setTexture2DArray(r, s), l = 35866;
                    else {
                        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D, THREE.DataTexture2DArray, and THREE.CompressedArrayTexture.");
                        return
                    }
                    ey.pixelStorei(37440, r.flipY), ey.pixelStorei(37441, r.premultiplyAlpha), ey.pixelStorei(3317, r.unpackAlignment);
                    let p = ey.getParameter(3314),
                        m = ey.getParameter(32878),
                        g = ey.getParameter(3316),
                        v = ey.getParameter(3315),
                        _ = ey.getParameter(32877),
                        y = n.isCompressedTexture ? n.mipmaps[a] : n.image;
                    ey.pixelStorei(3314, y.width), ey.pixelStorei(32878, y.height), ey.pixelStorei(3316, e.min.x), ey.pixelStorei(3315, e.min.y), ey.pixelStorei(32877, e.min.z), n.isDataTexture || n.isData3DTexture ? ey.texSubImage3D(l, a, t.x, t.y, t.z, u, c, h, d, f, y.data) : r.isCompressedArrayTexture ? ey.compressedTexSubImage3D(l, a, t.x, t.y, t.z, u, c, h, d, y.data) : ey.texSubImage3D(l, a, t.x, t.y, t.z, u, c, h, d, f, y), ey.pixelStorei(3314, p), ey.pixelStorei(32878, m), ey.pixelStorei(3316, g), ey.pixelStorei(3315, v), ey.pixelStorei(32877, _), 0 === a && r.generateMipmaps && ey.generateMipmap(l), i.unbindTexture()
                }, this.initTexture = function(e) {
                    e.isCubeTexture ? o.setTextureCube(e, 0) : e.isData3DTexture ? o.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? o.setTexture2DArray(e, 0) : o.setTexture2D(e, 0), i.unbindTexture()
                }, this.resetState = function() {
                    X = 0, Z = 0, Y = null, i.reset(), I.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            class s6 {
                constructor(e, t, n, r, i = 1) {
                    this.material = e, this.mesh = t, this.mesh.count = i, this.mesh.geometry.attributes.position ? this.mesh.isTransformFeedbackInstance = !0 : this.mesh.isTransformFeedback = !0, this.scene = r, this.source = this.mesh.geometry, this.target = this.source.clone(), this.renderer = n
                }
                tick() {
                    this.renderer.processTransformFeedback(this.mesh, this.source, this.target, this.material), this.mesh._sortAttributes = this.material.transformFeedbackVaryings, this.mesh.geometry = this.target, this.target = this.source, this.source = this.mesh.geometry
                }
            }
            class s8 extends s5 {}
            s8.prototype.isWebGL1Renderer = !0;
            class s7 {
                constructor(e, t = 25e-5) {
                    this.isFogExp2 = !0, this.name = "", this.color = new nR(e), this.density = t
                }
                clone() {
                    return new s7(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            class s9 {
                constructor(e, t = 1, n = 1e3) {
                    this.isFog = !0, this.name = "", this.color = new nR(e), this.near = t, this.far = n
                }
                clone() {
                    return new s9(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            class oe extends rF {
                constructor() {
                    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.overrideMaterial = null
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.backgroundBlurriness = this.backgroundBlurriness), t
                }
                get autoUpdate() {
                    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
                }
                set autoUpdate(e) {
                    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e
                }
            }
            class ot {
                constructor(e, t) {
                    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = t$, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = nr()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (let r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nr()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    let t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                        n = new this.constructor(t, this.stride);
                    return n.setUsage(this.usage), n
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nr()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            let on = new nj;
            class or {
                constructor(e, t, n, r = !1) {
                    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.data.count; t < n; t++) on.fromBufferAttribute(this, t), on.applyMatrix4(e), this.setXYZ(t, on.x, on.y, on.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) on.fromBufferAttribute(this, t), on.applyNormalMatrix(e), this.setXYZ(t, on.x, on.y, on.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) on.fromBufferAttribute(this, t), on.transformDirection(e), this.setXYZ(t, on.x, on.y, on.z);
                    return this
                }
                setX(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
                }
                setY(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
                }
                setZ(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
                }
                setW(e, t) {
                    return this.normalized && (t = nd(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
                }
                getX(e) {
                    let t = this.data.array[e * this.data.stride + this.offset];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                getY(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 1];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                getZ(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 2];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                getW(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 3];
                    return this.normalized && (t = nh(t, this.array)), t
                }
                setXY(e, t, n) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = nd(t, this.array), n = nd(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                }
                setXYZ(e, t, n, r) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = nd(t, this.array), n = nd(n, this.array), r = nd(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
                }
                setXYZW(e, t, n, r, i) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = nd(t, this.array), n = nd(n, this.array), r = nd(r, this.array), i = nd(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
                }
                clone(e) {
                    if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new or(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
                        let t = [];
                        for (let n = 0; n < this.count; n++) {
                            let r = n * this.data.stride + this.offset;
                            for (let i = 0; i < this.itemSize; i++) t.push(this.data.array[r + i])
                        }
                        return new r0(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                }
                toJSON(e) {
                    if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }; {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
                        let t = [];
                        for (let n = 0; n < this.count; n++) {
                            let r = n * this.data.stride + this.offset;
                            for (let i = 0; i < this.itemSize; i++) t.push(this.data.array[r + i])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                }
            }
            class oi extends r$ {
                constructor(e) {
                    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new nR(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            let oa = new nj,
                os = new nj,
                oo = new nj,
                ol = new np,
                ou = new np,
                oc = new rd,
                oh = new nj,
                od = new nj,
                of = new nj,
                op = new np,
                om = new np,
                og = new np;
            class ov extends rF {
                constructor(e) {
                    if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === i) {
                        i = new iu;
                        let t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                            n = new ot(t, 5);
                        i.setIndex([0, 1, 2, 0, 2, 3]), i.setAttribute("position", new or(n, 3, 0, !1)), i.setAttribute("uv", new or(n, 2, 3, !1))
                    }
                    this.geometry = i, this.material = void 0 !== e ? e : new oi, this.center = new np(.5, .5)
                }
                raycast(e, t) {
                    let n, r;
                    null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), os.setFromMatrixScale(this.matrixWorld), oc.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), oo.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && os.multiplyScalar(-oo.z);
                    let i = this.material.rotation;
                    0 !== i && (r = Math.cos(i), n = Math.sin(i));
                    let a = this.center;
                    o_(oh.set(-.5, -.5, 0), oo, a, os, n, r), o_(od.set(.5, -.5, 0), oo, a, os, n, r), o_( of .set(.5, .5, 0), oo, a, os, n, r), op.set(0, 0), om.set(1, 0), og.set(1, 1);
                    let s = e.ray.intersectTriangle(oh, od, of , !1, oa);
                    if (null === s && (o_(od.set(-.5, .5, 0), oo, a, os, n, r), om.set(0, 1), null === (s = e.ray.intersectTriangle(oh, of , od, !1, oa)))) return;
                    let o = e.ray.origin.distanceTo(oa);
                    o < e.near || o > e.far || t.push({
                        distance: o,
                        point: oa.clone(),
                        uv: rZ.getUV(oa, oh, od, of , op, om, og, new np),
                        face: null,
                        object: this
                    })
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
                }
            }

            function o_(e, t, n, r, i, a) {
                ol.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (ou.x = a * ol.x - i * ol.y, ou.y = i * ol.x + a * ol.y) : ou.copy(ol), e.copy(t), e.x += ou.x, e.y += ou.y, e.applyMatrix4(oc)
            }
            let oy = new nj,
                ox = new nj;
            class ob extends rF {
                constructor() {
                    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                        levels: {
                            enumerable: !0,
                            value: []
                        },
                        isLOD: {
                            value: !0
                        }
                    }), this.autoUpdate = !0
                }
                copy(e) {
                    super.copy(e, !1);
                    let t = e.levels;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let i = t[n];
                        this.addLevel(i.object.clone(), i.distance)
                    }
                    return this.autoUpdate = e.autoUpdate, this
                }
                addLevel(e, t = 0) {
                    let n;
                    t = Math.abs(t);
                    let r = this.levels;
                    for (n = 0; n < r.length && !(t < r[n].distance); n++);
                    return r.splice(n, 0, {
                        distance: t,
                        object: e
                    }), this.add(e), this
                }
                getCurrentLevel() {
                    return this._currentLevel
                }
                getObjectForDistance(e) {
                    let t = this.levels;
                    if (t.length > 0) {
                        let n, r;
                        for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
                        return t[n - 1].object
                    }
                    return null
                }
                raycast(e, t) {
                    let n = this.levels;
                    if (n.length > 0) {
                        oy.setFromMatrixPosition(this.matrixWorld);
                        let r = e.ray.origin.distanceTo(oy);
                        this.getObjectForDistance(r).raycast(e, t)
                    }
                }
                update(e) {
                    let t = this.levels;
                    if (t.length > 1) {
                        let n, r;
                        oy.setFromMatrixPosition(e.matrixWorld), ox.setFromMatrixPosition(this.matrixWorld);
                        let i = oy.distanceTo(ox) / e.zoom;
                        for (n = 1, t[0].object.visible = !0, r = t.length; n < r; n++)
                            if (i >= t[n].distance) t[n - 1].object.visible = !1, t[n].object.visible = !0;
                            else break;
                        for (this._currentLevel = n - 1; n < r; n++) t[n].object.visible = !1
                    }
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                    let n = this.levels;
                    for (let r = 0, i = n.length; r < i; r++) {
                        let a = n[r];
                        t.object.levels.push({
                            object: a.object.uuid,
                            distance: a.distance
                        })
                    }
                    return t
                }
            }
            let ow = new nj,
                oS = new nF,
                oM = new nF,
                oT = new nj,
                oA = new rd;
            class oE extends iC {
                constructor(e, t) {
                    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new rd, this.bindMatrixInverse = new rd
                }
                copy(e, t) {
                    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
                }
                bind(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    let e = new nF,
                        t = this.geometry.attributes.skinWeight;
                    for (let n = 0, r = t.count; n < r; n++) {
                        e.fromBufferAttribute(t, n);
                        let i = 1 / e.manhattanLength();
                        i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                boneTransform(e, t) {
                    let n = this.skeleton,
                        r = this.geometry;
                    oS.fromBufferAttribute(r.attributes.skinIndex, e), oM.fromBufferAttribute(r.attributes.skinWeight, e), ow.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let i = 0; i < 4; i++) {
                        let a = oM.getComponent(i);
                        if (0 !== a) {
                            let s = oS.getComponent(i);
                            oA.multiplyMatrices(n.bones[s].matrixWorld, n.boneInverses[s]), t.addScaledVector(oT.copy(ow).applyMatrix4(oA), a)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            class oC extends nO {
                constructor(e = null, t = 1, n = 1, r, i, a, s, o, l = eg, u = eg, c, h) {
                    super(null, a, s, o, l, u, r, i, c, h), this.isDataTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n
                    }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            let oI = new rd,
                oP = new rr;
            class oR extends iC {
                constructor(e, t = 1, n = 256, r = 262144, i = 262144, a) {
                    super(new iu, e), this.supportsMultiDraw = a, this._drawStarts = [], this._drawCounts = [], this._srcOffsetAttribute = [], this._srcPosAttribute = [], this._maxInstanceCount = t, this._visibilities = [], this._inViewports = [], this._maxGeometryCount = n, this._instanceCount = t, this._maxVertexCount = r, this._maxIndexCount = i, this._currentGeometryCount = 1, this._currentVertexCount = 0, this._currentIndexCount = 0, this.batchDrawIDs = null, this.instanceMatrix = null, this.matricesTexture = null, this.matricesTextureSize = null, this.storedGeometries = new Map, this.activeGeometries = new Map, this.geometriesTexture = null, this.geometries = null, this.instances = null, this.instancePerDrawID = null, this.instancePerDrawIDTexture = null, this.batchUniforms = null, this.inViewport = !0, this._starts = [], this._counts = [], this._instances = [], this.isBatchedMesh = !0, this.isBatchedInstanceMesh = !0, this._init()
                }
                _init() {
                    let e = Math.sqrt(4 * this._maxGeometryCount);
                    e = Math.max(e = nu(e), 4);
                    let t = Math.sqrt(16 * this._maxInstanceCount);
                    t = Math.max(t = nu(t), 4);
                    let n = new Float32Array(t * t * 4),
                        r = new oC(n, t, t, eB, eL);
                    this.instanceMatrix = n, this.matricesTexture = r, this.matricesTextureSize = e, this.matricesInstanceTextureSize = t;
                    let i = new Float32Array(16 * this._maxInstanceCount);
                    this.geometries = i;
                    let a = new Float32Array(t * t * 4),
                        s = new oC(a, t, t, eH, eL),
                        o = new Float32Array(e * e * 4),
                        l = new oC(o, e, e, eH, eL);
                    this.instances = a, this.geometriesTexture = s, this.instancePerDrawID = o, this.instancePerDrawIDTexture = l, this._visibilities = Array(this._maxInstanceCount).fill(!0), this._inViewports = Array(this._maxInstanceCount).fill(!0)
                }
                registerGeometry(e, t) {
                    if (this.storedGeometries.has(t)) return this.storedGeometries.get(t);
                    if (1 === this._currentGeometryCount) {
                        for (let n in e.attributes) {
                            let r = e.getAttribute(n),
                                {
                                    array: i,
                                    itemSize: a,
                                    normalized: s
                                } = r,
                                o = new i.constructor(this._maxVertexCount * a),
                                l = new r.constructor(o, a, s);
                            l.setUsage(r.usage), this.geometry.setAttribute(n, l)
                        }
                        if (null !== e.getIndex()) {
                            let u = this._maxIndexCount > 65534 ? new Uint32Array(this._maxIndexCount) : new Uint16Array(this._maxIndexCount);
                            this.geometry.setIndex(new r0(u, 1))
                        }
                        if (!this.supportsMultiDraw) {
                            let c = new Uint16Array(this._maxIndexCount);
                            this.batchDrawIDs = new r0(c, 1)
                        }
                    }
                    let h = null !== this.geometry.getIndex(),
                        d = this.geometry.getIndex(),
                        f = e.getIndex(),
                        p = e.getAttribute("position");
                    this.boundingSphere || (e.computeBoundingSphere(), this.boundingSphere = e.boundingSphere);
                    let m = h ? this._currentIndexCount : this._currentVertexCount,
                        g = h ? f.count : p.count;
                    for (let v in (isNaN(m) || !g) && (console.error(t + ": geometry index not defined: " + m), console.error(e)), this._drawStarts.push(m), this._drawCounts.push(g), this.supportsMultiDraw || (this._srcOffsetAttribute.push(this._currentVertexCount), this._srcPosAttribute.push(p.count)), e.attributes) {
                        let _ = e.getAttribute(v),
                            y = this.geometry.getAttribute(v);
                        if (!y) throw Error(`MetaSkinnedMesh: PerksId:${t} Attribute:${v} Does not exist on the metaskinnedmesh`);
                        y.array.set(_.array, this._currentVertexCount * y.itemSize), y.needsUpdate = !0
                    }
                    if (h) {
                        for (let x = 0; x < f.count; x++) d.setX(this._currentIndexCount + x, this._currentVertexCount + f.getX(x));
                        d.needsUpdate = !0
                    }
                    if (!this.supportsMultiDraw && h) {
                        for (let b = 0; b < p.count; b++) this.batchDrawIDs.setX(this._currentVertexCount + b, this._currentGeometryCount);
                        this.batchDrawIDs.needsUpdate = !0
                    }
                    h && (this._currentIndexCount += f.count);
                    let w = this._currentGeometryCount;
                    return this._currentGeometryCount++, this.storedGeometries.set(t, w), this._currentVertexCount += p.count, this.geometry.drawRange.count = this._currentVertexCount, w
                }
                setGeometry(e, t) {
                    return this.geometries[e] = t, this
                }
                getGeometry(e) {
                    return this.geometries[e]
                }
                setInstanceCount(e) {
                    return this._instanceCount = e, this
                }
                getInstanceCount() {
                    return this._instanceCount
                }
                setMatrixAt(e, t) {
                    return t.toArray(this.instanceMatrix, 16 * e), this.matricesTexture.needsUpdate = !0, this
                }
                getMatrixAt(e, t) {
                    return t.fromArray(this.instanceMatrix, 16 * e)
                }
                setVisibilityAt(e, t) {
                    return this._visibilities[e] = t, this
                }
                getVisibilityAt(e) {
                    return this._visibilities[e]
                }
                getUniformAt(e, t) {
                    let n = this.batchUniforms[t];
                    return t.fromArray(n.data, e * n.size)
                }
                setUniformAt(e, t, n, r, i) {
                    if (this.batchUniforms || (this.batchUniforms = {}), void 0 === this.batchUniforms[t]) {
                        let a = this._maxInstanceCount,
                            s = r || 1,
                            o = Float32Array || i,
                            l = new o(a * s);
                        this.batchUniforms[t] = {
                            data: l,
                            size: s,
                            texture: new oC(l, a, 1, eB, eL)
                        }
                    }
                    n.toArray(this.batchUniforms[t].data, e * this.batchUniforms[t].size), this.batchUniforms[t].texture.needsUpdate = !0
                }
                copy(e) {
                    return super.copy(e), this.instanceMatrix = e.matrices, this.matricesTexture.copy(e.matricesTexture), this.matricesTextureSize = e.matricesTextureSize, this.matricesInstanceTextureSize = e.matricesInstanceTextureSize, this
                }
                dispose() {
                    for (let e in this.batchUniforms) {
                        let t = this.batchUniforms[e];
                        t.texture && (t.texture.dispose(), t.texture = null), delete this.batchUniforms[e]
                    }
                    this.geometriesTexture.dispose(), this.geometriesTexture = null, this.instancePerDrawIDTexture.dispose(), this.instancePerDrawIDTexture = null, this.matricesTexture.dispose(), this.matricesTexture = null
                }
                resetCullingStatus() {
                    for (let e = 0; e < this._inViewports.length; e++) this._inViewports[e] = !this.frustumCulled
                }
                intersectsFrustum(e) {
                    let t = this.boundingSphere || this.geometry.boundingSphere,
                        n = !1;
                    for (let r = 0; r < this.getInstanceCount(); r++) this.getMatrixAt(r, oI), oP.copy(t).applyMatrix4(oI), this._inViewports[r] = e.intersectsSphere(oP), n || (n = this._inViewports[r]);
                    return this.inViewport = n, n
                }
                updateBatches(e) {
                    if (!this.instancePerDrawIDTexture || !this.geometriesTexture) {
                        this._init();
                        return
                    }
                    if (!this.geometry || !this.geometry.getAttribute("position") || 0 === this._drawStarts.length) return;
                    this.activeGeometries.clear(), this.tempInview = 0;
                    for (let t = 0; t < this.getInstanceCount(); t++)
                        if (this._inViewports[t] && this._visibilities[t] || e) {
                            this.tempInview++;
                            let n = this.getGeometry(t);
                            if (!n) continue;
                            this.activeGeometries.has(n - 1) ? this.activeGeometries.get(n - 1).push(t) : this.activeGeometries.set(n - 1, [t])
                        }
                    this._starts.length = 0, this._counts.length = 0, this._instances.length = 0;
                    let r = [],
                        i = null !== this.geometry.getIndex() ? this.geometry.getIndex().array.BYTES_PER_ELEMENT : this.geometry.getAttribute("position").array.BYTES_PER_ELEMENT,
                        a = 0,
                        s = 0;
                    this.activeGeometries.forEach((e, t) => {
                        this.instancePerDrawID[s] = a;
                        for (let n = 0; n < e.length; n++) this._instances[s] ? this._instances[s]++ : (this._starts.push(this._drawStarts[t] * i), this._counts.push(this._drawCounts[t]), this._instances[s] = 1), r.push(e[n]);
                        if (a += this._instances[s], !this.supportsMultiDraw) {
                            for (let o = 0; o < this._srcPosAttribute[t]; o++) this.batchDrawIDs.setX(this._srcOffsetAttribute[t] + o, s);
                            this.batchDrawIDs.needsUpdate = !0
                        }
                        s++
                    }), this.instances.set(r, 0), this.instancePerDrawIDTexture.needsUpdate = !0, this.geometriesTexture.needsUpdate = !0, this.tempGeometries = this._starts.length, this.tempCounts = this._counts.reduce((e, t) => e + t, 0), this.tempInstance = this._instances.reduce((e, t) => e + t, 0)
                }
            }
            let oL = new rd,
                oD = new rd,
                ok = new rr;
            class oU extends oE {
                constructor(e, t = 1, n = 256, r = 262144, i = 262144, a, s = !1) {
                    super(new iu, e), this.supportsMultiDraw = a.extensions.get("WEBGL_multi_draw"), this._drawStarts = [], this._drawCounts = [], this._srcOffsetAttribute = [], this._srcPosAttribute = [], this._visibilities = [], this._inViewports = [], this._useTexture = !1, this._activeMap = new Map, this.useSplit = s, this._maxInstanceCount = t, this._maxGeometryCount = n, this._maxVertexCount = r, this._maxIndexCount = i, this._currentGeometryCount = 1, this._currentVertexCount = 0, this._currentIndexCount = 0, this.batchDrawIDs = null, this.maps = null, this.instanceBatchMatrix = null, this.matricesTextureSize = null, this.storedGeometries = [], this.storedPerksId = new Map, this.activeGeometries = new Map, this.geometriesTexture = null, this.geometriesLocal = null, this.geometries = null, this.instancePerDrawID = null, this.instancePerDrawIDTexture = null, this.textureIds = null, this.textureIdsLocal = null, this.textureIdsTexture = null, this.instanceBones = null, this.batchUniforms = null, this.inViewport = !0, this._starts = [], this._counts = [], this._instances = [], this._geometries = [], this.isBatchedMesh = !0, this.isBatchedInstanceMesh = !0, this.isSkinnedMesh = !0, this._init()
                }
                _replaceTextures() {
                    let e = Math.sqrt(16 * this._maxInstanceCount);
                    e = Math.max(e = nu(e), 4);
                    let t = new Uint8Array(e * e * 4);
                    this.textureIdsLocal && t.set(this.textureIdsLocal.subarray(0, e * e * 4), 0), this.textureIdsLocal = t;
                    let n = new Float32Array(e * e * 4);
                    this.textureIds && n.set(this.textureIds.subarray(0, e * e * 4), 0), this.textureIds = n, this.textureIdsTexture && this.textureIdsTexture.dispose(), this.textureIdsTexture = new oC(this.textureIds, e, e, eH, eL)
                }
                _replaceInstances() {
                    let e = Math.sqrt(16 * this._maxInstanceCount);
                    e = Math.max(e = nu(e), 4);
                    let t = new Float32Array(e * e * 4);
                    t.set(this.instanceBatchMatrix.subarray(0, e * e * 4), 0), this.instanceBatchMatrix = t, this.matricesInstanceTextureSize = e;
                    let n = new Uint8Array(e * e * 4);
                    n.set(this.geometriesLocal.subarray(0, e * e * 4), 0), this.geometriesLocal = null, this.geometriesLocal = n;
                    let r = new Float32Array(e * e * 4);
                    r.set(this.geometries.subarray(0, e * e * 4), 0), this.geometries = r, this.geometriesTexture.dispose(), this.geometriesTexture = new oC(this.geometries, e, e, eH, eL), this.geometriesTexture.needsUpdate = !0;
                    let i = new Uint8Array(this._maxInstanceCount).fill(!0);
                    i.set(this._visibilities.subarray(0, this._maxInstanceCount), 0), this._visibilities = i;
                    let a = new Uint8Array(this._maxInstanceCount).fill(!0);
                    a.set(this._inViewports.subarray(0, this._maxInstanceCount), 0), this._inViewports = a;
                    let s = 16 * this.skeleton.bones.length,
                        o = new Float32Array(s * this._maxInstanceCount);
                    if (o.set(this.instanceBones.subarray(0, s * this._maxInstanceCount), 0), this.instanceBones = o, this.skeleton.boneTexture && this.skeleton.boneTexture.dispose(), this.skeleton.computeInstancedBoneTexture(this.instanceBones, this._maxInstanceCount), this._useTexture && this._replaceTextures(), this.batchUniforms)
                        for (let l in this.batchUniforms) {
                            let {
                                data: u,
                                texture: c,
                                size: h,
                                format: d
                            } = this.batchUniforms[l], f = new u.constructor(this._maxInstanceCount * h);
                            f.set(u.subarray(0, this._maxInstanceCount * h), 0), this.batchUniforms[l].data = f, c && c.dispose(), this.batchUniforms[l].texture = new oC(f, this._maxInstanceCount, 1, d, eL), this.batchUniforms[l].texture.needsUpdate = !0
                        }
                }
                _initInstances() {
                    let e = Math.sqrt(16 * this._maxInstanceCount);
                    e = Math.max(e = nu(e), 4), this.instanceBatchMatrix = new Float32Array(e * e * 4), this.matricesInstanceTextureSize = e, this.geometriesLocal = new Uint8Array(e * e * 4), this.geometries = new Float32Array(e * e * 4), this.geometriesTexture = new oC(this.geometries, e, e, eH, eL), this.geometriesTexture.needsUpdate = !0, this._visibilities = new Uint8Array(this._maxInstanceCount).fill(!0), this._inViewports = new Uint8Array(this._maxInstanceCount).fill(!0)
                }
                _init() {
                    let e = Math.sqrt(4 * this._maxGeometryCount);
                    e = Math.max(e = nu(e), 4), this.matricesTextureSize = e, this.instancePerDrawID = new Float32Array(e * e * 4), this.instancePerDrawIDTexture = new oC(this.instancePerDrawID, e, e, eH, eL), this._initInstances()
                }
                _registerBatch(e, t) {
                    if (1 === this._currentGeometryCount) {
                        for (let n in e.attributes) {
                            if ("drawId" === n) continue;
                            let r = e.getAttribute(n),
                                {
                                    array: i,
                                    itemSize: a,
                                    normalized: s
                                } = r,
                                o = new i.constructor(this._maxVertexCount * a),
                                l = new r.constructor(o, a, s);
                            l.setUsage(r.usage), this.geometry.setAttribute(n, l)
                        }
                        if (null !== e.getIndex()) {
                            let u = this._maxIndexCount > 65534 ? new Uint32Array(this._maxIndexCount) : new Uint16Array(this._maxIndexCount);
                            this.geometry.setIndex(new r0(u, 1))
                        }
                        if (!this.supportsMultiDraw) {
                            let c = new Uint16Array(this._maxIndexCount);
                            this.batchDrawIDs = new r0(c, 1)
                        }
                    }
                    let h = null !== this.geometry.getIndex(),
                        d = this.geometry.getIndex(),
                        f = e.getIndex(),
                        p = e.getAttribute("position");
                    for (let m in this._drawStarts.push(h ? this._currentIndexCount : this._currentVertexCount), this._drawCounts.push(h ? f.count : p.count), this.supportsMultiDraw || (this._srcOffsetAttribute.push(this._currentVertexCount), this._srcPosAttribute.push(p.count)), e.attributes) {
                        if ("drawId" === m) continue;
                        let g = e.getAttribute(m),
                            v = this.geometry.getAttribute(m);
                        if (!v) throw Error(`MetaSkinnedMesh: PerksId:${t} Attribute:${m} Does not exist on the metaskinnedmesh`);
                        v.array.set(g.array, this._currentVertexCount * v.itemSize), v.needsUpdate = !0
                    }
                    if (h) {
                        for (let _ = 0; _ < f.count; _++) d.setX(this._currentIndexCount + _, this._currentVertexCount + f.getX(_));
                        d.needsUpdate = !0
                    }
                    if (!this.supportsMultiDraw && h) {
                        for (let y = 0; y < p.count; y++) this.batchDrawIDs.setX(this._currentVertexCount + y, this._currentGeometryCount);
                        this.batchDrawIDs.needsUpdate = !0
                    }
                    h && (this._currentIndexCount += f.count)
                }
                _registerBasic(e) {
                    let t = null !== e.getIndex(),
                        n = e.getIndex(),
                        r = e.getAttribute("position"),
                        i = new Uint8Array(t ? n.count : r.count),
                        a = new r0(i, 1);
                    for (let s = 0; s < (t ? n.count : r.count); s++) a.setX(s, this._currentGeometryCount);
                    e.setAttribute("drawId", a), e.getAttribute("drawId").needsUpdate = !0, this._drawStarts.push(0), this._drawCounts.push(t ? n.count : r.count)
                }
                registerGeometry(e, t) {
                    if (this.storedPerksId.has(t)) return this.storedPerksId.get(t);
                    if (this._currentGeometryCount > this._maxGeometryCount) {
                        console.error("Too many geometries added");
                        return
                    }
                    this.useSplit ? this._registerBasic(e) : this._registerBatch(e, t);
                    let n = this._currentGeometryCount;
                    if (this._currentGeometryCount++, this.storedPerksId.set(t, n), this.useSplit) this.storedGeometries.push(e);
                    else {
                        let r = e.getAttribute("position");
                        this._currentVertexCount += r.count, this.geometry.drawRange.count = this._currentVertexCount
                    }
                    return n
                }
                setGeometriesAt(e, t) {
                    return t.toArray(this.geometriesLocal, 16 * e), this
                }
                getGeometriesAt(e, t) {
                    return t.fromArray(this.geometriesLocal, 16 * e)
                }
                setIsActive(e, t) {
                    t ? this._activeMap.set(e, e) : this._activeMap.delete(e)
                }
                setMaxInstanceCount(e) {
                    return this._maxInstanceCount = e, this._replaceInstances(), this
                }
                getMaxInstanceCount() {
                    return this._maxInstanceCount
                }
                setMatrixAt(e, t) {
                    return t.toArray(this.instanceBatchMatrix, 16 * e), this
                }
                getMatrixAt(e, t) {
                    return t.fromArray(this.instanceBatchMatrix, 16 * e)
                }
                setTexturesAt(e, t) {
                    return this.textureIds || (this._useTexture = !0, this._replaceTextures()), t.toArray(this.textureIdsLocal, 16 * e), this.textureIdsTexture.needsUpdate = !0, this
                }
                getTexturesAt(e, t) {
                    return t.fromArray(this.textureIdsLocal, 16 * e)
                }
                setBonesAt(e, t) {
                    t = t || this.skeleton;
                    let n = 16 * t.bones.length;
                    null === this.instanceBones && (this.instanceBones = new Float32Array(n * this._maxInstanceCount)), t.update(this.instanceBones, e)
                }
                setVisibilityAt(e, t) {
                    return this._visibilities[e] = t, this
                }
                getVisibilityAt(e) {
                    return this._visibilities[e]
                }
                getUniformAt(e, t) {
                    let n = this.batchUniforms[t];
                    return t.fromArray(n.data, e * n.size)
                }
                setUniformAt(e, t, n, r, i, a) {
                    if (this.batchUniforms || (this.batchUniforms = {}), void 0 === this.batchUniforms[t]) {
                        let s = this._maxInstanceCount,
                            o = r || 1,
                            l = a || eB,
                            u = Float32Array || i,
                            c = new u(s * o);
                        this.batchUniforms[t] = {
                            data: c,
                            size: o,
                            format: l,
                            texture: new oC(c, s, 1, l, eL)
                        }
                    }
                    n.toArray(this.batchUniforms[t].data, e * this.batchUniforms[t].size), this.batchUniforms[t].texture.needsUpdate = !0
                }
                copy(e) {
                    return super.copy(e), this.instanceBatchMatrix = e.matrices, this.matricesTextureSize = e.matricesTextureSize, this.matricesInstanceTextureSize = e.matricesInstanceTextureSize, this
                }
                disposeInstances() {
                    for (let e in this.batchUniforms) {
                        let t = this.batchUniforms[e];
                        t.texture && (t.texture.dispose(), t.texture = null), delete this.batchUniforms[e]
                    }
                    this.textureIdsTexture && (this.textureIds = null, this.textureIdsTexture.dispose(), this.textureIdsTexture = null), this.instanceBones = null, this.skeleton && this.skeleton.boneTexture && (this.skeleton.boneTexture.dispose(), this.skeleton.boneTexture = null)
                }
                dispose() {
                    this.disposeInstances(), this.geometriesTexture.dispose(), this.geometriesTexture = null, this.instancePerDrawIDTexture.dispose(), this.instancePerDrawIDTexture = null, this.activeGeometries.clear(), this.storedPerksId.clear()
                }
                resetCullingStatus() {
                    for (let e = 0; e < this._inViewports.length; e++) this._inViewports[e] = !this.frustumCulled
                }
                updateBones(e, t) {
                    (t = t || this.skeleton) && (t.bones[0].updateMatrixWorld(), this.setBonesAt(e, t))
                }
                intersectsFrustum(e) {
                    let t = this.boundingSphere;
                    if (!t) return !0;
                    let n = !1;
                    for (let r of this._activeMap.values()) this.getMatrixAt(r, oL), ok.copy(t).applyMatrix4(oL), this._inViewports[r] = e.intersectsSphere(ok), n || (n = this._inViewports[r]);
                    return this.inViewport = n, n
                }
                updateBatches() {
                    if (!this.instancePerDrawIDTexture || !this.geometriesTexture) {
                        this._init();
                        return
                    }
                    if (!this.geometry || !this.geometry.getAttribute("position") || 0 === this._drawStarts.length || this.useSplit && 0 === this.storedGeometries.length) return;
                    for (let e of (this.activeGeometries.clear(), this.tempInview = 0, this._activeMap.values()))
                        if (this._inViewports[e] && this._visibilities[e]) {
                            this.tempInview++;
                            let t = this.getGeometriesAt(e, oD).elements;
                            for (let n = 0; n < t.length; n++) {
                                let r = t[n];
                                if (!r) continue;
                                let i = {
                                    value: e,
                                    offset: n
                                };
                                this.activeGeometries.has(r - 1) ? this.activeGeometries.get(r - 1).push(i) : this.activeGeometries.set(r - 1, [i])
                            }
                        }
                    this._starts.length = 0, this._counts.length = 0, this._geometries.length = 0, this._instances.length = 0;
                    let a = [],
                        s = [],
                        o = null !== this.geometry.getIndex() ? this.geometry.getIndex().array.BYTES_PER_ELEMENT : this.geometry.getAttribute("position").array.BYTES_PER_ELEMENT,
                        l = 0,
                        u = 0;
                    this.activeGeometries.forEach((e, t) => {
                        this.instancePerDrawID[u] = l;
                        for (let n = 0; n < e.length; n++) {
                            if (this._instances[u]) this._instances[u]++;
                            else {
                                if (this.useSplit) {
                                    let r = this.storedGeometries[t];
                                    if (r) {
                                        let i = null !== r.getIndex(),
                                            c = r.getAttribute("position"),
                                            h = r.getAttribute("drawId");
                                        this._geometries.push(r);
                                        for (let d = 0; d < (i ? h.count : c.count); d++) h.setX(d, u);
                                        h.needsUpdate = !0
                                    }
                                }
                                this._starts.push(this._drawStarts[t] * o), this._counts.push(this._drawCounts[t]), this._instances[u] = 1
                            }
                            a.push(e[n].value), this.textureIdsTexture && s.push(this.textureIdsLocal[16 * e[n].value + e[n].offset])
                        }
                        l += this._instances[u], u++
                    }), this.geometries.set(a, 0), this.instancePerDrawIDTexture.needsUpdate = !0, this.geometriesTexture.needsUpdate = !0, this.textureIdsTexture && (this.textureIds.set(s, 0), this.textureIdsTexture.needsUpdate = !0), this.tempGeometries = this._starts.length, this.tempCounts = this._counts.reduce((e, t) => e + t, 0), this.tempInstance = this._instances.reduce((e, t) => e + t, 0)
                }
            }
            class oO extends r0 {
                constructor(e, t, n, r = 1) {
                    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }
            let oF = new rd,
                oN = new rd,
                oB = [],
                oz = new nZ,
                oG = new rr;
            class oV extends oE {
                constructor(e, t, n) {
                    super(e, t), this.instanceMatrix = new oO(new Float32Array(16 * n), 16), this.instanceColor = null, this.instanceBones = null, this.isInstancedMesh = !0, this.count = n, this._mesh = null, this.boundingBox = null, this.boundingSphere = null
                }
                computeBoundingBox() {
                    let e = this.geometry,
                        t = this.count;
                    null === this.boundingBox && (this.boundingBox = new nZ), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, oF), oz.copy(e.boundingBox).applyMatrix4(oF), this.boundingBox.union(oz);
                    return this
                }
                computeBoundingSphere() {
                    let e = this.geometry,
                        t = this.count;
                    null === this.boundingSphere && (this.boundingSphere = new rr), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, oF), oG.copy(e.boundingSphere).applyMatrix4(oF), this.boundingSphere.union(oG);
                    return this
                }
                copy(e) {
                    return super.copy(e), e.isInstancedMesh && (this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), null !== e.instanceBones && (this.instanceBones = e.instanceBones), this.count = e.count), this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                raycast(e, t) {
                    let n = this.matrixWorld,
                        r = this.count;
                    null === this._mesh && (this._mesh = new oE(this.geometry, this.material), this._mesh.copy(this));
                    let i = this._mesh;
                    if (void 0 !== i.material)
                        for (let a = 0; a < r; a++) {
                            this.getMatrixAt(a, oF), oN.multiplyMatrices(n, oF), i.matrixWorld = oN, i.raycast(e, oB);
                            for (let s = 0, o = oB.length; s < o; s++) {
                                let l = oB[s];
                                l.instanceId = a, l.object = this, t.push(l)
                            }
                            oB.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new oO(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                setBonesAt(e, t) {
                    t = t || this.skeleton;
                    let n = 16 * t.bones.length;
                    null === this.instanceBones && (this.instanceBones = new Float32Array(n * this.count)), t.update(this.instanceBones, e)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class oW extends rF {
                constructor() {
                    super(), this.isBone = !0, this.type = "Bone"
                }
            }
            let oH = new rd,
                oj = new rd;
            class oq {
                constructor(e = [], t = []) {
                    this.uuid = nr(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                }
                init() {
                    let e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new rd)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        let n = new rd;
                        this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        let n = this.bones[e];
                        n && n.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let r = 0, i = this.bones.length; r < i; r++) {
                        let a = this.bones[r];
                        a && (a.parent && a.parent.isBone ? (a.matrix.copy(a.parent.matrixWorld).invert(), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                    }
                }
                update(e, t) {
                    let n = this.bones,
                        r = this.boneInverses,
                        i = e || this.boneMatrices,
                        a = this.boneTexture,
                        s = t || 0;
                    for (let o = 0, l = n.length; o < l; o++) {
                        let u = n[o] ? n[o].matrixWorld : oj;
                        oH.multiplyMatrices(u, r[o]), oH.toArray(i, 16 * (o + s * n.length))
                    }
                    null !== a && (a.needsUpdate = !0)
                }
                clone() {
                    return new oq(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length);
                    e = Math.max(e = nu(e), 4);
                    let t = new Float32Array(e * e * 4);
                    t.set(this.boneMatrices);
                    let n = new oC(t, e, e, eB, eL);
                    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
                }
                computeInstancedBoneTexture(e, t) {
                    this.boneTexture = new oC(e, 4 * this.bones.length, t, eB, eL), this.boneTexture.needsUpdate = !0
                }
                getBoneByName(e) {
                    for (let t = 0, n = this.bones.length; t < n; t++) {
                        let r = this.bones[t];
                        if (r.name === e) return r
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let n = 0, r = e.bones.length; n < r; n++) {
                        let i = e.bones[n],
                            a = t[i];
                        void 0 === a && (console.warn("THREE.Skeleton: No bone found with UUID:", i), a = new oW), this.bones.push(a), this.boneInverses.push(new rd().fromArray(e.boneInverses[n]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.5,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    let t = this.bones,
                        n = this.boneInverses;
                    for (let r = 0, i = t.length; r < i; r++) {
                        let a = t[r];
                        e.bones.push(a.uuid);
                        let s = n[r];
                        e.boneInverses.push(s.toArray())
                    }
                    return e
                }
            }
            let oX = new rd,
                oZ = new rd,
                oY = [],
                o$ = new nZ,
                oJ = new rd,
                oK = new iC,
                oQ = new rr;
            class o0 extends iC {
                constructor(e, t, n) {
                    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new oO(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                    for (let r = 0; r < n; r++) this.setMatrixAt(r, oJ)
                }
                computeBoundingBox() {
                    let e = this.geometry,
                        t = this.count;
                    null === this.boundingBox && (this.boundingBox = new nZ), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, oX), o$.copy(e.boundingBox).applyMatrix4(oX), this.boundingBox.union(o$);
                    return this
                }
                computeBoundingSphere() {
                    let e = this.geometry,
                        t = this.count;
                    null === this.boundingSphere && (this.boundingSphere = new rr), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                    for (let n = 0; n < t; n++) this.getMatrixAt(n, oX), oQ.copy(e.boundingSphere).applyMatrix4(oX), this.boundingSphere.union(oQ);
                    return this
                }
                copy(e, t) {
                    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                raycast(e, t) {
                    let n = this.matrixWorld,
                        r = this.count;
                    if (oK.geometry = this.geometry, oK.material = this.material, void 0 !== oK.material)
                        for (let i = 0; i < r; i++) {
                            this.getMatrixAt(i, oX), oZ.multiplyMatrices(n, oX), oK.matrixWorld = oZ, oK.raycast(e, oY);
                            for (let a = 0, s = oY.length; a < s; a++) {
                                let o = oY[a];
                                o.instanceId = i, o.object = this, t.push(o)
                            }
                            oY.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new oO(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class o1 extends r$ {
                constructor(e) {
                    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new nR(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
                }
            }
            let o2 = new nj,
                o3 = new nj,
                o4 = new rd,
                o5 = new rh,
                o6 = new rr;
            class o8 extends rF {
                constructor(e = new iu, t = new o1) {
                    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
                }
                computeLineDistances() {
                    let e = this.geometry;
                    if (null === e.index) {
                        let t = e.attributes.position,
                            n = [0];
                        for (let r = 1, i = t.count; r < i; r++) o2.fromBufferAttribute(t, r - 1), o3.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += o2.distanceTo(o3);
                        e.setAttribute("lineDistance", new r9(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
                raycast(e, t) {
                    let n = this.geometry,
                        r = this.matrixWorld,
                        i = e.params.Line.threshold,
                        a = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), o6.copy(n.boundingSphere), o6.applyMatrix4(r), o6.radius += i, !1 === e.ray.intersectsSphere(o6)) return;
                    o4.copy(r).invert(), o5.copy(e.ray).applyMatrix4(o4);
                    let s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s,
                        l = new nj,
                        u = new nj,
                        c = new nj,
                        h = new nj,
                        d = this.isLineSegments ? 2 : 1,
                        f = n.index,
                        p = n.attributes,
                        m = p.position;
                    if (null !== f) {
                        let g = Math.max(0, a.start),
                            v = Math.min(f.count, a.start + a.count);
                        for (let _ = g, y = v - 1; _ < y; _ += d) {
                            let x = f.getX(_),
                                b = f.getX(_ + 1);
                            l.fromBufferAttribute(m, x), u.fromBufferAttribute(m, b);
                            let w = o5.distanceSqToSegment(l, u, h, c);
                            if (w > o) continue;
                            h.applyMatrix4(this.matrixWorld);
                            let S = e.ray.origin.distanceTo(h);
                            S < e.near || S > e.far || t.push({
                                distance: S,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: _,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        let M = Math.max(0, a.start),
                            T = Math.min(m.count, a.start + a.count);
                        for (let A = M, E = T - 1; A < E; A += d) {
                            l.fromBufferAttribute(m, A), u.fromBufferAttribute(m, A + 1);
                            let C = o5.distanceSqToSegment(l, u, h, c);
                            if (C > o) continue;
                            h.applyMatrix4(this.matrixWorld);
                            let I = e.ray.origin.distanceTo(h);
                            I < e.near || I > e.far || t.push({
                                distance: I,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: A,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                }
                updateMorphTargets() {
                    let e = this.geometry,
                        t = e.morphAttributes,
                        n = Object.keys(t);
                    if (n.length > 0) {
                        let r = t[n[0]];
                        if (void 0 !== r) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let i = 0, a = r.length; i < a; i++) {
                                let s = r[i].name || String(i);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = i
                            }
                        }
                    }
                }
            }
            let o7 = new nj,
                o9 = new nj;
            class le extends o8 {
                constructor(e, t) {
                    super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
                }
                computeLineDistances() {
                    let e = this.geometry;
                    if (null === e.index) {
                        let t = e.attributes.position,
                            n = [];
                        for (let r = 0, i = t.count; r < i; r += 2) o7.fromBufferAttribute(t, r), o9.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + o7.distanceTo(o9);
                        e.setAttribute("lineDistance", new r9(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
            }
            class lt extends o8 {
                constructor(e, t) {
                    super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
                }
            }
            class ln extends r$ {
                constructor(e) {
                    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new nR(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            let lr = new rd,
                li = new rh,
                la = new rr,
                ls = new nj;
            class lo extends rF {
                constructor(e = new iu, t = new ln) {
                    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
                }
                raycast(e, t) {
                    let n = this.geometry,
                        r = this.matrixWorld,
                        i = e.params.Points.threshold,
                        a = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), la.copy(n.boundingSphere), la.applyMatrix4(r), la.radius += i, !1 === e.ray.intersectsSphere(la)) return;
                    lr.copy(r).invert(), li.copy(e.ray).applyMatrix4(lr);
                    let s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s,
                        l = n.index,
                        u = n.attributes,
                        c = u.position;
                    if (null !== l) {
                        let h = Math.max(0, a.start),
                            d = Math.min(l.count, a.start + a.count);
                        for (let f = h; f < d; f++) {
                            let p = l.getX(f);
                            ls.fromBufferAttribute(c, p), ll(ls, p, o, r, e, t, this)
                        }
                    } else {
                        let m = Math.max(0, a.start),
                            g = Math.min(c.count, a.start + a.count);
                        for (let v = m; v < g; v++) ls.fromBufferAttribute(c, v), ll(ls, v, o, r, e, t, this)
                    }
                }
                updateMorphTargets() {
                    let e = this.geometry,
                        t = e.morphAttributes,
                        n = Object.keys(t);
                    if (n.length > 0) {
                        let r = t[n[0]];
                        if (void 0 !== r) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let i = 0, a = r.length; i < a; i++) {
                                let s = r[i].name || String(i);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = i
                            }
                        }
                    }
                }
            }

            function ll(e, t, n, r, i, a, s) {
                let o = li.distanceSqToPoint(e);
                if (o < n) {
                    let l = new nj;
                    li.closestPointToPoint(e, l), l.applyMatrix4(r);
                    let u = i.ray.origin.distanceTo(l);
                    if (u < i.near || u > i.far) return;
                    a.push({
                        distance: u,
                        distanceToRay: Math.sqrt(o),
                        point: l,
                        index: t,
                        face: null,
                        object: s
                    })
                }
            }
            class lu extends nO {
                constructor(e, t, n, r, i, a, s, o, l) {
                    super(e, t, n, r, i, a, s, o, l), this.isVideoTexture = !0, this.minFilter = void 0 !== a ? a : eb, this.magFilter = void 0 !== i ? i : eb, this.generateMipmaps = !1;
                    let u = this;
                    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
                        u.needsUpdate = !0, e.requestVideoFrameCallback(t)
                    })
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    let e = this.image;
                    !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }
            class lc extends nO {
                constructor(e, t, n) {
                    super({
                        width: e,
                        height: t
                    }), this.isFramebufferTexture = !0, this.format = n, this.magFilter = eg, this.minFilter = eg, this.generateMipmaps = !1, this.needsUpdate = !0
                }
            }
            class lh extends nO {
                constructor(e, t, n, r, i, a, s, o, l, u, c, h) {
                    super(null, a, s, o, l, u, r, i, c, h), this.isCompressedTexture = !0, this.image = {
                        width: t,
                        height: n
                    }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            class ld extends lh {
                constructor(e, t, n, r, i, a) {
                    super(e, t, n, i, a), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = ep
                }
            }
            class lf extends nO {
                constructor(e, t, n, r, i, a, s, o, l) {
                    super(e, t, n, r, i, a, s, o, l), this.isCanvasTexture = !0, this.needsUpdate = !0
                }
            }
            class lp {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(e, t) {
                    let n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                }
                getPoints(e = 5) {
                    let t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                }
                getSpacedPoints(e = 5) {
                    let t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                }
                getLength() {
                    let e = this.getLengths();
                    return e[e.length - 1]
                }
                getLengths(e = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    let t = [],
                        n, r = this.getPoint(0),
                        i = 0;
                    t.push(0);
                    for (let a = 1; a <= e; a++) t.push(i += (n = this.getPoint(a / e)).distanceTo(r)), r = n;
                    return this.cacheArcLengths = t, t
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(e, t) {
                    let n;
                    let r = this.getLengths(),
                        i = 0,
                        a = r.length;
                    n = t || e * r[a - 1];
                    let s = 0,
                        o = a - 1,
                        l;
                    for (; s <= o;)
                        if ((l = r[i = Math.floor(s + (o - s) / 2)] - n) < 0) s = i + 1;
                        else if (l > 0) o = i - 1;
                    else {
                        o = i;
                        break
                    }
                    if (r[i = o] === n) return i / (a - 1);
                    let u = r[i],
                        c = r[i + 1],
                        h = (i + (n - u) / (c - u)) / (a - 1);
                    return h
                }
                getTangent(e, t) {
                    let n = e - 1e-4,
                        r = e + 1e-4;
                    n < 0 && (n = 0), r > 1 && (r = 1);
                    let i = this.getPoint(n),
                        a = this.getPoint(r),
                        s = t || (i.isVector2 ? new np : new nj);
                    return s.copy(a).sub(i).normalize(), s
                }
                getTangentAt(e, t) {
                    let n = this.getUtoTmapping(e);
                    return this.getTangent(n, t)
                }
                computeFrenetFrames(e, t) {
                    let n = new nj,
                        r = [],
                        i = [],
                        a = [],
                        s = new nj,
                        o = new rd;
                    for (let l = 0; l <= e; l++) {
                        let u = l / e;
                        r[l] = this.getTangentAt(u, new nj)
                    }
                    i[0] = new nj, a[0] = new nj;
                    let c = Number.MAX_VALUE,
                        h = Math.abs(r[0].x),
                        d = Math.abs(r[0].y),
                        f = Math.abs(r[0].z);
                    h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), f <= c && n.set(0, 0, 1), s.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], s), a[0].crossVectors(r[0], i[0]);
                    for (let p = 1; p <= e; p++) {
                        if (i[p] = i[p - 1].clone(), a[p] = a[p - 1].clone(), s.crossVectors(r[p - 1], r[p]), s.length() > Number.EPSILON) {
                            s.normalize();
                            let m = Math.acos(ni(r[p - 1].dot(r[p]), -1, 1));
                            i[p].applyMatrix4(o.makeRotationAxis(s, m))
                        }
                        a[p].crossVectors(r[p], i[p])
                    }
                    if (!0 === t) {
                        let g = Math.acos(ni(i[0].dot(i[e]), -1, 1));
                        g /= e, r[0].dot(s.crossVectors(i[0], i[e])) > 0 && (g = -g);
                        for (let v = 1; v <= e; v++) i[v].applyMatrix4(o.makeRotationAxis(r[v], g * v)), a[v].crossVectors(r[v], i[v])
                    }
                    return {
                        tangents: r,
                        normals: i,
                        binormals: a
                    }
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                }
                fromJSON(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }
            class lm extends lp {
                constructor(e = 0, t = 0, n = 1, r = 1, i = 0, a = 2 * Math.PI, s = !1, o = 0) {
                    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = a, this.aClockwise = s, this.aRotation = o
                }
                getPoint(e, t) {
                    let n = t || new np,
                        r = 2 * Math.PI,
                        i = this.aEndAngle - this.aStartAngle,
                        a = Math.abs(i) < Number.EPSILON;
                    for (; i < 0;) i += r;
                    for (; i > r;) i -= r;
                    i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);
                    let s = this.aStartAngle + e * i,
                        o = this.aX + this.xRadius * Math.cos(s),
                        l = this.aY + this.yRadius * Math.sin(s);
                    if (0 !== this.aRotation) {
                        let u = Math.cos(this.aRotation),
                            c = Math.sin(this.aRotation),
                            h = o - this.aX,
                            d = l - this.aY;
                        o = h * u - d * c + this.aX, l = h * c + d * u + this.aY
                    }
                    return n.set(o, l)
                }
                copy(e) {
                    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
            }
            class lg extends lm {
                constructor(e, t, n, r, i, a) {
                    super(e, t, n, n, r, i, a), this.isArcCurve = !0, this.type = "ArcCurve"
                }
            }

            function lv() {
                let e = 0,
                    t = 0,
                    n = 0,
                    r = 0;

                function i(i, a, s, o) {
                    e = i, t = s, n = -3 * i + 3 * a - 2 * s - o, r = 2 * i - 2 * a + s + o
                }
                return {
                    initCatmullRom: function(e, t, n, r, a) {
                        i(t, n, a * (n - e), a * (r - t))
                    },
                    initNonuniformCatmullRom: function(e, t, n, r, a, s, o) {
                        let l = (t - e) / a - (n - e) / (a + s) + (n - t) / s,
                            u = (n - t) / s - (r - t) / (s + o) + (r - n) / o;
                        i(t, n, l *= s, u *= s)
                    },
                    calc: function(i) {
                        let a = i * i;
                        return e + t * i + n * a + r * (a * i)
                    }
                }
            }
            let l_ = new nj,
                ly = new lv,
                lx = new lv,
                lb = new lv;
            class lw extends lp {
                constructor(e = [], t = !1, n = "centripetal", r = .5) {
                    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r
                }
                getPoint(e, t = new nj) {
                    let n, r;
                    let i = this.points,
                        a = i.length,
                        s = (a - (this.closed ? 0 : 1)) * e,
                        o = Math.floor(s),
                        l = s - o;
                    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / a) + 1) * a : 0 === l && o === a - 1 && (o = a - 2, l = 1), this.closed || o > 0 ? n = i[(o - 1) % a] : (l_.subVectors(i[0], i[1]).add(i[0]), n = l_);
                    let u = i[o % a],
                        c = i[(o + 1) % a];
                    if (this.closed || o + 2 < a ? r = i[(o + 2) % a] : (l_.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), r = l_), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        let h = "chordal" === this.curveType ? .5 : .25,
                            d = Math.pow(n.distanceToSquared(u), h),
                            f = Math.pow(u.distanceToSquared(c), h),
                            p = Math.pow(c.distanceToSquared(r), h);
                        f < 1e-4 && (f = 1), d < 1e-4 && (d = f), p < 1e-4 && (p = f), ly.initNonuniformCatmullRom(n.x, u.x, c.x, r.x, d, f, p), lx.initNonuniformCatmullRom(n.y, u.y, c.y, r.y, d, f, p), lb.initNonuniformCatmullRom(n.z, u.z, c.z, r.z, d, f, p)
                    } else "catmullrom" === this.curveType && (ly.initCatmullRom(n.x, u.x, c.x, r.x, this.tension), lx.initCatmullRom(n.y, u.y, c.y, r.y, this.tension), lb.initCatmullRom(n.z, u.z, c.z, r.z, this.tension));
                    return t.set(ly.calc(l), lx.calc(l), lb.calc(l)), t
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let r = e.points[t];
                        this.points.push(r.clone())
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        let r = this.points[t];
                        e.points.push(r.toArray())
                    }
                    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let r = e.points[t];
                        this.points.push(new nj().fromArray(r))
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
            }

            function lS(e, t, n, r, i) {
                let a = (r - t) * .5,
                    s = (i - n) * .5,
                    o = e * e;
                return (2 * n - 2 * r + a + s) * (e * o) + (-3 * n + 3 * r - 2 * a - s) * o + a * e + n
            }

            function lM(e, t, n, r) {
                return function(e, t) {
                    let n = 1 - e;
                    return n * n * t
                }(e, t) + 2 * (1 - e) * e * n + e * e * r
            }

            function lT(e, t, n, r, i) {
                return function(e, t) {
                    let n = 1 - e;
                    return n * n * n * t
                }(e, t) + function(e, t) {
                    let n = 1 - e;
                    return 3 * n * n * e * t
                }(e, n) + 3 * (1 - e) * e * e * r + e * e * e * i
            }
            class lA extends lp {
                constructor(e = new np, t = new np, n = new np, r = new np) {
                    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
                }
                getPoint(e, t = new np) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2,
                        a = this.v3;
                    return t.set(lT(e, n.x, r.x, i.x, a.x), lT(e, n.y, r.y, i.y, a.y)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            class lE extends lp {
                constructor(e = new nj, t = new nj, n = new nj, r = new nj) {
                    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
                }
                getPoint(e, t = new nj) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2,
                        a = this.v3;
                    return t.set(lT(e, n.x, r.x, i.x, a.x), lT(e, n.y, r.y, i.y, a.y), lT(e, n.z, r.z, i.z, a.z)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            class lC extends lp {
                constructor(e = new np, t = new np) {
                    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new np) {
                    return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t) {
                    let n = t || new np;
                    return n.copy(this.v2).sub(this.v1).normalize(), n
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class lI extends lp {
                constructor(e = new nj, t = new nj) {
                    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new nj) {
                    return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class lP extends lp {
                constructor(e = new np, t = new np, n = new np) {
                    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new np) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2;
                    return t.set(lM(e, n.x, r.x, i.x), lM(e, n.y, r.y, i.y)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class lR extends lp {
                constructor(e = new nj, t = new nj, n = new nj) {
                    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new nj) {
                    let n = this.v0,
                        r = this.v1,
                        i = this.v2;
                    return t.set(lM(e, n.x, r.x, i.x), lM(e, n.y, r.y, i.y), lM(e, n.z, r.z, i.z)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class lL extends lp {
                constructor(e = []) {
                    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
                }
                getPoint(e, t = new np) {
                    let n = this.points,
                        r = (n.length - 1) * e,
                        i = Math.floor(r),
                        a = r - i,
                        s = n[0 === i ? i : i - 1],
                        o = n[i],
                        l = n[i > n.length - 2 ? n.length - 1 : i + 1],
                        u = n[i > n.length - 3 ? n.length - 1 : i + 2];
                    return t.set(lS(a, s.x, o.x, l.x, u.x), lS(a, s.y, o.y, l.y, u.y)), t
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let r = e.points[t];
                        this.points.push(r.clone())
                    }
                    return this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        let r = this.points[t];
                        e.points.push(r.toArray())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        let r = e.points[t];
                        this.points.push(new np().fromArray(r))
                    }
                    return this
                }
            }
            var lD = Object.freeze({
                __proto__: null,
                ArcCurve: lg,
                CatmullRomCurve3: lw,
                CubicBezierCurve: lA,
                CubicBezierCurve3: lE,
                EllipseCurve: lm,
                LineCurve: lC,
                LineCurve3: lI,
                QuadraticBezierCurve: lP,
                QuadraticBezierCurve3: lR,
                SplineCurve: lL
            });
            class lk extends lp {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(e) {
                    this.curves.push(e)
                }
                closePath() {
                    let e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new lC(t, e))
                }
                getPoint(e, t) {
                    let n = e * this.getLength(),
                        r = this.getCurveLengths(),
                        i = 0;
                    for (; i < r.length;) {
                        if (r[i] >= n) {
                            let a = r[i] - n,
                                s = this.curves[i],
                                o = s.getLength(),
                                l = 0 === o ? 0 : 1 - a / o;
                            return s.getPointAt(l, t)
                        }
                        i++
                    }
                    return null
                }
                getLength() {
                    let e = this.getCurveLengths();
                    return e[e.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    let e = [],
                        t = 0;
                    for (let n = 0, r = this.curves.length; n < r; n++) e.push(t += this.curves[n].getLength());
                    return this.cacheLengths = e, e
                }
                getSpacedPoints(e = 40) {
                    let t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                }
                getPoints(e = 12) {
                    let t;
                    let n = [];
                    for (let r = 0, i = this.curves; r < i.length; r++) {
                        let a = i[r],
                            s = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e,
                            o = a.getPoints(s);
                        for (let l = 0; l < o.length; l++) {
                            let u = o[l];
                            t && t.equals(u) || (n.push(u), t = u)
                        }
                    }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                }
                copy(e) {
                    super.copy(e), this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        let r = e.curves[t];
                        this.curves.push(r.clone())
                    }
                    return this.autoClose = e.autoClose, this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.autoClose = this.autoClose, e.curves = [];
                    for (let t = 0, n = this.curves.length; t < n; t++) {
                        let r = this.curves[t];
                        e.curves.push(r.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        let r = e.curves[t];
                        this.curves.push(new lD[r.type]().fromJSON(r))
                    }
                    return this
                }
            }
            class lU extends lk {
                constructor(e) {
                    super(), this.type = "Path", this.currentPoint = new np, e && this.setFromPoints(e)
                }
                setFromPoints(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                }
                moveTo(e, t) {
                    return this.currentPoint.set(e, t), this
                }
                lineTo(e, t) {
                    let n = new lC(this.currentPoint.clone(), new np(e, t));
                    return this.curves.push(n), this.currentPoint.set(e, t), this
                }
                quadraticCurveTo(e, t, n, r) {
                    let i = new lP(this.currentPoint.clone(), new np(e, t), new np(n, r));
                    return this.curves.push(i), this.currentPoint.set(n, r), this
                }
                bezierCurveTo(e, t, n, r, i, a) {
                    let s = new lA(this.currentPoint.clone(), new np(e, t), new np(n, r), new np(i, a));
                    return this.curves.push(s), this.currentPoint.set(i, a), this
                }
                splineThru(e) {
                    let t = [this.currentPoint.clone()].concat(e),
                        n = new lL(t);
                    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
                }
                arc(e, t, n, r, i, a) {
                    let s = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(e + s, t + o, n, r, i, a), this
                }
                absarc(e, t, n, r, i, a) {
                    return this.absellipse(e, t, n, n, r, i, a), this
                }
                ellipse(e, t, n, r, i, a, s, o) {
                    let l = this.currentPoint.x,
                        u = this.currentPoint.y;
                    return this.absellipse(e + l, t + u, n, r, i, a, s, o), this
                }
                absellipse(e, t, n, r, i, a, s, o) {
                    let l = new lm(e, t, n, r, i, a, s, o);
                    if (this.curves.length > 0) {
                        let u = l.getPoint(0);
                        u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
                    }
                    this.curves.push(l);
                    let c = l.getPoint(1);
                    return this.currentPoint.copy(c), this
                }
                copy(e) {
                    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.currentPoint = this.currentPoint.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }
            class lO extends iu {
                constructor(e = [new np(0, -.5), new np(.5, 0), new np(0, .5)], t = 12, n = 0, r = 2 * Math.PI) {
                    super(), this.type = "LatheGeometry", this.parameters = {
                        points: e,
                        segments: t,
                        phiStart: n,
                        phiLength: r
                    }, t = Math.floor(t), r = ni(r, 0, 2 * Math.PI);
                    let i = [],
                        a = [],
                        s = [],
                        o = [],
                        l = [],
                        u = 1 / t,
                        c = new nj,
                        h = new np,
                        d = new nj,
                        f = new nj,
                        p = new nj,
                        m = 0,
                        g = 0;
                    for (let v = 0; v <= e.length - 1; v++) switch (v) {
                        case 0:
                            m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, p.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
                            break;
                        case e.length - 1:
                            o.push(p.x, p.y, p.z);
                            break;
                        default:
                            m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, f.copy(d), d.x += p.x, d.y += p.y, d.z += p.z, d.normalize(), o.push(d.x, d.y, d.z), p.copy(f)
                    }
                    for (let _ = 0; _ <= t; _++) {
                        let y = n + _ * u * r,
                            x = Math.sin(y),
                            b = Math.cos(y);
                        for (let w = 0; w <= e.length - 1; w++) {
                            c.x = e[w].x * x, c.y = e[w].y, c.z = e[w].x * b, a.push(c.x, c.y, c.z), h.x = _ / t, h.y = w / (e.length - 1), s.push(h.x, h.y);
                            let S = o[3 * w + 0] * x,
                                M = o[3 * w + 1],
                                T = o[3 * w + 0] * b;
                            l.push(S, M, T)
                        }
                    }
                    for (let A = 0; A < t; A++)
                        for (let E = 0; E < e.length - 1; E++) {
                            let C = E + A * e.length,
                                I = C + e.length,
                                P = C + e.length + 1,
                                R = C + 1;
                            i.push(C, I, R), i.push(P, R, I)
                        }
                    this.setIndex(i), this.setAttribute("position", new r9(a, 3)), this.setAttribute("uv", new r9(s, 2)), this.setAttribute("normal", new r9(l, 3))
                }
                static fromJSON(e) {
                    return new lO(e.points, e.segments, e.phiStart, e.phiLength)
                }
            }
            class lF extends lO {
                constructor(e = 1, t = 1, n = 4, r = 8) {
                    let i = new lU;
                    i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), i.absarc(0, t / 2, e, 0, .5 * Math.PI), super(i.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        capSegments: n,
                        radialSegments: r
                    }
                }
                static fromJSON(e) {
                    return new lF(e.radius, e.length, e.capSegments, e.radialSegments)
                }
            }
            class lN extends iu {
                constructor(e = 1, t = 8, n = 0, r = 2 * Math.PI) {
                    super(), this.type = "CircleGeometry", this.parameters = {
                        radius: e,
                        segments: t,
                        thetaStart: n,
                        thetaLength: r
                    }, t = Math.max(3, t);
                    let i = [],
                        a = [],
                        s = [],
                        o = [],
                        l = new nj,
                        u = new np;
                    a.push(0, 0, 0), s.push(0, 0, 1), o.push(.5, .5);
                    for (let c = 0, h = 3; c <= t; c++, h += 3) {
                        let d = n + c / t * r;
                        l.x = e * Math.cos(d), l.y = e * Math.sin(d), a.push(l.x, l.y, l.z), s.push(0, 0, 1), u.x = (a[h] / e + 1) / 2, u.y = (a[h + 1] / e + 1) / 2, o.push(u.x, u.y)
                    }
                    for (let f = 1; f <= t; f++) i.push(f, f + 1, 0);
                    this.setIndex(i), this.setAttribute("position", new r9(a, 3)), this.setAttribute("normal", new r9(s, 3)), this.setAttribute("uv", new r9(o, 2))
                }
                static fromJSON(e) {
                    return new lN(e.radius, e.segments, e.thetaStart, e.thetaLength)
                }
            }
            class lB extends iu {
                constructor(e = 1, t = 1, n = 1, r = 8, i = 1, a = !1, s = 0, o = 2 * Math.PI) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: e,
                        radiusBottom: t,
                        height: n,
                        radialSegments: r,
                        heightSegments: i,
                        openEnded: a,
                        thetaStart: s,
                        thetaLength: o
                    };
                    let l = this;
                    r = Math.floor(r), i = Math.floor(i);
                    let u = [],
                        c = [],
                        h = [],
                        d = [],
                        f = 0,
                        p = [],
                        m = n / 2,
                        g = 0;

                    function v(n) {
                        let i = f,
                            a = new np,
                            p = new nj,
                            v = 0,
                            _ = !0 === n ? e : t,
                            y = !0 === n ? 1 : -1;
                        for (let x = 1; x <= r; x++) c.push(0, m * y, 0), h.push(0, y, 0), d.push(.5, .5), f++;
                        let b = f;
                        for (let w = 0; w <= r; w++) {
                            let S = w / r,
                                M = S * o + s,
                                T = Math.cos(M),
                                A = Math.sin(M);
                            p.x = _ * A, p.y = m * y, p.z = _ * T, c.push(p.x, p.y, p.z), h.push(0, y, 0), a.x = .5 * T + .5, a.y = .5 * A * y + .5, d.push(a.x, a.y), f++
                        }
                        for (let E = 0; E < r; E++) {
                            let C = i + E,
                                I = b + E;
                            !0 === n ? u.push(I, I + 1, C) : u.push(I + 1, I, C), v += 3
                        }
                        l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                    }(function() {
                        let a = new nj,
                            v = new nj,
                            _ = 0,
                            y = (t - e) / n;
                        for (let x = 0; x <= i; x++) {
                            let b = [],
                                w = x / i,
                                S = w * (t - e) + e;
                            for (let M = 0; M <= r; M++) {
                                let T = M / r,
                                    A = T * o + s,
                                    E = Math.sin(A),
                                    C = Math.cos(A);
                                v.x = S * E, v.y = -w * n + m, v.z = S * C, c.push(v.x, v.y, v.z), a.set(E, y, C).normalize(), h.push(a.x, a.y, a.z), d.push(T, 1 - w), b.push(f++)
                            }
                            p.push(b)
                        }
                        for (let I = 0; I < r; I++)
                            for (let P = 0; P < i; P++) {
                                let R = p[P][I],
                                    L = p[P + 1][I],
                                    D = p[P + 1][I + 1],
                                    k = p[P][I + 1];
                                u.push(R, L, k), u.push(L, D, k), _ += 6
                            }
                        l.addGroup(g, _, 0), g += _
                    })(), !1 === a && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(u), this.setAttribute("position", new r9(c, 3)), this.setAttribute("normal", new r9(h, 3)), this.setAttribute("uv", new r9(d, 2))
                }
                static fromJSON(e) {
                    return new lB(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class lz extends lB {
                constructor(e = 1, t = 1, n = 8, r = 1, i = !1, a = 0, s = 2 * Math.PI) {
                    super(0, e, t, n, r, i, a, s), this.type = "ConeGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        radialSegments: n,
                        heightSegments: r,
                        openEnded: i,
                        thetaStart: a,
                        thetaLength: s
                    }
                }
                static fromJSON(e) {
                    return new lz(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class lG extends iu {
                constructor(e = [], t = [], n = 1, r = 0) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: e,
                        indices: t,
                        radius: n,
                        detail: r
                    };
                    let i = [],
                        a = [];

                    function s(e) {
                        i.push(e.x, e.y, e.z)
                    }

                    function o(t, n) {
                        let r = 3 * t;
                        n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
                    }

                    function l(e, t, n, r) {
                        r < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === n.x && 0 === n.z && (a[t] = r / 2 / Math.PI + .5)
                    }

                    function u(e) {
                        return Math.atan2(e.z, -e.x)
                    }(function(e) {
                        let n = new nj,
                            r = new nj,
                            i = new nj;
                        for (let a = 0; a < t.length; a += 3) o(t[a + 0], n), o(t[a + 1], r), o(t[a + 2], i),
                            function(e, t, n, r) {
                                let i = r + 1,
                                    a = [];
                                for (let o = 0; o <= i; o++) {
                                    a[o] = [];
                                    let l = e.clone().lerp(n, o / i),
                                        u = t.clone().lerp(n, o / i),
                                        c = i - o;
                                    for (let h = 0; h <= c; h++) 0 === h && o === i ? a[o][h] = l : a[o][h] = l.clone().lerp(u, h / c)
                                }
                                for (let d = 0; d < i; d++)
                                    for (let f = 0; f < 2 * (i - d) - 1; f++) {
                                        let p = Math.floor(f / 2);
                                        f % 2 == 0 ? (s(a[d][p + 1]), s(a[d + 1][p]), s(a[d][p])) : (s(a[d][p + 1]), s(a[d + 1][p + 1]), s(a[d + 1][p]))
                                    }
                            }(n, r, i, e)
                    })(r),
                    function(e) {
                        let t = new nj;
                        for (let n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z
                    }(n),
                    function() {
                        let e = new nj;
                        for (let t = 0; t < i.length; t += 3) {
                            e.x = i[t + 0], e.y = i[t + 1], e.z = i[t + 2];
                            let n = u(e) / 2 / Math.PI + .5,
                                r = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5;
                            a.push(n, 1 - r)
                        }(function() {
                            let e = new nj,
                                t = new nj,
                                n = new nj,
                                r = new nj,
                                s = new np,
                                o = new np,
                                c = new np;
                            for (let h = 0, d = 0; h < i.length; h += 9, d += 6) {
                                e.set(i[h + 0], i[h + 1], i[h + 2]), t.set(i[h + 3], i[h + 4], i[h + 5]), n.set(i[h + 6], i[h + 7], i[h + 8]), s.set(a[d + 0], a[d + 1]), o.set(a[d + 2], a[d + 3]), c.set(a[d + 4], a[d + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                                let f = u(r);
                                l(s, d + 0, e, f), l(o, d + 2, t, f), l(c, d + 4, n, f)
                            }
                        })(),
                        function() {
                            for (let e = 0; e < a.length; e += 6) {
                                let t = a[e + 0],
                                    n = a[e + 2],
                                    r = a[e + 4],
                                    i = Math.max(t, n, r),
                                    s = Math.min(t, n, r);
                                i > .9 && s < .1 && (t < .2 && (a[e + 0] += 1), n < .2 && (a[e + 2] += 1), r < .2 && (a[e + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new r9(i, 3)), this.setAttribute("normal", new r9(i.slice(), 3)), this.setAttribute("uv", new r9(a, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
                }
                static fromJSON(e) {
                    return new lG(e.vertices, e.indices, e.radius, e.details)
                }
            }
            class lV extends lG {
                constructor(e = 1, t = 0) {
                    let n = (1 + Math.sqrt(5)) / 2,
                        r = 1 / n;
                    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new lV(e.radius, e.detail)
                }
            }
            let lW = new nj,
                lH = new nj,
                lj = new nj,
                lq = new rZ;
            class lX extends iu {
                constructor(e = null, t = 1) {
                    if (super(), this.type = "EdgesGeometry", this.parameters = {
                            geometry: e,
                            thresholdAngle: t
                        }, null !== e) {
                        let n = Math.cos(nt * t),
                            r = e.getIndex(),
                            i = e.getAttribute("position"),
                            a = r ? r.count : i.count,
                            s = [0, 0, 0],
                            o = ["a", "b", "c"],
                            l = [, , , ],
                            u = {},
                            c = [];
                        for (let h = 0; h < a; h += 3) {
                            r ? (s[0] = r.getX(h), s[1] = r.getX(h + 1), s[2] = r.getX(h + 2)) : (s[0] = h, s[1] = h + 1, s[2] = h + 2);
                            let {
                                a: d,
                                b: f,
                                c: p
                            } = lq;
                            if (d.fromBufferAttribute(i, s[0]), f.fromBufferAttribute(i, s[1]), p.fromBufferAttribute(i, s[2]), lq.getNormal(lj), l[0] = `${Math.round(1e4*d.x)},${Math.round(1e4*d.y)},${Math.round(1e4*d.z)}`, l[1] = `${Math.round(1e4*f.x)},${Math.round(1e4*f.y)},${Math.round(1e4*f.z)}`, l[2] = `${Math.round(1e4*p.x)},${Math.round(1e4*p.y)},${Math.round(1e4*p.z)}`, l[0] !== l[1] && l[1] !== l[2] && l[2] !== l[0])
                                for (let m = 0; m < 3; m++) {
                                    let g = (m + 1) % 3,
                                        v = l[m],
                                        _ = l[g],
                                        y = lq[o[m]],
                                        x = lq[o[g]],
                                        b = `${v}_${_}`,
                                        w = `${_}_${v}`;
                                    w in u && u[w] ? (lj.dot(u[w].normal) <= n && (c.push(y.x, y.y, y.z), c.push(x.x, x.y, x.z)), u[w] = null) : b in u || (u[b] = {
                                        index0: s[m],
                                        index1: s[g],
                                        normal: lj.clone()
                                    })
                                }
                        }
                        for (let S in u)
                            if (u[S]) {
                                let {
                                    index0: M,
                                    index1: T
                                } = u[S];
                                lW.fromBufferAttribute(i, M), lH.fromBufferAttribute(i, T), c.push(lW.x, lW.y, lW.z), c.push(lH.x, lH.y, lH.z)
                            }
                        this.setAttribute("position", new r9(c, 3))
                    }
                }
            }
            class lZ extends lU {
                constructor(e) {
                    super(e), this.uuid = nr(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(e) {
                    let t = [];
                    for (let n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                }
                extractPoints(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                }
                copy(e) {
                    super.copy(e), this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        let r = e.holes[t];
                        this.holes.push(r.clone())
                    }
                    return this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.uuid = this.uuid, e.holes = [];
                    for (let t = 0, n = this.holes.length; t < n; t++) {
                        let r = this.holes[t];
                        e.holes.push(r.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        let r = e.holes[t];
                        this.holes.push(new lU().fromJSON(r))
                    }
                    return this
                }
            }
            let lY = {
                triangulate: function(e, t, n = 2) {
                    let r, i, a, s, o, l, u;
                    let c = t && t.length,
                        h = c ? t[0] * n : e.length,
                        d = l$(e, 0, h, n, !0),
                        f = [];
                    if (!d || d.next === d.prev) return f;
                    if (c && (d = function(e, t, n, r) {
                            let i, a, s, o, l;
                            let u = [];
                            for (i = 0, a = t.length; i < a; i++) s = t[i] * r, o = i < a - 1 ? t[i + 1] * r : e.length, (l = l$(e, s, o, r, !1)) === l.next && (l.steiner = !0), u.push(function(e) {
                                let t = e,
                                    n = e;
                                do(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== e);
                                return n
                            }(l));
                            for (u.sort(lK), i = 0; i < u.length; i++)(function(e, t) {
                                if (t = function(e, t) {
                                        let n = t,
                                            r = e.x,
                                            i = e.y,
                                            a = -1 / 0,
                                            s;
                                        do {
                                            if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                                                let o = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                                if (o <= r && o > a) {
                                                    if (a = o, o === r) {
                                                        if (i === n.y) return n;
                                                        if (i === n.next.y) return n.next
                                                    }
                                                    s = n.x < n.next.x ? n : n.next
                                                }
                                            }
                                            n = n.next
                                        } while (n !== t);
                                        if (!s) return null;
                                        if (r === a) return s;
                                        let l = s,
                                            u = s.x,
                                            c = s.y,
                                            h = 1 / 0,
                                            d;
                                        n = s;
                                        do {
                                            var f, p;
                                            r >= n.x && n.x >= u && r !== n.x && l0(i < c ? r : a, i, u, c, i < c ? a : r, i, n.x, n.y) && (d = Math.abs(i - n.y) / (r - n.x), l6(n, e) && (d < h || d === h && (n.x > s.x || n.x === s.x && (f = s, p = n, 0 > l1(f.prev, f, p.prev) && 0 > l1(p.next, f, f.next)))) && (s = n, h = d)), n = n.next
                                        } while (n !== l);
                                        return s
                                    }(e, t)) {
                                    let n = l8(t, e);
                                    lJ(t, t.next), lJ(n, n.next)
                                }
                            })(u[i], n), n = lJ(n, n.next);
                            return n
                        }(e, t, d, n)), e.length > 80 * n) {
                        r = a = e[0], i = s = e[1];
                        for (let p = n; p < h; p += n) o = e[p], l = e[p + 1], o < r && (r = o), l < i && (i = l), o > a && (a = o), l > s && (s = l);
                        u = 0 !== (u = Math.max(a - r, s - i)) ? 1 / u : 0
                    }
                    return function e(t, n, r, i, a, s, o) {
                        if (!t) return;
                        !o && s && function(e, t, n, r) {
                            let i = e;
                            do null === i.z && (i.z = lQ(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== e);
                            i.prevZ.nextZ = null, i.prevZ = null,
                                function(e) {
                                    let t, n, r, i, a, s, o, l, u = 1;
                                    do {
                                        for (n = e, e = null, a = null, s = 0; n;) {
                                            for (s++, r = n, o = 0, t = 0; t < u && (o++, r = r.nextZ); t++);
                                            for (l = u; o > 0 || l > 0 && r;) 0 !== o && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, o--) : (i = r, r = r.nextZ, l--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i;
                                            n = r
                                        }
                                        a.nextZ = null, u *= 2
                                    } while (s > 1)
                                }(i)
                        }(t, i, a, s);
                        let l = t,
                            u, c;
                        for (; t.prev !== t.next;) {
                            if (u = t.prev, c = t.next, s ? function(e, t, n, r) {
                                    let i = e.prev,
                                        a = e.next;
                                    if (l1(i, e, a) >= 0) return !1;
                                    let s = i.x < e.x ? i.x < a.x ? i.x : a.x : e.x < a.x ? e.x : a.x,
                                        o = i.y < e.y ? i.y < a.y ? i.y : a.y : e.y < a.y ? e.y : a.y,
                                        l = i.x > e.x ? i.x > a.x ? i.x : a.x : e.x > a.x ? e.x : a.x,
                                        u = i.y > e.y ? i.y > a.y ? i.y : a.y : e.y > a.y ? e.y : a.y,
                                        c = lQ(s, o, t, n, r),
                                        h = lQ(l, u, t, n, r),
                                        d = e.prevZ,
                                        f = e.nextZ;
                                    for (; d && d.z >= c && f && f.z <= h;) {
                                        if (d !== e.prev && d !== e.next && l0(i.x, i.y, e.x, e.y, a.x, a.y, d.x, d.y) && l1(d.prev, d, d.next) >= 0 || (d = d.prevZ, f !== e.prev && f !== e.next && l0(i.x, i.y, e.x, e.y, a.x, a.y, f.x, f.y) && l1(f.prev, f, f.next) >= 0)) return !1;
                                        f = f.nextZ
                                    }
                                    for (; d && d.z >= c;) {
                                        if (d !== e.prev && d !== e.next && l0(i.x, i.y, e.x, e.y, a.x, a.y, d.x, d.y) && l1(d.prev, d, d.next) >= 0) return !1;
                                        d = d.prevZ
                                    }
                                    for (; f && f.z <= h;) {
                                        if (f !== e.prev && f !== e.next && l0(i.x, i.y, e.x, e.y, a.x, a.y, f.x, f.y) && l1(f.prev, f, f.next) >= 0) return !1;
                                        f = f.nextZ
                                    }
                                    return !0
                                }(t, i, a, s) : function(e) {
                                    let t = e.prev,
                                        n = e.next;
                                    if (l1(t, e, n) >= 0) return !1;
                                    let r = e.next.next;
                                    for (; r !== e.prev;) {
                                        if (l0(t.x, t.y, e.x, e.y, n.x, n.y, r.x, r.y) && l1(r.prev, r, r.next) >= 0) return !1;
                                        r = r.next
                                    }
                                    return !0
                                }(t)) {
                                n.push(u.i / r), n.push(t.i / r), n.push(c.i / r), l9(t), t = c.next, l = c.next;
                                continue
                            }
                            if ((t = c) === l) {
                                o ? 1 === o ? e(t = function(e, t, n) {
                                    let r = e;
                                    do {
                                        let i = r.prev,
                                            a = r.next.next;
                                        !l2(i, a) && l3(i, r, r.next, a) && l6(i, a) && l6(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), l9(r), l9(r.next), r = e = a), r = r.next
                                    } while (r !== e);
                                    return lJ(r)
                                }(lJ(t), n, r), n, r, i, a, s, 2) : 2 === o && function(t, n, r, i, a, s) {
                                    let o = t;
                                    do {
                                        let l = o.next.next;
                                        for (; l !== o.prev;) {
                                            var u, c;
                                            if (o.i !== l.i && (u = o, c = l, u.next.i !== c.i && u.prev.i !== c.i && ! function(e, t) {
                                                    let n = e;
                                                    do {
                                                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && l3(n, n.next, e, t)) return !0;
                                                        n = n.next
                                                    } while (n !== e);
                                                    return !1
                                                }(u, c) && (l6(u, c) && l6(c, u) && function(e, t) {
                                                    let n = e,
                                                        r = !1,
                                                        i = (e.x + t.x) / 2,
                                                        a = (e.y + t.y) / 2;
                                                    do n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== e);
                                                    return r
                                                }(u, c) && (l1(u.prev, u, c.prev) || l1(u, c.prev, c)) || l2(u, c) && l1(u.prev, u, u.next) > 0 && l1(c.prev, c, c.next) > 0))) {
                                                let h = l8(o, l);
                                                o = lJ(o, o.next), h = lJ(h, h.next), e(o, n, r, i, a, s), e(h, n, r, i, a, s);
                                                return
                                            }
                                            l = l.next
                                        }
                                        o = o.next
                                    } while (o !== t)
                                }(t, n, r, i, a, s) : e(lJ(t), n, r, i, a, s, 1);
                                break
                            }
                        }
                    }(d, f, n, r, i, u), f
                }
            };

            function l$(e, t, n, r, i) {
                let a, s;
                if (i === function(e, t, n, r) {
                        let i = 0;
                        for (let a = t, s = n - r; a < n; a += r) i += (e[s] - e[a]) * (e[a + 1] + e[s + 1]), s = a;
                        return i
                    }(e, t, n, r) > 0)
                    for (a = t; a < n; a += r) s = l7(a, e[a], e[a + 1], s);
                else
                    for (a = n - r; a >= t; a -= r) s = l7(a, e[a], e[a + 1], s);
                return s && l2(s, s.next) && (l9(s), s = s.next), s
            }

            function lJ(e, t) {
                if (!e) return e;
                t || (t = e);
                let n = e,
                    r;
                do
                    if (r = !1, !n.steiner && (l2(n, n.next) || 0 === l1(n.prev, n, n.next))) {
                        if (l9(n), (n = t = n.prev) === n.next) break;
                        r = !0
                    } else n = n.next; while (r || n !== t);
                return t
            }

            function lK(e, t) {
                return e.x - t.x
            }

            function lQ(e, t, n, r, i) {
                return (e = ((e = ((e = ((e = ((e = 32767 * (e - n) * i) | e << 8) & 16711935) | e << 4) & 252645135) | e << 2) & 858993459) | e << 1) & 1431655765) | (t = ((t = ((t = ((t = ((t = 32767 * (t - r) * i) | t << 8) & 16711935) | t << 4) & 252645135) | t << 2) & 858993459) | t << 1) & 1431655765) << 1
            }

            function l0(e, t, n, r, i, a, s, o) {
                return (i - s) * (t - o) - (e - s) * (a - o) >= 0 && (e - s) * (r - o) - (n - s) * (t - o) >= 0 && (n - s) * (a - o) - (i - s) * (r - o) >= 0
            }

            function l1(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function l2(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function l3(e, t, n, r) {
                let i = l5(l1(e, t, n)),
                    a = l5(l1(e, t, r)),
                    s = l5(l1(n, r, e)),
                    o = l5(l1(n, r, t));
                return !!(i !== a && s !== o || 0 === i && l4(e, n, t) || 0 === a && l4(e, r, t) || 0 === s && l4(n, e, r) || 0 === o && l4(n, t, r))
            }

            function l4(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }

            function l5(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function l6(e, t) {
                return 0 > l1(e.prev, e, e.next) ? l1(e, t, e.next) >= 0 && l1(e, e.prev, t) >= 0 : 0 > l1(e, t, e.prev) || 0 > l1(e, e.next, t)
            }

            function l8(e, t) {
                let n = new ue(e.i, e.x, e.y),
                    r = new ue(t.i, t.x, t.y),
                    i = e.next,
                    a = t.prev;
                return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r
            }

            function l7(e, t, n, r) {
                let i = new ue(e, t, n);
                return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
            }

            function l9(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function ue(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            class ut {
                static area(e) {
                    let t = e.length,
                        n = 0;
                    for (let r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                    return .5 * n
                }
                static isClockWise(e) {
                    return 0 > ut.area(e)
                }
                static triangulateShape(e, t) {
                    let n = [],
                        r = [],
                        i = [];
                    un(e), ur(n, e);
                    let a = e.length;
                    t.forEach(un);
                    for (let s = 0; s < t.length; s++) r.push(a), a += t[s].length, ur(n, t[s]);
                    let o = lY.triangulate(n, r);
                    for (let l = 0; l < o.length; l += 3) i.push(o.slice(l, l + 3));
                    return i
                }
            }

            function un(e) {
                let t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function ur(e, t) {
                for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }
            class ui extends iu {
                constructor(e = new lZ([new np(.5, .5), new np(-.5, .5), new np(-.5, -.5), new np(.5, -.5)]), t = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    }, e = Array.isArray(e) ? e : [e];
                    let n = this,
                        r = [],
                        i = [];
                    for (let a = 0, s = e.length; a < s; a++) {
                        let o = e[a];
                        ! function(e) {
                            let a, s, o, l;
                            let u = [],
                                c = void 0 !== t.curveSegments ? t.curveSegments : 12,
                                h = void 0 !== t.steps ? t.steps : 1,
                                d = void 0 !== t.depth ? t.depth : 1,
                                f = void 0 === t.bevelEnabled || t.bevelEnabled,
                                p = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                                m = void 0 !== t.bevelSize ? t.bevelSize : p - .1,
                                g = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                                v = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                                _ = t.extrudePath,
                                y = void 0 !== t.UVGenerator ? t.UVGenerator : ua,
                                x, b = !1;
                            _ && (x = _.getSpacedPoints(h), b = !0, f = !1, a = _.computeFrenetFrames(h, !1), s = new nj, o = new nj, l = new nj), f || (v = 0, p = 0, m = 0, g = 0);
                            let w = e.extractPoints(c),
                                S = w.shape,
                                M = w.holes,
                                T = !ut.isClockWise(S);
                            if (T) {
                                S = S.reverse();
                                for (let A = 0, E = M.length; A < E; A++) {
                                    let C = M[A];
                                    ut.isClockWise(C) && (M[A] = C.reverse())
                                }
                            }
                            let I = ut.triangulateShape(S, M),
                                P = S;
                            for (let R = 0, L = M.length; R < L; R++) {
                                let D = M[R];
                                S = S.concat(D)
                            }

                            function k(e, t, n) {
                                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                            }
                            let U = S.length,
                                O = I.length;

                            function F(e, t, n) {
                                let r, i, a;
                                let s = e.x - t.x,
                                    o = e.y - t.y,
                                    l = n.x - e.x,
                                    u = n.y - e.y,
                                    c = s * s + o * o;
                                if (Math.abs(s * u - o * l) > Number.EPSILON) {
                                    let h = Math.sqrt(c),
                                        d = Math.sqrt(l * l + u * u),
                                        f = t.x - o / h,
                                        p = t.y + s / h,
                                        m = n.x - u / d,
                                        g = n.y + l / d,
                                        v = ((m - f) * u - (g - p) * l) / (s * u - o * l);
                                    r = f + s * v - e.x, i = p + o * v - e.y;
                                    let _ = r * r + i * i;
                                    if (_ <= 2) return new np(r, i);
                                    a = Math.sqrt(_ / 2)
                                } else {
                                    let y = !1;
                                    s > Number.EPSILON ? l > Number.EPSILON && (y = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(o) === Math.sign(u) && (y = !0), y ? (r = -o, i = s, a = Math.sqrt(c)) : (r = s, i = o, a = Math.sqrt(c / 2))
                                }
                                return new np(r / a, i / a)
                            }
                            let N = [];
                            for (let B = 0, z = P.length, G = z - 1, V = B + 1; B < z; B++, G++, V++) G === z && (G = 0), V === z && (V = 0), N[B] = F(P[B], P[G], P[V]);
                            let W = [],
                                H, j = N.concat();
                            for (let q = 0, X = M.length; q < X; q++) {
                                let Z = M[q];
                                H = [];
                                for (let Y = 0, $ = Z.length, J = $ - 1, K = Y + 1; Y < $; Y++, J++, K++) J === $ && (J = 0), K === $ && (K = 0), H[Y] = F(Z[Y], Z[J], Z[K]);
                                W.push(H), j = j.concat(H)
                            }
                            for (let Q = 0; Q < v; Q++) {
                                let ee = Q / v,
                                    et = p * Math.cos(ee * Math.PI / 2),
                                    en = m * Math.sin(ee * Math.PI / 2) + g;
                                for (let er = 0, ei = P.length; er < ei; er++) {
                                    let ea = k(P[er], N[er], en);
                                    eL(ea.x, ea.y, -et)
                                }
                                for (let es = 0, eo = M.length; es < eo; es++) {
                                    let el = M[es];
                                    H = W[es];
                                    for (let eu = 0, ec = el.length; eu < ec; eu++) {
                                        let eh = k(el[eu], H[eu], en);
                                        eL(eh.x, eh.y, -et)
                                    }
                                }
                            }
                            let ed = m + g;
                            for (let ef = 0; ef < U; ef++) {
                                let ep = f ? k(S[ef], j[ef], ed) : S[ef];
                                b ? (o.copy(a.normals[0]).multiplyScalar(ep.x), s.copy(a.binormals[0]).multiplyScalar(ep.y), l.copy(x[0]).add(o).add(s), eL(l.x, l.y, l.z)) : eL(ep.x, ep.y, 0)
                            }
                            for (let em = 1; em <= h; em++)
                                for (let eg = 0; eg < U; eg++) {
                                    let ev = f ? k(S[eg], j[eg], ed) : S[eg];
                                    b ? (o.copy(a.normals[em]).multiplyScalar(ev.x), s.copy(a.binormals[em]).multiplyScalar(ev.y), l.copy(x[em]).add(o).add(s), eL(l.x, l.y, l.z)) : eL(ev.x, ev.y, d / h * em)
                                }
                            for (let e_ = v - 1; e_ >= 0; e_--) {
                                let ey = e_ / v,
                                    ex = p * Math.cos(ey * Math.PI / 2),
                                    eb = m * Math.sin(ey * Math.PI / 2) + g;
                                for (let ew = 0, eS = P.length; ew < eS; ew++) {
                                    let eM = k(P[ew], N[ew], eb);
                                    eL(eM.x, eM.y, d + ex)
                                }
                                for (let eT = 0, eA = M.length; eT < eA; eT++) {
                                    let eE = M[eT];
                                    H = W[eT];
                                    for (let eC = 0, eI = eE.length; eC < eI; eC++) {
                                        let eP = k(eE[eC], H[eC], eb);
                                        b ? eL(eP.x, eP.y + x[h - 1].y, x[h - 1].x + ex) : eL(eP.x, eP.y, d + ex)
                                    }
                                }
                            }

                            function eR(e, t) {
                                let i = e.length;
                                for (; --i >= 0;) {
                                    let a = i,
                                        s = i - 1;
                                    s < 0 && (s = e.length - 1);
                                    for (let o = 0, l = h + 2 * v; o < l; o++) {
                                        let u = U * o,
                                            c = U * (o + 1),
                                            d = t + a + u,
                                            f = t + s + u,
                                            p = t + s + c,
                                            m = t + a + c;
                                        ! function(e, t, i, a) {
                                            ek(e), ek(t), ek(a), ek(t), ek(i), ek(a);
                                            let s = r.length / 3,
                                                o = y.generateSideWallUV(n, r, s - 6, s - 3, s - 2, s - 1);
                                            eU(o[0]), eU(o[1]), eU(o[3]), eU(o[1]), eU(o[2]), eU(o[3])
                                        }(d, f, p, m)
                                    }
                                }
                            }

                            function eL(e, t, n) {
                                u.push(e), u.push(t), u.push(n)
                            }

                            function eD(e, t, i) {
                                ek(e), ek(t), ek(i);
                                let a = r.length / 3,
                                    s = y.generateTopUV(n, r, a - 3, a - 2, a - 1);
                                eU(s[0]), eU(s[1]), eU(s[2])
                            }

                            function ek(e) {
                                r.push(u[3 * e + 0]), r.push(u[3 * e + 1]), r.push(u[3 * e + 2])
                            }

                            function eU(e) {
                                i.push(e.x), i.push(e.y)
                            }(function() {
                                let e = r.length / 3;
                                if (f) {
                                    let t = 0 * U;
                                    for (let i = 0; i < O; i++) {
                                        let a = I[i];
                                        eD(a[2] + t, a[1] + t, a[0] + t)
                                    }
                                    t = U * (h + 2 * v);
                                    for (let s = 0; s < O; s++) {
                                        let o = I[s];
                                        eD(o[0] + t, o[1] + t, o[2] + t)
                                    }
                                } else {
                                    for (let l = 0; l < O; l++) {
                                        let u = I[l];
                                        eD(u[2], u[1], u[0])
                                    }
                                    for (let c = 0; c < O; c++) {
                                        let d = I[c];
                                        eD(d[0] + U * h, d[1] + U * h, d[2] + U * h)
                                    }
                                }
                                n.addGroup(e, r.length / 3 - e, 0)
                            })(),
                            function() {
                                let e = r.length / 3,
                                    t = 0;
                                eR(P, 0), t += P.length;
                                for (let i = 0, a = M.length; i < a; i++) {
                                    let s = M[i];
                                    eR(s, t), t += s.length
                                }
                                n.addGroup(e, r.length / 3 - e, 1)
                            }()
                        }(o)
                    }
                    this.setAttribute("position", new r9(r, 3)), this.setAttribute("uv", new r9(i, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    let e = super.toJSON(),
                        t = this.parameters.shapes,
                        n = this.parameters.options;
                    return function(e, t, n) {
                        if (n.shapes = [], Array.isArray(e))
                            for (let r = 0, i = e.length; r < i; r++) {
                                let a = e[r];
                                n.shapes.push(a.uuid)
                            } else n.shapes.push(e.uuid);
                        return n.options = Object.assign({}, t), void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
                    }(t, n, e)
                }
                static fromJSON(e, t) {
                    let n = [];
                    for (let r = 0, i = e.shapes.length; r < i; r++) {
                        let a = t[e.shapes[r]];
                        n.push(a)
                    }
                    let s = e.options.extrudePath;
                    return void 0 !== s && (e.options.extrudePath = new lD[s.type]().fromJSON(s)), new ui(n, e.options)
                }
            }
            let ua = {
                generateTopUV: function(e, t, n, r, i) {
                    let a = t[3 * n],
                        s = t[3 * n + 1],
                        o = t[3 * r],
                        l = t[3 * r + 1],
                        u = t[3 * i],
                        c = t[3 * i + 1];
                    return [new np(a, s), new np(o, l), new np(u, c)]
                },
                generateSideWallUV: function(e, t, n, r, i, a) {
                    let s = t[3 * n],
                        o = t[3 * n + 1],
                        l = t[3 * n + 2],
                        u = t[3 * r],
                        c = t[3 * r + 1],
                        h = t[3 * r + 2],
                        d = t[3 * i],
                        f = t[3 * i + 1],
                        p = t[3 * i + 2],
                        m = t[3 * a],
                        g = t[3 * a + 1],
                        v = t[3 * a + 2];
                    return Math.abs(o - c) < Math.abs(s - u) ? [new np(s, 1 - l), new np(u, 1 - h), new np(d, 1 - p), new np(m, 1 - v)] : [new np(o, 1 - l), new np(c, 1 - h), new np(f, 1 - p), new np(g, 1 - v)]
                }
            };
            class us extends lG {
                constructor(e = 1, t = 0) {
                    let n = (1 + Math.sqrt(5)) / 2;
                    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new us(e.radius, e.detail)
                }
            }
            class uo extends lG {
                constructor(e = 1, t = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new uo(e.radius, e.detail)
                }
            }
            class ul extends iu {
                constructor(e = .5, t = 1, n = 8, r = 1, i = 0, a = 2 * Math.PI) {
                    super(), this.type = "RingGeometry", this.parameters = {
                        innerRadius: e,
                        outerRadius: t,
                        thetaSegments: n,
                        phiSegments: r,
                        thetaStart: i,
                        thetaLength: a
                    }, n = Math.max(3, n), r = Math.max(1, r);
                    let s = [],
                        o = [],
                        l = [],
                        u = [],
                        c = e,
                        h = (t - e) / r,
                        d = new nj,
                        f = new np;
                    for (let p = 0; p <= r; p++) {
                        for (let m = 0; m <= n; m++) {
                            let g = i + m / n * a;
                            d.x = c * Math.cos(g), d.y = c * Math.sin(g), o.push(d.x, d.y, d.z), l.push(0, 0, 1), f.x = (d.x / t + 1) / 2, f.y = (d.y / t + 1) / 2, u.push(f.x, f.y)
                        }
                        c += h
                    }
                    for (let v = 0; v < r; v++) {
                        let _ = v * (n + 1);
                        for (let y = 0; y < n; y++) {
                            let x = y + _,
                                b = x + n + 1,
                                w = x + n + 2,
                                S = x + 1;
                            s.push(x, b, S), s.push(b, w, S)
                        }
                    }
                    this.setIndex(s), this.setAttribute("position", new r9(o, 3)), this.setAttribute("normal", new r9(l, 3)), this.setAttribute("uv", new r9(u, 2))
                }
                static fromJSON(e) {
                    return new ul(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
                }
            }
            class uu extends iu {
                constructor(e = new lZ([new np(0, .5), new np(-.5, -.5), new np(.5, -.5)]), t = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    let n = [],
                        r = [],
                        i = [],
                        a = [],
                        s = 0,
                        o = 0;
                    if (!1 === Array.isArray(e)) u(e);
                    else
                        for (let l = 0; l < e.length; l++) u(e[l]), this.addGroup(s, o, l), s += o, o = 0;

                    function u(e) {
                        let s = r.length / 3,
                            l = e.extractPoints(t),
                            u = l.shape,
                            c = l.holes;
                        !1 === ut.isClockWise(u) && (u = u.reverse());
                        for (let h = 0, d = c.length; h < d; h++) {
                            let f = c[h];
                            !0 === ut.isClockWise(f) && (c[h] = f.reverse())
                        }
                        let p = ut.triangulateShape(u, c);
                        for (let m = 0, g = c.length; m < g; m++) {
                            let v = c[m];
                            u = u.concat(v)
                        }
                        for (let _ = 0, y = u.length; _ < y; _++) {
                            let x = u[_];
                            r.push(x.x, x.y, 0), i.push(0, 0, 1), a.push(x.x, x.y)
                        }
                        for (let b = 0, w = p.length; b < w; b++) {
                            let S = p[b],
                                M = S[0] + s,
                                T = S[1] + s,
                                A = S[2] + s;
                            n.push(M, T, A), o += 3
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new r9(r, 3)), this.setAttribute("normal", new r9(i, 3)), this.setAttribute("uv", new r9(a, 2))
                }
                toJSON() {
                    let e = super.toJSON(),
                        t = this.parameters.shapes;
                    return function(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let n = 0, r = e.length; n < r; n++) {
                                let i = e[n];
                                t.shapes.push(i.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(t, e)
                }
                static fromJSON(e, t) {
                    let n = [];
                    for (let r = 0, i = e.shapes.length; r < i; r++) {
                        let a = t[e.shapes[r]];
                        n.push(a)
                    }
                    return new uu(n, e.curveSegments)
                }
            }
            class uc extends iu {
                constructor(e = 1, t = 32, n = 16, r = 0, i = 2 * Math.PI, a = 0, s = Math.PI) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: r,
                        phiLength: i,
                        thetaStart: a,
                        thetaLength: s
                    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                    let o = Math.min(a + s, Math.PI),
                        l = 0,
                        u = [],
                        c = new nj,
                        h = new nj,
                        d = [],
                        f = [],
                        p = [],
                        m = [];
                    for (let g = 0; g <= n; g++) {
                        let v = [],
                            _ = g / n,
                            y = 0;
                        0 == g && 0 == a ? y = .5 / t : g == n && o == Math.PI && (y = -.5 / t);
                        for (let x = 0; x <= t; x++) {
                            let b = x / t;
                            c.x = -e * Math.cos(r + b * i) * Math.sin(a + _ * s), c.y = e * Math.cos(a + _ * s), c.z = e * Math.sin(r + b * i) * Math.sin(a + _ * s), f.push(c.x, c.y, c.z), h.copy(c).normalize(), p.push(h.x, h.y, h.z), m.push(b + y, 1 - _), v.push(l++)
                        }
                        u.push(v)
                    }
                    for (let w = 0; w < n; w++)
                        for (let S = 0; S < t; S++) {
                            let M = u[w][S + 1],
                                T = u[w][S],
                                A = u[w + 1][S],
                                E = u[w + 1][S + 1];
                            (0 !== w || a > 0) && d.push(M, T, E), (w !== n - 1 || o < Math.PI) && d.push(T, A, E)
                        }
                    this.setIndex(d), this.setAttribute("position", new r9(f, 3)), this.setAttribute("normal", new r9(p, 3)), this.setAttribute("uv", new r9(m, 2))
                }
                static fromJSON(e) {
                    return new uc(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
                }
            }
            class uh extends lG {
                constructor(e = 1, t = 0) {
                    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new uh(e.radius, e.detail)
                }
            }
            class ud extends iu {
                constructor(e = 1, t = .4, n = 8, r = 6, i = 2 * Math.PI) {
                    super(), this.type = "TorusGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        radialSegments: n,
                        tubularSegments: r,
                        arc: i
                    }, n = Math.floor(n), r = Math.floor(r);
                    let a = [],
                        s = [],
                        o = [],
                        l = [],
                        u = new nj,
                        c = new nj,
                        h = new nj;
                    for (let d = 0; d <= n; d++)
                        for (let f = 0; f <= r; f++) {
                            let p = f / r * i,
                                m = d / n * Math.PI * 2;
                            c.x = (e + t * Math.cos(m)) * Math.cos(p), c.y = (e + t * Math.cos(m)) * Math.sin(p), c.z = t * Math.sin(m), s.push(c.x, c.y, c.z), u.x = e * Math.cos(p), u.y = e * Math.sin(p), h.subVectors(c, u).normalize(), o.push(h.x, h.y, h.z), l.push(f / r), l.push(d / n)
                        }
                    for (let g = 1; g <= n; g++)
                        for (let v = 1; v <= r; v++) {
                            let _ = (r + 1) * g + v - 1,
                                y = (r + 1) * (g - 1) + v - 1,
                                x = (r + 1) * (g - 1) + v,
                                b = (r + 1) * g + v;
                            a.push(_, y, b), a.push(y, x, b)
                        }
                    this.setIndex(a), this.setAttribute("position", new r9(s, 3)), this.setAttribute("normal", new r9(o, 3)), this.setAttribute("uv", new r9(l, 2))
                }
                static fromJSON(e) {
                    return new ud(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
                }
            }
            class uf extends iu {
                constructor(e = 1, t = .4, n = 64, r = 8, i = 2, a = 3) {
                    super(), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        tubularSegments: n,
                        radialSegments: r,
                        p: i,
                        q: a
                    }, n = Math.floor(n), r = Math.floor(r);
                    let s = [],
                        o = [],
                        l = [],
                        u = [],
                        c = new nj,
                        h = new nj,
                        d = new nj,
                        f = new nj,
                        p = new nj,
                        m = new nj,
                        g = new nj;
                    for (let v = 0; v <= n; ++v) {
                        let _ = v / n * i * Math.PI * 2;
                        I(_, i, a, e, d), I(_ + .01, i, a, e, f), m.subVectors(f, d), g.addVectors(f, d), p.crossVectors(m, g), g.crossVectors(p, m), p.normalize(), g.normalize();
                        for (let y = 0; y <= r; ++y) {
                            let x = y / r * Math.PI * 2,
                                b = -t * Math.cos(x),
                                w = t * Math.sin(x);
                            c.x = d.x + (b * g.x + w * p.x), c.y = d.y + (b * g.y + w * p.y), c.z = d.z + (b * g.z + w * p.z), o.push(c.x, c.y, c.z), h.subVectors(c, d).normalize(), l.push(h.x, h.y, h.z), u.push(v / n), u.push(y / r)
                        }
                    }
                    for (let S = 1; S <= n; S++)
                        for (let M = 1; M <= r; M++) {
                            let T = (r + 1) * (S - 1) + (M - 1),
                                A = (r + 1) * S + (M - 1),
                                E = (r + 1) * S + M,
                                C = (r + 1) * (S - 1) + M;
                            s.push(T, A, C), s.push(A, E, C)
                        }

                    function I(e, t, n, r, i) {
                        let a = n / t * e,
                            s = Math.cos(a);
                        i.x = r * (2 + s) * .5 * Math.cos(e), i.y = r * (2 + s) * Math.sin(e) * .5, i.z = r * Math.sin(a) * .5
                    }
                    this.setIndex(s), this.setAttribute("position", new r9(o, 3)), this.setAttribute("normal", new r9(l, 3)), this.setAttribute("uv", new r9(u, 2))
                }
                static fromJSON(e) {
                    return new uf(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
                }
            }
            class up extends iu {
                constructor(e = new lR(new nj(-1, -1, 0), new nj(-1, 1, 0), new nj(1, 1, 0)), t = 64, n = 1, r = 8, i = !1) {
                    super(), this.type = "TubeGeometry", this.parameters = {
                        path: e,
                        tubularSegments: t,
                        radius: n,
                        radialSegments: r,
                        closed: i
                    };
                    let a = e.computeFrenetFrames(t, i);
                    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
                    let s = new nj,
                        o = new nj,
                        l = new np,
                        u = new nj,
                        c = [],
                        h = [],
                        d = [],
                        f = [];

                    function p(i) {
                        u = e.getPointAt(i / t, u);
                        let l = a.normals[i],
                            d = a.binormals[i];
                        for (let f = 0; f <= r; f++) {
                            let p = f / r * Math.PI * 2,
                                m = Math.sin(p),
                                g = -Math.cos(p);
                            o.x = g * l.x + m * d.x, o.y = g * l.y + m * d.y, o.z = g * l.z + m * d.z, o.normalize(), h.push(o.x, o.y, o.z), s.x = u.x + n * o.x, s.y = u.y + n * o.y, s.z = u.z + n * o.z, c.push(s.x, s.y, s.z)
                        }
                    }(function() {
                        for (let e = 0; e < t; e++) p(e);
                        p(!1 === i ? t : 0),
                            function() {
                                for (let e = 0; e <= t; e++)
                                    for (let n = 0; n <= r; n++) l.x = e / t, l.y = n / r, d.push(l.x, l.y)
                            }(),
                            function() {
                                for (let e = 1; e <= t; e++)
                                    for (let n = 1; n <= r; n++) {
                                        let i = (r + 1) * (e - 1) + (n - 1),
                                            a = (r + 1) * e + (n - 1),
                                            s = (r + 1) * e + n,
                                            o = (r + 1) * (e - 1) + n;
                                        f.push(i, a, o), f.push(a, s, o)
                                    }
                            }()
                    })(), this.setIndex(f), this.setAttribute("position", new r9(c, 3)), this.setAttribute("normal", new r9(h, 3)), this.setAttribute("uv", new r9(d, 2))
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.path = this.parameters.path.toJSON(), e
                }
                static fromJSON(e) {
                    return new up(new lD[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
                }
            }
            class um extends iu {
                constructor(e = null) {
                    if (super(), this.type = "WireframeGeometry", this.parameters = {
                            geometry: e
                        }, null !== e) {
                        let t = [],
                            n = new Set,
                            r = new nj,
                            i = new nj;
                        if (null !== e.index) {
                            let a = e.attributes.position,
                                s = e.index,
                                o = e.groups;
                            0 === o.length && (o = [{
                                start: 0,
                                count: s.count,
                                materialIndex: 0
                            }]);
                            for (let l = 0, u = o.length; l < u; ++l) {
                                let c = o[l],
                                    h = c.start,
                                    d = c.count;
                                for (let f = h, p = h + d; f < p; f += 3)
                                    for (let m = 0; m < 3; m++) {
                                        let g = s.getX(f + m),
                                            v = s.getX(f + (m + 1) % 3);
                                        r.fromBufferAttribute(a, g), i.fromBufferAttribute(a, v), !0 === ug(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                                    }
                            }
                        } else {
                            let _ = e.attributes.position;
                            for (let y = 0, x = _.count / 3; y < x; y++)
                                for (let b = 0; b < 3; b++) {
                                    let w = 3 * y + b,
                                        S = 3 * y + (b + 1) % 3;
                                    r.fromBufferAttribute(_, w), i.fromBufferAttribute(_, S), !0 === ug(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                                }
                        }
                        this.setAttribute("position", new r9(t, 3))
                    }
                }
            }

            function ug(e, t, n) {
                let r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
                    i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
                return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0)
            }
            var uv = Object.freeze({
                __proto__: null,
                BoxGeometry: iP,
                CapsuleGeometry: lF,
                CircleGeometry: lN,
                ConeGeometry: lz,
                CylinderGeometry: lB,
                DodecahedronGeometry: lV,
                EdgesGeometry: lX,
                ExtrudeGeometry: ui,
                IcosahedronGeometry: us,
                LatheGeometry: lO,
                OctahedronGeometry: uo,
                PlaneGeometry: i$,
                PolyhedronGeometry: lG,
                RingGeometry: ul,
                ShapeGeometry: uu,
                SphereGeometry: uc,
                TetrahedronGeometry: uh,
                TorusGeometry: ud,
                TorusKnotGeometry: uf,
                TubeGeometry: up,
                WireframeGeometry: um
            });
            class u_ extends r$ {
                constructor(e) {
                    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new nR(0), this.transparent = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
                }
            }
            class uy extends iU {
                constructor(e) {
                    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
                }
            }
            class ux extends r$ {
                constructor(e) {
                    super(), this.isMeshStandardMaterial = !0, this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new nR(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tI, this.normalScale = new np(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class ub extends ux {
                constructor(e) {
                    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new np(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return ni(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new nR(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new nR(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new nR(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e)
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                }
                get iridescence() {
                    return this._iridescence
                }
                set iridescence(e) {
                    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                }
            }
            class uw extends r$ {
                constructor(e) {
                    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new nR(16777215), this.specular = new nR(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tI, this.normalScale = new np(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = K, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class uS extends r$ {
                constructor(e) {
                    super(), this.isMeshToonMaterial = !0, this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new nR(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tI, this.normalScale = new np(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            class uM extends r$ {
                constructor(e) {
                    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tI, this.normalScale = new np(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                }
            }
            class uT extends r$ {
                constructor(e) {
                    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new nR(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tI, this.normalScale = new np(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = K, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class uA extends r$ {
                constructor(e) {
                    super(), this.isMeshMatcapMaterial = !0, this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new nR(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tI, this.normalScale = new np(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class uE extends o1 {
                constructor(e) {
                    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
                }
            }

            function uC(e, t, n) {
                return uP(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
            }

            function uI(e, t, n) {
                return e && (n || e.constructor !== t) ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e
            }

            function uP(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            }

            function uR(e) {
                let t = e.length,
                    n = Array(t);
                for (let r = 0; r !== t; ++r) n[r] = r;
                return n.sort(function(t, n) {
                    return e[t] - e[n]
                }), n
            }

            function uL(e, t, n) {
                let r = e.length,
                    i = new e.constructor(r);
                for (let a = 0, s = 0; s !== r; ++a) {
                    let o = n[a] * t;
                    for (let l = 0; l !== t; ++l) i[s++] = e[o + l]
                }
                return i
            }

            function uD(e, t, n, r) {
                let i = 1,
                    a = e[0];
                for (; void 0 !== a && void 0 === a[r];) a = e[i++];
                if (void 0 === a) return;
                let s = a[r];
                if (void 0 !== s) {
                    if (Array.isArray(s))
                        do void 0 !== (s = a[r]) && (t.push(a.time), n.push.apply(n, s)), a = e[i++]; while (void 0 !== a);
                    else if (void 0 !== s.toArray)
                        do void 0 !== (s = a[r]) && (t.push(a.time), s.toArray(n, n.length)), a = e[i++]; while (void 0 !== a);
                    else
                        do void 0 !== (s = a[r]) && (t.push(a.time), n.push(s)), a = e[i++]; while (void 0 !== a)
                }
            }
            var uk = Object.freeze({
                __proto__: null,
                arraySlice: uC,
                convertArray: uI,
                isTypedArray: uP,
                getKeyframeOrder: uR,
                sortedArray: uL,
                flattenJSON: uD,
                subclip: function(e, t, n, r, i = 30) {
                    let a = e.clone();
                    a.name = t;
                    let s = [];
                    for (let o = 0; o < a.tracks.length; ++o) {
                        let l = a.tracks[o],
                            u = l.getValueSize(),
                            c = [],
                            h = [];
                        for (let d = 0; d < l.times.length; ++d) {
                            let f = l.times[d] * i;
                            if (!(f < n) && !(f >= r)) {
                                c.push(l.times[d]);
                                for (let p = 0; p < u; ++p) h.push(l.values[d * u + p])
                            }
                        }
                        0 !== c.length && (l.times = uI(c, l.times.constructor), l.values = uI(h, l.values.constructor), s.push(l))
                    }
                    a.tracks = s;
                    let m = 1 / 0;
                    for (let g = 0; g < a.tracks.length; ++g) m > a.tracks[g].times[0] && (m = a.tracks[g].times[0]);
                    for (let v = 0; v < a.tracks.length; ++v) a.tracks[v].shift(-1 * m);
                    return a.resetDuration(), a
                },
                makeClipAdditive: function(e, t = 0, n = e, r = 30) {
                    r <= 0 && (r = 30);
                    let i = n.tracks.length,
                        a = t / r;
                    for (let s = 0; s < i; ++s) {
                        let o;
                        let l = n.tracks[s],
                            u = l.ValueTypeName;
                        if ("bool" === u || "string" === u) continue;
                        let c = e.tracks.find(function(e) {
                            return e.name === l.name && e.ValueTypeName === u
                        });
                        if (void 0 === c) continue;
                        let h = 0,
                            d = l.getValueSize();
                        l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
                        let f = 0,
                            p = c.getValueSize();
                        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = p / 3);
                        let m = l.times.length - 1;
                        if (a <= l.times[0]) {
                            let g = h,
                                v = d - h;
                            o = uC(l.values, g, v)
                        } else if (a >= l.times[m]) {
                            let _ = m * d + h,
                                y = _ + d - h;
                            o = uC(l.values, _, y)
                        } else {
                            let x = l.createInterpolant(),
                                b = h,
                                w = d - h;
                            x.evaluate(a), o = uC(x.resultBuffer, b, w)
                        }
                        if ("quaternion" === u) {
                            let S = new nH().fromArray(o).normalize().conjugate();
                            S.toArray(o)
                        }
                        let M = c.times.length;
                        for (let T = 0; T < M; ++T) {
                            let A = T * p + f;
                            if ("quaternion" === u) nH.multiplyQuaternionsFlat(c.values, A, o, 0, c.values, A);
                            else {
                                let E = p - 2 * f;
                                for (let C = 0; C < E; ++C) c.values[A + C] -= o[C]
                            }
                        }
                    }
                    return e.blendMode = tb, e
                }
            });
            class uU {
                constructor(e, t, n, r) {
                    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    let t = this.parameterPositions,
                        n = this._cachedIndex,
                        r = t[n],
                        i = t[n - 1];
                    n: {
                        r: {
                            let a;i: {
                                a: if (!(e < r)) {
                                    for (let s = n + 2;;) {
                                        if (void 0 === r) {
                                            if (e < i) break a;
                                            return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                        }
                                        if (n === s) break;
                                        if (i = r, e < (r = t[++n])) break r
                                    }
                                    a = t.length;
                                    break i
                                }if (!(e >= i)) {
                                    let o = t[1];
                                    e < o && (n = 2, i = o);
                                    for (let l = n - 2;;) {
                                        if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                                        if (n === l) break;
                                        if (r = i, e >= (i = t[--n - 1])) break r
                                    }
                                    a = n, n = 0;
                                    break i
                                }
                                break n
                            }
                            for (; n < a;) {
                                let u = n + a >>> 1;
                                e < t[u] ? a = u : n = u + 1
                            }
                            if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (void 0 === r) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, e, r)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    let t = this.resultBuffer,
                        n = this.sampleValues,
                        r = this.valueSize,
                        i = e * r;
                    for (let a = 0; a !== r; ++a) t[a] = n[i + a];
                    return t
                }
                interpolate_() {
                    throw Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class uO extends uU {
                constructor(e, t, n, r) {
                    super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: tv,
                        endingEnd: tv
                    }
                }
                intervalChanged_(e, t, n) {
                    let r = this.parameterPositions,
                        i = e - 2,
                        a = e + 1,
                        s = r[i],
                        o = r[a];
                    if (void 0 === s) switch (this.getSettings_().endingStart) {
                        case t_:
                            i = e, s = 2 * t - n;
                            break;
                        case ty:
                            i = r.length - 2, s = t + r[i] - r[i + 1];
                            break;
                        default:
                            i = e, s = n
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                        case t_:
                            a = e, o = 2 * n - t;
                            break;
                        case ty:
                            a = 1, o = n + r[1] - r[0];
                            break;
                        default:
                            a = e - 1, o = t
                    }
                    let l = (n - t) * .5,
                        u = this.valueSize;
                    this._weightPrev = l / (t - s), this._weightNext = l / (o - n), this._offsetPrev = i * u, this._offsetNext = a * u
                }
                interpolate_(e, t, n, r) {
                    let i = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = e * s,
                        l = o - s,
                        u = this._offsetPrev,
                        c = this._offsetNext,
                        h = this._weightPrev,
                        d = this._weightNext,
                        f = (n - t) / (r - t),
                        p = f * f,
                        m = p * f,
                        g = -h * m + 2 * h * p - h * f,
                        v = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1,
                        _ = (-1 - d) * m + (1.5 + d) * p + .5 * f,
                        y = d * m - d * p;
                    for (let x = 0; x !== s; ++x) i[x] = g * a[u + x] + v * a[l + x] + _ * a[o + x] + y * a[c + x];
                    return i
                }
            }
            class uF extends uU {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    let i = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = e * s,
                        l = o - s,
                        u = (n - t) / (r - t),
                        c = 1 - u;
                    for (let h = 0; h !== s; ++h) i[h] = a[l + h] * c + a[o + h] * u;
                    return i
                }
            }
            class uN extends uU {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class uB {
                constructor(e, t, n, r) {
                    if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e, this.times = uI(t, this.TimeBufferType), this.values = uI(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    let t;
                    let n = e.constructor;
                    if (n.toJSON !== this.toJSON) t = n.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: uI(e.times, Array),
                            values: uI(e.values, Array)
                        };
                        let r = e.getInterpolation();
                        r !== e.DefaultInterpolation && (t.interpolation = r)
                    }
                    return t.type = e.ValueTypeName, t
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new uN(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new uF(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new uO(this.times, this.values, this.getValueSize(), e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                        case tp:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case tm:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case tg:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        let n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                            else throw Error(n)
                        }
                        return console.warn("THREE.KeyframeTrack:", n), this
                    }
                    return this.createInterpolant = t, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return tp;
                        case this.InterpolantFactoryMethodLinear:
                            return tm;
                        case this.InterpolantFactoryMethodSmooth:
                            return tg
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        let t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n) t[n] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        let t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e
                    }
                    return this
                }
                trim(e, t) {
                    let n = this.times,
                        r = n.length,
                        i = 0,
                        a = r - 1;
                    for (; i !== r && n[i] < e;) ++i;
                    for (; - 1 !== a && n[a] > t;) --a;
                    if (++a, 0 !== i || a !== r) {
                        i >= a && (i = (a = Math.max(a, 1)) - 1);
                        let s = this.getValueSize();
                        this.times = uC(n, i, a), this.values = uC(this.values, i * s, a * s)
                    }
                    return this
                }
                validate() {
                    let e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    let n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    let a = null;
                    for (let s = 0; s !== i; s++) {
                        let o = n[s];
                        if ("number" == typeof o && isNaN(o)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, o), e = !1;
                            break
                        }
                        if (null !== a && a > o) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, s, o, a), e = !1;
                            break
                        }
                        a = o
                    }
                    if (void 0 !== r && uP(r))
                        for (let l = 0, u = r.length; l !== u; ++l) {
                            let c = r[l];
                            if (isNaN(c)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, c), e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    let e = uC(this.times),
                        t = uC(this.values),
                        n = this.getValueSize(),
                        r = this.getInterpolation() === tg,
                        i = e.length - 1,
                        a = 1;
                    for (let s = 1; s < i; ++s) {
                        let o = !1,
                            l = e[s],
                            u = e[s + 1];
                        if (l !== u && (1 !== s || l !== e[0])) {
                            if (r) o = !0;
                            else {
                                let c = s * n,
                                    h = c - n,
                                    d = c + n;
                                for (let f = 0; f !== n; ++f) {
                                    let p = t[c + f];
                                    if (p !== t[h + f] || p !== t[d + f]) {
                                        o = !0;
                                        break
                                    }
                                }
                            }
                        }
                        if (o) {
                            if (s !== a) {
                                e[a] = e[s];
                                let m = s * n,
                                    g = a * n;
                                for (let v = 0; v !== n; ++v) t[g + v] = t[m + v]
                            }++a
                        }
                    }
                    if (i > 0) {
                        e[a] = e[i];
                        for (let _ = i * n, y = a * n, x = 0; x !== n; ++x) t[y + x] = t[_ + x];
                        ++a
                    }
                    return a !== e.length ? (this.times = uC(e, 0, a), this.values = uC(t, 0, a * n)) : (this.times = e, this.values = t), this
                }
                clone() {
                    let e = uC(this.times, 0),
                        t = uC(this.values, 0),
                        n = this.constructor,
                        r = new n(this.name, e, t);
                    return r.createInterpolant = this.createInterpolant, r
                }
            }
            uB.prototype.TimeBufferType = Float32Array, uB.prototype.ValueBufferType = Float32Array, uB.prototype.DefaultInterpolation = tm;
            class uz extends uB {}
            uz.prototype.ValueTypeName = "bool", uz.prototype.ValueBufferType = Array, uz.prototype.DefaultInterpolation = tp, uz.prototype.InterpolantFactoryMethodLinear = void 0, uz.prototype.InterpolantFactoryMethodSmooth = void 0;
            class uG extends uB {}
            uG.prototype.ValueTypeName = "color";
            class uV extends uB {}
            uV.prototype.ValueTypeName = "number";
            class uW extends uU {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    let i = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = (n - t) / (r - t),
                        l = e * s;
                    for (let u = l + s; l !== u; l += 4) nH.slerpFlat(i, 0, a, l - s, a, l, o);
                    return i
                }
            }
            class uH extends uB {
                InterpolantFactoryMethodLinear(e) {
                    return new uW(this.times, this.values, this.getValueSize(), e)
                }
            }
            uH.prototype.ValueTypeName = "quaternion", uH.prototype.DefaultInterpolation = tm, uH.prototype.InterpolantFactoryMethodSmooth = void 0;
            class uj extends uB {}
            uj.prototype.ValueTypeName = "string", uj.prototype.ValueBufferType = Array, uj.prototype.DefaultInterpolation = tp, uj.prototype.InterpolantFactoryMethodLinear = void 0, uj.prototype.InterpolantFactoryMethodSmooth = void 0;
            class uq extends uB {}
            uq.prototype.ValueTypeName = "vector";
            class uX {
                constructor(e, t = -1, n, r = tx) {
                    this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = nr(), this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    let t = [],
                        n = e.tracks,
                        r = 1 / (e.fps || 1);
                    for (let i = 0, a = n.length; i !== a; ++i) t.push((function(e) {
                        if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        let t = function(e) {
                            switch (e.toLowerCase()) {
                                case "scalar":
                                case "double":
                                case "float":
                                case "number":
                                case "integer":
                                    return uV;
                                case "vector":
                                case "vector2":
                                case "vector3":
                                case "vector4":
                                    return uq;
                                case "color":
                                    return uG;
                                case "quaternion":
                                    return uH;
                                case "bool":
                                case "boolean":
                                    return uz;
                                case "string":
                                    return uj
                            }
                            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                        }(e.type);
                        if (void 0 === e.times) {
                            let n = [],
                                r = [];
                            uD(e.keys, n, r, "value"), e.times = n, e.values = r
                        }
                        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
                    })(n[i]).scale(r));
                    let s = new this(e.name, e.duration, t, e.blendMode);
                    return s.uuid = e.uuid, s
                }
                static toJSON(e) {
                    let t = [],
                        n = e.tracks,
                        r = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let i = 0, a = n.length; i !== a; ++i) t.push(uB.toJSON(n[i]));
                    return r
                }
                static CreateFromMorphTargetSequence(e, t, n, r) {
                    let i = t.length,
                        a = [];
                    for (let s = 0; s < i; s++) {
                        let o = [],
                            l = [];
                        o.push((s + i - 1) % i, s, (s + 1) % i), l.push(0, 1, 0);
                        let u = uR(o);
                        o = uL(o, 1, u), l = uL(l, 1, u), r || 0 !== o[0] || (o.push(i), l.push(l[0])), a.push(new uV(".morphTargetInfluences[" + t[s].name + "]", o, l).scale(1 / n))
                    }
                    return new this(e, -1, a)
                }
                static findByName(e, t) {
                    let n = e;
                    Array.isArray(e) || (n = e.geometry && e.geometry.animations || e.animations);
                    for (let r = 0; r < n.length; r++)
                        if (n[r].name === t) return n[r];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, n) {
                    let r = {},
                        i = /^([\w-]*?)([\d]+)$/;
                    for (let a = 0, s = e.length; a < s; a++) {
                        let o = e[a],
                            l = o.name.match(i);
                        if (l && l.length > 1) {
                            let u = l[1],
                                c = r[u];
                            c || (r[u] = c = []), c.push(o)
                        }
                    }
                    let h = [];
                    for (let d in r) h.push(this.CreateFromMorphTargetSequence(d, r[d], t, n));
                    return h
                }
                static parseAnimation(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    let n = function(e, t, n, r, i) {
                            if (0 !== n.length) {
                                let a = [],
                                    s = [];
                                uD(n, a, s, r), 0 !== a.length && i.push(new e(t, a, s))
                            }
                        },
                        r = [],
                        i = e.name || "default",
                        a = e.fps || 30,
                        s = e.blendMode,
                        o = e.length || -1,
                        l = e.hierarchy || [];
                    for (let u = 0; u < l.length; u++) {
                        let c = l[u].keys;
                        if (c && 0 !== c.length) {
                            if (c[0].morphTargets) {
                                let h;
                                let d = {};
                                for (h = 0; h < c.length; h++)
                                    if (c[h].morphTargets)
                                        for (let f = 0; f < c[h].morphTargets.length; f++) d[c[h].morphTargets[f]] = -1;
                                for (let p in d) {
                                    let m = [],
                                        g = [];
                                    for (let v = 0; v !== c[h].morphTargets.length; ++v) {
                                        let _ = c[h];
                                        m.push(_.time), g.push(_.morphTarget === p ? 1 : 0)
                                    }
                                    r.push(new uV(".morphTargetInfluence[" + p + "]", m, g))
                                }
                                o = d.length * a
                            } else {
                                let y = ".bones[" + t[u].name + "]";
                                n(uq, y + ".position", c, "pos", r), n(uH, y + ".quaternion", c, "rot", r), n(uq, y + ".scale", c, "scl", r)
                            }
                        }
                    }
                    if (0 === r.length) return null;
                    let x = new this(i, o, r, s);
                    return x
                }
                resetDuration() {
                    let e = this.tracks,
                        t = 0;
                    for (let n = 0, r = e.length; n !== r; ++n) {
                        let i = this.tracks[n];
                        t = Math.max(t, i.times[i.times.length - 1])
                    }
                    return this.duration = t, this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
                clone() {
                    let e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new this.constructor(this.name, this.duration, e, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }
            let uZ = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e) {
                    if (!1 !== this.enabled) return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class uY {
                constructor(e, t, n) {
                    let r;
                    let i = this,
                        a = !1,
                        s = 0,
                        o = 0,
                        l = [];
                    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                        o++, !1 === a && void 0 !== i.onStart && i.onStart(e, s, o), a = !0
                    }, this.itemEnd = function(e) {
                        s++, void 0 !== i.onProgress && i.onProgress(e, s, o), s === o && (a = !1, void 0 !== i.onLoad && i.onLoad())
                    }, this.itemError = function(e) {
                        void 0 !== i.onError && i.onError(e)
                    }, this.resolveURL = function(e) {
                        return r ? r(e) : e
                    }, this.setURLModifier = function(e) {
                        return r = e, this
                    }, this.addHandler = function(e, t) {
                        return l.push(e, t), this
                    }, this.removeHandler = function(e) {
                        let t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2), this
                    }, this.getHandler = function(e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            let r = l[t],
                                i = l[t + 1];
                            if (r.global && (r.lastIndex = 0), r.test(e)) return i
                        }
                        return null
                    }
                }
            }
            let u$ = new uY;
            class uJ {
                constructor(e) {
                    this.manager = void 0 !== e ? e : u$, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    let n = this;
                    return new Promise(function(r, i) {
                        n.load(e, r, t, i)
                    })
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e, this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e, this
                }
                setPath(e) {
                    return this.path = e, this
                }
                setResourcePath(e) {
                    return this.resourcePath = e, this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e, this
                }
            }
            let uK = {};
            class uQ extends Error {
                constructor(e, t) {
                    super(e), this.response = t
                }
            }
            class u0 extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let i = uZ.get(e);
                    if (void 0 !== i) return this.manager.itemStart(e), setTimeout(() => {
                        t && t(i), this.manager.itemEnd(e)
                    }, 0), i;
                    if (void 0 !== uK[e]) {
                        uK[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: r
                        });
                        return
                    }
                    uK[e] = [], uK[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: r
                    });
                    let a = new Request(e, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin"
                        }),
                        s = this.mimeType,
                        o = this.responseType;
                    fetch(a).then(t => {
                        if (200 === t.status || 0 === t.status) {
                            if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                            let n = uK[e],
                                r = t.body.getReader(),
                                i = t.headers.get("Content-Length") || t.headers.get("X-File-Size"),
                                a = i ? parseInt(i) : 0,
                                s = 0 !== a,
                                o = 0,
                                l = new ReadableStream({
                                    start(e) {
                                        (function t() {
                                            r.read().then(({
                                                done: r,
                                                value: i
                                            }) => {
                                                if (r) e.close();
                                                else {
                                                    o += i.byteLength;
                                                    let l = new ProgressEvent("progress", {
                                                        lengthComputable: s,
                                                        loaded: o,
                                                        total: a
                                                    });
                                                    for (let u = 0, c = n.length; u < c; u++) {
                                                        let h = n[u];
                                                        h.onProgress && h.onProgress(l)
                                                    }
                                                    e.enqueue(i), t()
                                                }
                                            })
                                        })()
                                    }
                                });
                            return new Response(l)
                        }
                        throw new uQ(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t)
                    }).then(e => {
                        switch (o) {
                            case "arraybuffer":
                                return e.arrayBuffer();
                            case "blob":
                                return e.blob();
                            case "document":
                                return e.text().then(e => {
                                    let t = new DOMParser;
                                    return t.parseFromString(e, s)
                                });
                            case "json":
                                return e.json();
                            default:
                                if (void 0 === s) return e.text(); {
                                    let t = /charset="?([^;"\s]*)"?/i.exec(s),
                                        n = t && t[1] ? t[1].toLowerCase() : void 0,
                                        r = new TextDecoder(n);
                                    return e.arrayBuffer().then(e => r.decode(e))
                                }
                        }
                    }).then(t => {
                        uZ.add(e, t);
                        let n = uK[e];
                        delete uK[e];
                        for (let r = 0, i = n.length; r < i; r++) {
                            let a = n[r];
                            a.onLoad && a.onLoad(t)
                        }
                    }).catch(t => {
                        let n = uK[e];
                        if (void 0 === n) throw this.manager.itemError(e), t;
                        delete uK[e];
                        for (let r = 0, i = n.length; r < i; r++) {
                            let a = n[r];
                            a.onError && a.onError(t)
                        }
                        this.manager.itemError(e)
                    }).finally(() => {
                        this.manager.itemEnd(e)
                    }), this.manager.itemStart(e)
                }
                setResponseType(e) {
                    return this.responseType = e, this
                }
                setMimeType(e) {
                    return this.mimeType = e, this
                }
            }
            class u1 extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        a = new u0(this.manager);
                    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (a) {
                            r ? r(a) : console.error(a), i.manager.itemError(e)
                        }
                    }, n, r)
                }
                parse(e) {
                    let t = [];
                    for (let n = 0; n < e.length; n++) {
                        let r = uX.parse(e[n]);
                        t.push(r)
                    }
                    return t
                }
            }
            class u2 extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        a = [],
                        s = new lh,
                        o = new u0(this.manager);
                    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(i.withCredentials);
                    let l = 0;
                    if (Array.isArray(e))
                        for (let u = 0, c = e.length; u < c; ++u) ! function(u) {
                            o.load(e[u], function(e) {
                                let n = i.parse(e, !0);
                                a[u] = {
                                    width: n.width,
                                    height: n.height,
                                    format: n.format,
                                    mipmaps: n.mipmaps
                                }, 6 === (l += 1) && (1 === n.mipmapCount && (s.minFilter = eb), s.image = a, s.format = n.format, s.needsUpdate = !0, t && t(s))
                            }, n, r)
                        }(u);
                    else o.load(e, function(e) {
                        let n = i.parse(e, !0);
                        if (n.isCubemap) {
                            let r = n.mipmaps.length / n.mipmapCount;
                            for (let o = 0; o < r; o++) {
                                a[o] = {
                                    mipmaps: []
                                };
                                for (let l = 0; l < n.mipmapCount; l++) a[o].mipmaps.push(n.mipmaps[o * n.mipmapCount + l]), a[o].format = n.format, a[o].width = n.width, a[o].height = n.height
                            }
                            s.image = a
                        } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (s.minFilter = eb), s.format = n.format, s.needsUpdate = !0, t && t(s)
                    }, n, r);
                    return s
                }
            }
            class u3 extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let i = this,
                        a = uZ.get(e);
                    if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function() {
                        t && t(a), i.manager.itemEnd(e)
                    }, 0), a;
                    let s = nx("img");

                    function o() {
                        u(), uZ.add(e, this), t && t(this), i.manager.itemEnd(e)
                    }

                    function l(t) {
                        u(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    }

                    function u() {
                        s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1)
                    }
                    return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), i.manager.itemStart(e), s.src = e, s
                }
            }
            class u4 extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = new iB,
                        a = new u3(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                    let s = 0;
                    for (let o = 0; o < e.length; ++o) ! function(n) {
                        a.load(e[n], function(e) {
                            i.images[n] = e, 6 == ++s && (i.needsUpdate = !0, t && t(i))
                        }, void 0, r)
                    }(o);
                    return i
                }
            }
            class u5 extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        a = new oC,
                        s = new u0(this.manager);
                    return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(i.withCredentials), s.load(e, function(e) {
                        let n = i.parse(e);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : ep, a.wrapT = void 0 !== n.wrapT ? n.wrapT : ep, a.magFilter = void 0 !== n.magFilter ? n.magFilter : eb, a.minFilter = void 0 !== n.minFilter ? n.minFilter : eb, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (a.encoding = n.encoding), void 0 !== n.flipY && (a.flipY = n.flipY), void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = eM), 1 === n.mipmapCount && (a.minFilter = eb), void 0 !== n.generateMipmaps && (a.generateMipmaps = n.generateMipmaps), a.needsUpdate = !0, t && t(a, n))
                    }, n, r), a
                }
            }
            class u6 extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = new nO,
                        a = new u3(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(e) {
                        i.image = e, i.needsUpdate = !0, void 0 !== t && t(i)
                    }, n, r), i
                }
            }
            class u8 extends rF {
                constructor(e, t = 1) {
                    super(), this.isLight = !0, this.type = "Light", this.color = new nR(e), this.intensity = t
                }
                dispose() {}
                copy(e, t) {
                    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }
            class u7 extends u8 {
                constructor(e, t, n) {
                    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(rF.DefaultUp), this.updateMatrix(), this.groundColor = new nR(t)
                }
                copy(e, t) {
                    return super.copy(e, t), this.groundColor.copy(e.groundColor), this
                }
            }
            let u9 = new rd,
                ce = new nj,
                ct = new nj;
            class cn {
                constructor(e) {
                    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new np(512, 512), this.map = null, this.mapPass = null, this.matrix = new rd, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new iX, this._frameExtents = new np(1, 1), this._viewportCount = 1, this._viewports = [new nF(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    let t = this.camera,
                        n = this.matrix;
                    ce.setFromMatrixPosition(e.matrixWorld), t.position.copy(ce), ct.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(ct), t.updateMatrixWorld(), u9.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(u9), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(u9)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                toJSON() {
                    let e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }
            class cr extends cn {
                constructor() {
                    super(new iF(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                }
                updateMatrices(e) {
                    let t = this.camera,
                        n = 2 * nn * e.angle * this.focus,
                        r = this.mapSize.width / this.mapSize.height,
                        i = e.distance || t.far;
                    (n !== t.fov || r !== t.aspect || i !== t.far) && (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e), this.focus = e.focus, this
                }
            }
            class ci extends u8 {
                constructor(e, t, n = 0, r = Math.PI / 3, i = 0, a = 1) {
                    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(rF.DefaultUp), this.updateMatrix(), this.target = new rF, this.distance = n, this.angle = r, this.penumbra = i, this.decay = a, this.map = null, this.shadow = new cr
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            let ca = new rd,
                cs = new nj,
                co = new nj;
            class cl extends cn {
                constructor() {
                    super(new iF(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new np(4, 2), this._viewportCount = 6, this._viewports = [new nF(2, 1, 1, 1), new nF(0, 1, 1, 1), new nF(3, 1, 1, 1), new nF(1, 1, 1, 1), new nF(3, 0, 1, 1), new nF(1, 0, 1, 1)], this._cubeDirections = [new nj(1, 0, 0), new nj(-1, 0, 0), new nj(0, 0, 1), new nj(0, 0, -1), new nj(0, 1, 0), new nj(0, -1, 0)], this._cubeUps = [new nj(0, 1, 0), new nj(0, 1, 0), new nj(0, 1, 0), new nj(0, 1, 0), new nj(0, 0, 1), new nj(0, 0, -1)]
                }
                updateMatrices(e, t = 0) {
                    let n = this.camera,
                        r = this.matrix,
                        i = e.distance || n.far;
                    i !== n.far && (n.far = i, n.updateProjectionMatrix()), cs.setFromMatrixPosition(e.matrixWorld), n.position.copy(cs), co.copy(n.position), co.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(co), n.updateMatrixWorld(), r.makeTranslation(-cs.x, -cs.y, -cs.z), ca.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ca)
                }
            }
            class cu extends u8 {
                constructor(e, t, n = 0, r = 1) {
                    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new cl
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }
            class cc extends cn {
                constructor() {
                    super(new i8(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                }
            }
            class ch extends u8 {
                constructor(e, t) {
                    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(rF.DefaultUp), this.updateMatrix(), this.target = new rF, this.shadow = new cc
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            class cd extends u8 {
                constructor(e, t) {
                    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
                }
            }
            class cf extends u8 {
                constructor(e, t, n = 10, r = 10) {
                    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r
                }
                get power() {
                    return this.intensity * this.width * this.height * Math.PI
                }
                set power(e) {
                    this.intensity = e / (this.width * this.height * Math.PI)
                }
                copy(e) {
                    return super.copy(e), this.width = e.width, this.height = e.height, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }
            class cp {
                constructor() {
                    this.isSphericalHarmonics3 = !0, this.coefficients = [];
                    for (let e = 0; e < 9; e++) this.coefficients.push(new nj)
                }
                set(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this
                }
                zero() {
                    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this
                }
                getAt(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z,
                        a = this.coefficients;
                    return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * r), t.addScaledVector(a[2], .488603 * i), t.addScaledVector(a[3], .488603 * n), t.addScaledVector(a[4], 1.092548 * (n * r)), t.addScaledVector(a[5], 1.092548 * (r * i)), t.addScaledVector(a[6], .315392 * (3 * i * i - 1)), t.addScaledVector(a[7], 1.092548 * (n * i)), t.addScaledVector(a[8], .546274 * (n * n - r * r)), t
                }
                getIrradianceAt(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z,
                        a = this.coefficients;
                    return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * i), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], .858086 * n * r), t.addScaledVector(a[5], .858086 * r * i), t.addScaledVector(a[6], .743125 * i * i - .247708), t.addScaledVector(a[7], .858086 * n * i), t.addScaledVector(a[8], .429043 * (n * n - r * r)), t
                }
                add(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this
                }
                addScaledSH(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                    return this
                }
                scale(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this
                }
                lerp(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                    return this
                }
                equals(e) {
                    for (let t = 0; t < 9; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                    return !0
                }
                copy(e) {
                    return this.set(e.coefficients)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                fromArray(e, t = 0) {
                    let n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                    return this
                }
                toArray(e = [], t = 0) {
                    let n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                    return e
                }
                static getBasisAt(e, t) {
                    let n = e.x,
                        r = e.y,
                        i = e.z;
                    t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
                }
            }
            class cm extends u8 {
                constructor(e = new cp, t = 1) {
                    super(void 0, t), this.isLightProbe = !0, this.sh = e
                }
                copy(e) {
                    return super.copy(e), this.sh.copy(e.sh), this
                }
                fromJSON(e) {
                    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.sh = this.sh.toArray(), t
                }
            }
            class cg extends uJ {
                constructor(e) {
                    super(e), this.textures = {}
                }
                load(e, t, n, r) {
                    let i = this,
                        a = new u0(i.manager);
                    a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (a) {
                            r ? r(a) : console.error(a), i.manager.itemError(e)
                        }
                    }, n, r)
                }
                parse(e) {
                    let t = this.textures;

                    function n(e) {
                        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                    }
                    let r = cg.createMaterialFromType(e.type);
                    if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = new nR().setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.iridescence && (r.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                        for (let i in e.uniforms) {
                            let a = e.uniforms[i];
                            switch (r.uniforms[i] = {}, a.type) {
                                case "t":
                                    r.uniforms[i].value = n(a.value);
                                    break;
                                case "c":
                                    r.uniforms[i].value = new nR().setHex(a.value);
                                    break;
                                case "v2":
                                    r.uniforms[i].value = new np().fromArray(a.value);
                                    break;
                                case "v3":
                                    r.uniforms[i].value = new nj().fromArray(a.value);
                                    break;
                                case "v4":
                                    r.uniforms[i].value = new nF().fromArray(a.value);
                                    break;
                                case "m3":
                                    r.uniforms[i].value = new nm().fromArray(a.value);
                                    break;
                                case "m4":
                                    r.uniforms[i].value = new rd().fromArray(a.value);
                                    break;
                                default:
                                    r.uniforms[i].value = a.value
                            }
                        }
                    if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.glslVersion && (r.glslVersion = e.glslVersion), void 0 !== e.extensions)
                        for (let s in e.extensions) r.extensions[s] = e.extensions[s];
                    if (void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        let o = e.normalScale;
                        !1 === Array.isArray(o) && (o = [o, o]), r.normalScale = new np().fromArray(o)
                    }
                    return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = new np().fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (r.iridescenceMap = n(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r
                }
                setTextures(e) {
                    return this.textures = e, this
                }
                static createMaterialFromType(e) {
                    return new({
                        ShadowMaterial: u_,
                        SpriteMaterial: oi,
                        RawShaderMaterial: uy,
                        ShaderMaterial: iU,
                        PointsMaterial: ln,
                        MeshPhysicalMaterial: ub,
                        MeshStandardMaterial: ux,
                        MeshPhongMaterial: uw,
                        MeshToonMaterial: uS,
                        MeshNormalMaterial: uM,
                        MeshLambertMaterial: uT,
                        MeshDepthMaterial: sW,
                        MeshDistanceMaterial: sH,
                        MeshBasicMaterial: rJ,
                        MeshMatcapMaterial: uA,
                        LineDashedMaterial: uE,
                        LineBasicMaterial: o1,
                        Material: r$
                    })[e]
                }
            }
            class cv {
                static decodeText(e) {
                    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
                    let t = "";
                    for (let n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (i) {
                        return t
                    }
                }
                static extractUrlBase(e) {
                    let t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.slice(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e)) ? e : t + e
                }
            }
            class c_ extends iu {
                constructor() {
                    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(e) {
                    return super.copy(e), this.instanceCount = e.instanceCount, this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                toJSON() {
                    let e = super.toJSON(this);
                    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                }
            }
            class cy extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        a = new u0(i.manager);
                    a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (a) {
                            r ? r(a) : console.error(a), i.manager.itemError(e)
                        }
                    }, n, r)
                }
                parse(e) {
                    let t = {},
                        n = {};

                    function r(e, r) {
                        if (void 0 !== t[r]) return t[r];
                        let i = e.interleavedBuffers,
                            a = i[r],
                            s = function(e, t) {
                                if (void 0 !== n[t]) return n[t];
                                let r = e.arrayBuffers,
                                    i = r[t],
                                    a = new Uint32Array(i).buffer;
                                return n[t] = a, a
                            }(e, a.buffer),
                            o = ny(a.type, s),
                            l = new ot(o, a.stride);
                        return l.uuid = a.uuid, t[r] = l, l
                    }
                    let i = e.isInstancedBufferGeometry ? new c_ : new iu,
                        a = e.data.index;
                    if (void 0 !== a) {
                        let s = ny(a.type, a.array);
                        i.setIndex(new r0(s, 1))
                    }
                    let o = e.data.attributes;
                    for (let l in o) {
                        let u;
                        let c = o[l];
                        if (c.isInterleavedBufferAttribute) {
                            let h = r(e.data, c.data);
                            u = new or(h, c.itemSize, c.offset, c.normalized)
                        } else {
                            let d = ny(c.type, c.array),
                                f = c.isInstancedBufferAttribute ? oO : r0;
                            u = new f(d, c.itemSize, c.normalized)
                        }
                        void 0 !== c.name && (u.name = c.name), void 0 !== c.usage && u.setUsage(c.usage), void 0 !== c.updateRange && (u.updateRange.offset = c.updateRange.offset, u.updateRange.count = c.updateRange.count), i.setAttribute(l, u)
                    }
                    let p = e.data.morphAttributes;
                    if (p)
                        for (let m in p) {
                            let g = p[m],
                                v = [];
                            for (let _ = 0, y = g.length; _ < y; _++) {
                                let x;
                                let b = g[_];
                                if (b.isInterleavedBufferAttribute) {
                                    let w = r(e.data, b.data);
                                    x = new or(w, b.itemSize, b.offset, b.normalized)
                                } else {
                                    let S = ny(b.type, b.array);
                                    x = new r0(S, b.itemSize, b.normalized)
                                }
                                void 0 !== b.name && (x.name = b.name), v.push(x)
                            }
                            i.morphAttributes[m] = v
                        }
                    let M = e.data.morphTargetsRelative;
                    M && (i.morphTargetsRelative = !0);
                    let T = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== T)
                        for (let A = 0, E = T.length; A !== E; ++A) {
                            let C = T[A];
                            i.addGroup(C.start, C.count, C.materialIndex)
                        }
                    let I = e.data.boundingSphere;
                    if (void 0 !== I) {
                        let P = new nj;
                        void 0 !== I.center && P.fromArray(I.center), i.boundingSphere = new rr(P, I.radius)
                    }
                    return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i
                }
            }
            class cx extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        a = "" === this.path ? cv.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || a;
                    let s = new u0(this.manager);
                    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(n) {
                        let a = null;
                        try {
                            a = JSON.parse(n)
                        } catch (s) {
                            void 0 !== r && r(s), console.error("THREE:ObjectLoader: Can't parse " + e + ".", s.message);
                            return
                        }
                        let o = a.metadata;
                        if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) {
                            console.error("THREE.ObjectLoader: Can't load " + e);
                            return
                        }
                        i.parse(a, t)
                    }, n, r)
                }
                async loadAsync(e, t) {
                    let n = "" === this.path ? cv.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || n;
                    let r = new u0(this.manager);
                    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
                    let i = await r.loadAsync(e, t),
                        a = JSON.parse(i),
                        s = a.metadata;
                    if (void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase()) throw Error("THREE.ObjectLoader: Can't load " + e);
                    return await this.parseAsync(a)
                }
                parse(e, t) {
                    let n = this.parseAnimations(e.animations),
                        r = this.parseShapes(e.shapes),
                        i = this.parseGeometries(e.geometries, r),
                        a = this.parseImages(e.images, function() {
                            void 0 !== t && t(l)
                        }),
                        s = this.parseTextures(e.textures, a),
                        o = this.parseMaterials(e.materials, s),
                        l = this.parseObject(e.object, i, o, s, n),
                        u = this.parseSkeletons(e.skeletons, l);
                    if (this.bindSkeletons(l, u), void 0 !== t) {
                        let c = !1;
                        for (let h in a)
                            if (a[h].data instanceof HTMLImageElement) {
                                c = !0;
                                break
                            }!1 === c && t(l)
                    }
                    return l
                }
                async parseAsync(e) {
                    let t = this.parseAnimations(e.animations),
                        n = this.parseShapes(e.shapes),
                        r = this.parseGeometries(e.geometries, n),
                        i = await this.parseImagesAsync(e.images),
                        a = this.parseTextures(e.textures, i),
                        s = this.parseMaterials(e.materials, a),
                        o = this.parseObject(e.object, r, s, a, t),
                        l = this.parseSkeletons(e.skeletons, o);
                    return this.bindSkeletons(o, l), o
                }
                parseShapes(e) {
                    let t = {};
                    if (void 0 !== e)
                        for (let n = 0, r = e.length; n < r; n++) {
                            let i = new lZ().fromJSON(e[n]);
                            t[i.uuid] = i
                        }
                    return t
                }
                parseSkeletons(e, t) {
                    let n = {},
                        r = {};
                    if (t.traverse(function(e) {
                            e.isBone && (r[e.uuid] = e)
                        }), void 0 !== e)
                        for (let i = 0, a = e.length; i < a; i++) {
                            let s = new oq().fromJSON(e[i], r);
                            n[s.uuid] = s
                        }
                    return n
                }
                parseGeometries(e, t) {
                    let n = {};
                    if (void 0 !== e) {
                        let r = new cy;
                        for (let i = 0, a = e.length; i < a; i++) {
                            let s;
                            let o = e[i];
                            switch (o.type) {
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    s = r.parse(o);
                                    break;
                                default:
                                    o.type in uv ? s = uv[o.type].fromJSON(o, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)
                            }
                            s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), n[o.uuid] = s
                        }
                    }
                    return n
                }
                parseMaterials(e, t) {
                    let n = {},
                        r = {};
                    if (void 0 !== e) {
                        let i = new cg;
                        i.setTextures(t);
                        for (let a = 0, s = e.length; a < s; a++) {
                            let o = e[a];
                            void 0 === n[o.uuid] && (n[o.uuid] = i.parse(o)), r[o.uuid] = n[o.uuid]
                        }
                    }
                    return r
                }
                parseAnimations(e) {
                    let t = {};
                    if (void 0 !== e)
                        for (let n = 0; n < e.length; n++) {
                            let r = e[n],
                                i = uX.parse(r);
                            t[i.uuid] = i
                        }
                    return t
                }
                parseImages(e, t) {
                    let n;
                    let r = this,
                        i = {};

                    function a(e) {
                        if ("string" == typeof e) {
                            let t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : r.resourcePath + e;
                            return r.manager.itemStart(t), n.load(t, function() {
                                r.manager.itemEnd(t)
                            }, void 0, function() {
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            })
                        }
                        return e.data ? {
                            data: ny(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        let s = new uY(t);
                        (n = new u3(s)).setCrossOrigin(this.crossOrigin);
                        for (let o = 0, l = e.length; o < l; o++) {
                            let u = e[o],
                                c = u.url;
                            if (Array.isArray(c)) {
                                let h = [];
                                for (let d = 0, f = c.length; d < f; d++) {
                                    let p = c[d],
                                        m = a(p);
                                    null !== m && (m instanceof HTMLImageElement ? h.push(m) : h.push(new oC(m.data, m.width, m.height)))
                                }
                                i[u.uuid] = new nD(h)
                            } else {
                                let g = a(u.url);
                                i[u.uuid] = new nD(g)
                            }
                        }
                    }
                    return i
                }
                async parseImagesAsync(e) {
                    let t;
                    let n = this,
                        r = {};
                    async function i(e) {
                        if ("string" == typeof e) {
                            let r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e;
                            return await t.loadAsync(r)
                        }
                        return e.data ? {
                            data: ny(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        (t = new u3(this.manager)).setCrossOrigin(this.crossOrigin);
                        for (let a = 0, s = e.length; a < s; a++) {
                            let o = e[a],
                                l = o.url;
                            if (Array.isArray(l)) {
                                let u = [];
                                for (let c = 0, h = l.length; c < h; c++) {
                                    let d = l[c],
                                        f = await i(d);
                                    null !== f && (f instanceof HTMLImageElement ? u.push(f) : u.push(new oC(f.data, f.width, f.height)))
                                }
                                r[o.uuid] = new nD(u)
                            } else {
                                let p = await i(o.url);
                                r[o.uuid] = new nD(p)
                            }
                        }
                    }
                    return r
                }
                parseTextures(e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    let r = {};
                    if (void 0 !== e)
                        for (let i = 0, a = e.length; i < a; i++) {
                            let s;
                            let o = e[i];
                            void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                            let l = t[o.image],
                                u = l.data;
                            Array.isArray(u) ? (s = new iB, 6 === u.length && (s.needsUpdate = !0)) : (s = u && u.data ? new oC : new nO, u && (s.needsUpdate = !0)), s.source = l, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, cb)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], cw), s.wrapT = n(o.wrap[1], cw)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, cS)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, cS)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), void 0 !== o.userData && (s.userData = o.userData), r[o.uuid] = s
                        }
                    return r
                }
                parseObject(e, t, n, r, i) {
                    let a, s, o;

                    function l(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function u(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                let t = [];
                                for (let r = 0, i = e.length; r < i; r++) {
                                    let a = e[r];
                                    void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), t.push(n[a])
                                }
                                return t
                            }
                            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                        }
                    }

                    function c(e) {
                        return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e]
                    }
                    switch (e.type) {
                        case "Scene":
                            a = new oe, void 0 !== e.background && (Number.isInteger(e.background) ? a.background = new nR(e.background) : a.background = c(e.background)), void 0 !== e.environment && (a.environment = c(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new s9(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new s7(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            a = new iF(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            a = new i8(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            a = new cd(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            a = new ch(e.color, e.intensity);
                            break;
                        case "PointLight":
                            a = new cu(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            a = new cf(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            a = new ci(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            a = new u7(e.color, e.groundColor, e.intensity);
                            break;
                        case "LightProbe":
                            a = new cm().fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            s = l(e.geometry), o = u(e.material), a = new oE(s, o), void 0 !== e.bindMode && (a.bindMode = e.bindMode), void 0 !== e.bindMatrix && a.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (a.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            s = l(e.geometry), o = u(e.material), a = new iC(s, o);
                            break;
                        case "InstancedMesh":
                            s = l(e.geometry), o = u(e.material);
                            let h = e.count,
                                d = e.instanceMatrix,
                                f = e.instanceColor;
                            (a = new o0(s, o, h)).instanceMatrix = new oO(new Float32Array(d.array), 16), void 0 !== f && (a.instanceColor = new oO(new Float32Array(f.array), f.itemSize));
                            break;
                        case "LOD":
                            a = new ob;
                            break;
                        case "Line":
                            a = new o8(l(e.geometry), u(e.material));
                            break;
                        case "LineLoop":
                            a = new lt(l(e.geometry), u(e.material));
                            break;
                        case "LineSegments":
                            a = new le(l(e.geometry), u(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            a = new lo(l(e.geometry), u(e.material));
                            break;
                        case "Sprite":
                            a = new ov(u(e.material));
                            break;
                        case "Group":
                            a = new sK;
                            break;
                        case "Bone":
                            a = new oW;
                            break;
                        default:
                            a = new rF
                    }
                    if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (a.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (a.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.frustumCulled && (a.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.layers && (a.layers.mask = e.layers), void 0 !== e.children) {
                        let p = e.children;
                        for (let m = 0; m < p.length; m++) a.add(this.parseObject(p[m], t, n, r, i))
                    }
                    if (void 0 !== e.animations) {
                        let g = e.animations;
                        for (let v = 0; v < g.length; v++) {
                            let _ = g[v];
                            a.animations.push(i[_])
                        }
                    }
                    if ("LOD" === e.type) {
                        void 0 !== e.autoUpdate && (a.autoUpdate = e.autoUpdate);
                        let y = e.levels;
                        for (let x = 0; x < y.length; x++) {
                            let b = y[x],
                                w = a.getObjectByProperty("uuid", b.object);
                            void 0 !== w && a.addLevel(w, b.distance)
                        }
                    }
                    return a
                }
                bindSkeletons(e, t) {
                    0 !== Object.keys(t).length && e.traverse(function(e) {
                        if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                            let n = t[e.skeleton];
                            void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                        }
                    })
                }
            }
            let cb = {
                    UVMapping: eo,
                    CubeReflectionMapping: el,
                    CubeRefractionMapping: eu,
                    EquirectangularReflectionMapping: ec,
                    EquirectangularRefractionMapping: eh,
                    CubeUVReflectionMapping: ed
                },
                cw = {
                    RepeatWrapping: ef,
                    ClampToEdgeWrapping: ep,
                    MirroredRepeatWrapping: em
                },
                cS = {
                    NearestFilter: eg,
                    NearestMipmapNearestFilter: ev,
                    NearestMipmapLinearFilter: ey,
                    LinearFilter: eb,
                    LinearMipmapNearestFilter: ew,
                    LinearMipmapLinearFilter: eM
                };
            class cM extends uJ {
                constructor(e) {
                    super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(e) {
                    return this.options = e, this
                }
                load(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let i = this,
                        a = uZ.get(e);
                    if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function() {
                        t && t(a), i.manager.itemEnd(e)
                    }, 0), a;
                    let s = {};
                    s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(e, s).then(function(e) {
                        return e.blob()
                    }).then(function(e) {
                        return createImageBitmap(e, Object.assign(i.options, {
                            colorSpaceConversion: "none"
                        }))
                    }).then(function(n) {
                        uZ.add(e, n), t && t(n), i.manager.itemEnd(e)
                    }).catch(function(t) {
                        r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    }), i.manager.itemStart(e)
                }
            }
            let cT = {
                getContext: function() {
                    return void 0 === a && (a = new(window.AudioContext || window.webkitAudioContext)), a
                },
                setContext: function(e) {
                    a = e
                }
            };
            class cA extends uJ {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    let i = this,
                        a = new u0(this.manager);
                    a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(n) {
                        try {
                            let a = n.slice(0),
                                s = cT.getContext();
                            s.decodeAudioData(a, function(e) {
                                t(e)
                            })
                        } catch (o) {
                            r ? r(o) : console.error(o), i.manager.itemError(e)
                        }
                    }, n, r)
                }
            }
            class cE extends cm {
                constructor(e, t, n = 1) {
                    super(void 0, n), this.isHemisphereLightProbe = !0;
                    let r = new nR().set(e),
                        i = new nR().set(t),
                        a = new nj(r.r, r.g, r.b),
                        s = new nj(i.r, i.g, i.b),
                        o = Math.sqrt(Math.PI);
                    this.sh.coefficients[0].copy(a).add(s).multiplyScalar(o), this.sh.coefficients[1].copy(a).sub(s).multiplyScalar(o * Math.sqrt(.75))
                }
            }
            class cC extends cm {
                constructor(e, t = 1) {
                    super(void 0, t), this.isAmbientLightProbe = !0;
                    let n = new nR().set(e);
                    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
            }
            let cI = new rd,
                cP = new rd,
                cR = new rd;
            class cL {
                constructor() {
                    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new iF, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new iF, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                        focus: null,
                        fov: null,
                        aspect: null,
                        near: null,
                        far: null,
                        zoom: null,
                        eyeSep: null
                    }
                }
                update(e) {
                    let t = this._cache,
                        n = t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep;
                    if (n) {
                        let r, i;
                        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, cR.copy(e.projectionMatrix);
                        let a = t.eyeSep / 2,
                            s = a * t.near / t.focus,
                            o = t.near * Math.tan(nt * t.fov * .5) / t.zoom;
                        cP.elements[12] = -a, cI.elements[12] = a, r = -o * t.aspect + s, i = o * t.aspect + s, cR.elements[0] = 2 * t.near / (i - r), cR.elements[8] = (i + r) / (i - r), this.cameraL.projectionMatrix.copy(cR), r = -o * t.aspect - s, i = o * t.aspect - s, cR.elements[0] = 2 * t.near / (i - r), cR.elements[8] = (i + r) / (i - r), this.cameraR.projectionMatrix.copy(cR)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(cP), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(cI)
                }
            }
            class cD {
                constructor(e = !0) {
                    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = ck(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        let t = ck();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }

            function ck() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }
            let cU = new nj,
                cO = new nH,
                cF = new nj,
                cN = new nj;
            class cB extends rF {
                constructor() {
                    super(), this.type = "AudioListener", this.context = cT.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new cD
                }
                getInput() {
                    return this.gain
                }
                removeFilter() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                }
                getFilter() {
                    return this.filter
                }
                setFilter(e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                }
                getMasterVolume() {
                    return this.gain.gain.value
                }
                setMasterVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e);
                    let t = this.context.listener,
                        n = this.up;
                    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(cU, cO, cF), cN.set(0, 0, -1).applyQuaternion(cO), t.positionX) {
                        let r = this.context.currentTime + this.timeDelta;
                        t.positionX.linearRampToValueAtTime(cU.x, r), t.positionY.linearRampToValueAtTime(cU.y, r), t.positionZ.linearRampToValueAtTime(cU.z, r), t.forwardX.linearRampToValueAtTime(cN.x, r), t.forwardY.linearRampToValueAtTime(cN.y, r), t.forwardZ.linearRampToValueAtTime(cN.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r)
                    } else t.setPosition(cU.x, cU.y, cU.z), t.setOrientation(cN.x, cN.y, cN.z, n.x, n.y, n.z)
                }
            }
            class cz extends rF {
                constructor(e) {
                    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                }
                setMediaElementSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                }
                setMediaStreamSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                }
                setBuffer(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(e = 0) {
                    if (!0 === this.isPlaying) {
                        console.warn("THREE.Audio: Audio is already playing.");
                        return
                    }
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    this._startedAt = this.context.currentTime + e;
                    let t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
                }
                stop() {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(e) {
                    return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                }
                setDetune(e) {
                    if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(e) {
                    return this.setFilters(e ? [e] : [])
                }
                setPlaybackRate(e) {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(e) {
                    if (!1 === this.hasPlaybackControl) {
                        console.warn("THREE.Audio: this Audio has no playback control.");
                        return
                    }
                    return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this
                }
                setLoopStart(e) {
                    return this.loopStart = e, this
                }
                setLoopEnd(e) {
                    return this.loopEnd = e, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }
            let cG = new nj,
                cV = new nH,
                cW = new nj,
                cH = new nj;
            class cj extends cz {
                constructor(e) {
                    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                }
                disconnect() {
                    super.disconnect(), this.panner.disconnect(this.gain)
                }
                getOutput() {
                    return this.panner
                }
                getRefDistance() {
                    return this.panner.refDistance
                }
                setRefDistance(e) {
                    return this.panner.refDistance = e, this
                }
                getRolloffFactor() {
                    return this.panner.rolloffFactor
                }
                setRolloffFactor(e) {
                    return this.panner.rolloffFactor = e, this
                }
                getDistanceModel() {
                    return this.panner.distanceModel
                }
                setDistanceModel(e) {
                    return this.panner.distanceModel = e, this
                }
                getMaxDistance() {
                    return this.panner.maxDistance
                }
                setMaxDistance(e) {
                    return this.panner.maxDistance = e, this
                }
                setDirectionalCone(e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                }
                updateMatrixWorld(e) {
                    if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                    this.matrixWorld.decompose(cG, cV, cW), cH.set(0, 0, 1).applyQuaternion(cV);
                    let t = this.panner;
                    if (t.positionX) {
                        let n = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(cG.x, n), t.positionY.linearRampToValueAtTime(cG.y, n), t.positionZ.linearRampToValueAtTime(cG.z, n), t.orientationX.linearRampToValueAtTime(cH.x, n), t.orientationY.linearRampToValueAtTime(cH.y, n), t.orientationZ.linearRampToValueAtTime(cH.z, n)
                    } else t.setPosition(cG.x, cG.y, cG.z), t.setOrientation(cH.x, cH.y, cH.z)
                }
            }
            class cq {
                constructor(e, t = 2048) {
                    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
                }
                getFrequencyData() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
                getAverageFrequency() {
                    let e = 0,
                        t = this.getFrequencyData();
                    for (let n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }
            class cX {
                constructor(e, t, n) {
                    let r, i, a;
                    switch (this.binding = e, this.valueSize = n, t) {
                        case "quaternion":
                            r = this._slerp, i = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            r = this._select, i = this._select, a = this._setAdditiveIdentityOther, this.buffer = Array(5 * n);
                            break;
                        default:
                            r = this._lerp, i = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                    }
                    this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(e, t) {
                    let n = this.buffer,
                        r = this.valueSize,
                        i = e * r + r,
                        a = this.cumulativeWeight;
                    if (0 === a) {
                        for (let s = 0; s !== r; ++s) n[i + s] = n[s];
                        a = t
                    } else {
                        a += t;
                        let o = t / a;
                        this._mixBufferRegion(n, i, 0, o, r)
                    }
                    this.cumulativeWeight = a
                }
                accumulateAdditive(e) {
                    let t = this.buffer,
                        n = this.valueSize,
                        r = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e
                }
                apply(e) {
                    let t = this.valueSize,
                        n = this.buffer,
                        r = e * t + t,
                        i = this.cumulativeWeight,
                        a = this.cumulativeWeightAdditive,
                        s = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                        let o = t * this._origIndex;
                        this._mixBufferRegion(n, r, o, 1 - i, t)
                    }
                    a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
                    for (let l = t, u = t + t; l !== u; ++l)
                        if (n[l] !== n[l + t]) {
                            s.setValue(n, r);
                            break
                        }
                }
                saveOriginalState() {
                    let e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        r = n * this._origIndex;
                    e.getValue(t, r);
                    for (let i = n; i !== r; ++i) t[i] = t[r + i % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    let e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                }
                _setAdditiveIdentityNumeric() {
                    let e = this._addIndex * this.valueSize,
                        t = e + this.valueSize;
                    for (let n = e; n < t; n++) this.buffer[n] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    let e = this._origIndex * this.valueSize,
                        t = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
                }
                _select(e, t, n, r, i) {
                    if (r >= .5)
                        for (let a = 0; a !== i; ++a) e[t + a] = e[n + a]
                }
                _slerp(e, t, n, r) {
                    nH.slerpFlat(e, t, e, t, e, n, r)
                }
                _slerpAdditive(e, t, n, r, i) {
                    let a = this._workIndex * i;
                    nH.multiplyQuaternionsFlat(e, a, e, t, e, n), nH.slerpFlat(e, t, e, t, e, a, r)
                }
                _lerp(e, t, n, r, i) {
                    let a = 1 - r;
                    for (let s = 0; s !== i; ++s) {
                        let o = t + s;
                        e[o] = e[o] * a + e[n + s] * r
                    }
                }
                _lerpAdditive(e, t, n, r, i) {
                    for (let a = 0; a !== i; ++a) {
                        let s = t + a;
                        e[s] = e[s] + e[n + a] * r
                    }
                }
            }
            let cZ = "\\[\\]\\.:\\/",
                cY = RegExp("[" + cZ + "]", "g"),
                c$ = "[^" + cZ + "]",
                cJ = "[^" + cZ.replace("\\.", "") + "]",
                cK = /((?:WC+[\/:])*)/.source.replace("WC", c$),
                cQ = /(WCOD+)?/.source.replace("WCOD", cJ),
                c0 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", c$),
                c1 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", c$),
                c2 = RegExp("^" + cK + cQ + c0 + c1 + "$"),
                c3 = ["material", "materials", "bones", "map"];
            class c4 {
                constructor(e, t, n) {
                    this.path = t, this.parsedPath = n || c4.parseTrackName(t), this.node = c4.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new c4.Composite(e, t, n) : new c4(e, t, n)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(cY, "")
                }
                static parseTrackName(e) {
                    let t = c2.exec(e);
                    if (null === t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                    let n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        let i = n.nodeName.substring(r + 1); - 1 !== c3.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
                static findNode(e, t) {
                    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        let n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        let r = function(e) {
                                for (let n = 0; n < e.length; n++) {
                                    let i = e[n];
                                    if (i.name === t || i.uuid === t) return i;
                                    let a = r(i.children);
                                    if (a) return a
                                }
                                return null
                            },
                            i = r(e.children);
                        if (i) return i
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    let n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                }
                bind() {
                    let e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        r = t.propertyName,
                        i = t.propertyIndex;
                    if (e || (e = c4.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        return
                    }
                    if (n) {
                        let a = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.materials) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) {
                                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                e = e.skeleton.bones;
                                for (let s = 0; s < e.length; s++)
                                    if (e[s].name === a) {
                                        a = s;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map" in e) {
                                    e = e.map;
                                    break
                                }
                                if (!e.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.map) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                e = e.material.map;
                                break;
                            default:
                                if (void 0 === e[n]) {
                                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                e = e[n]
                        }
                        if (void 0 !== a) {
                            if (void 0 === e[a]) {
                                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                return
                            }
                            e = e[a]
                        }
                    }
                    let o = e[r];
                    if (void 0 === o) {
                        let l = t.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", e);
                        return
                    }
                    let u = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? u = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (u = this.Versioning.MatrixWorldNeedsUpdate);
                    let c = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!e.geometry) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                return
                            }
                            if (!e.geometry.morphAttributes) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                return
                            }
                            void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                        }
                        c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i
                    } else void 0 !== o.fromArray && void 0 !== o.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][u]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            c4.Composite = class {
                constructor(e, t, n) {
                    let r = n || c4.parseTrackName(t);
                    this._targetGroup = e, this._bindings = e.subscribe_(t, r)
                }
                getValue(e, t) {
                    this.bind();
                    let n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(e, t)
                }
                setValue(e, t) {
                    let n = this._bindings;
                    for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
                }
                bind() {
                    let e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                }
                unbind() {
                    let e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }, c4.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, c4.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, c4.prototype.GetterByBindingType = [c4.prototype._getValue_direct, c4.prototype._getValue_array, c4.prototype._getValue_arrayElement, c4.prototype._getValue_toArray], c4.prototype.SetterByBindingTypeAndVersioning = [
                [c4.prototype._setValue_direct, c4.prototype._setValue_direct_setNeedsUpdate, c4.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [c4.prototype._setValue_array, c4.prototype._setValue_array_setNeedsUpdate, c4.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [c4.prototype._setValue_arrayElement, c4.prototype._setValue_arrayElement_setNeedsUpdate, c4.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [c4.prototype._setValue_fromArray, c4.prototype._setValue_fromArray_setNeedsUpdate, c4.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class c5 {
                constructor() {
                    this.isAnimationObjectGroup = !0, this.uuid = nr(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                    let e = {};
                    this._indicesByUUID = e;
                    for (let t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                    let r = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return r._objects.length
                            },
                            get inUse() {
                                return this.total - r.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return r._bindings.length
                        }
                    }
                }
                add() {
                    let e = this._objects,
                        t = this._indicesByUUID,
                        n = this._paths,
                        r = this._parsedPaths,
                        i = this._bindings,
                        a = i.length,
                        s, o = e.length,
                        l = this.nCachedObjects_;
                    for (let u = 0, c = arguments.length; u !== c; ++u) {
                        let h = arguments[u],
                            d = h.uuid,
                            f = t[d];
                        if (void 0 === f) {
                            f = o++, t[d] = f, e.push(h);
                            for (let p = 0; p !== a; ++p) i[p].push(new c4(h, n[p], r[p]))
                        } else if (f < l) {
                            s = e[f];
                            let m = --l,
                                g = e[m];
                            t[g.uuid] = f, e[f] = g, t[d] = m, e[m] = h;
                            for (let v = 0; v !== a; ++v) {
                                let _ = i[v],
                                    y = _[m],
                                    x = _[f];
                                _[f] = y, void 0 === x && (x = new c4(h, n[v], r[v])), _[m] = x
                            }
                        } else e[f] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = l
                }
                remove() {
                    let e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length,
                        i = this.nCachedObjects_;
                    for (let a = 0, s = arguments.length; a !== s; ++a) {
                        let o = arguments[a],
                            l = o.uuid,
                            u = t[l];
                        if (void 0 !== u && u >= i) {
                            let c = i++,
                                h = e[c];
                            t[h.uuid] = u, e[u] = h, t[l] = c, e[c] = o;
                            for (let d = 0; d !== r; ++d) {
                                let f = n[d],
                                    p = f[c],
                                    m = f[u];
                                f[u] = p, f[c] = m
                            }
                        }
                    }
                    this.nCachedObjects_ = i
                }
                uncache() {
                    let e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length,
                        i = this.nCachedObjects_,
                        a = e.length;
                    for (let s = 0, o = arguments.length; s !== o; ++s) {
                        let l = arguments[s],
                            u = l.uuid,
                            c = t[u];
                        if (void 0 !== c) {
                            if (delete t[u], c < i) {
                                let h = --i,
                                    d = e[h],
                                    f = --a,
                                    p = e[f];
                                t[d.uuid] = c, e[c] = d, t[p.uuid] = h, e[h] = p, e.pop();
                                for (let m = 0; m !== r; ++m) {
                                    let g = n[m],
                                        v = g[h],
                                        _ = g[f];
                                    g[c] = v, g[h] = _, g.pop()
                                }
                            } else {
                                let y = --a,
                                    x = e[y];
                                y > 0 && (t[x.uuid] = c), e[c] = x, e.pop();
                                for (let b = 0; b !== r; ++b) {
                                    let w = n[b];
                                    w[c] = w[y], w.pop()
                                }
                            }
                        }
                    }
                    this.nCachedObjects_ = i
                }
                subscribe_(e, t) {
                    let n = this._bindingsIndicesByPath,
                        r = n[e],
                        i = this._bindings;
                    if (void 0 !== r) return i[r];
                    let a = this._paths,
                        s = this._parsedPaths,
                        o = this._objects,
                        l = o.length,
                        u = this.nCachedObjects_,
                        c = Array(l);
                    r = i.length, n[e] = r, a.push(e), s.push(t), i.push(c);
                    for (let h = u, d = o.length; h !== d; ++h) {
                        let f = o[h];
                        c[h] = new c4(f, e, t)
                    }
                    return c
                }
                unsubscribe_(e) {
                    let t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        let r = this._paths,
                            i = this._parsedPaths,
                            a = this._bindings,
                            s = a.length - 1,
                            o = a[s],
                            l = e[s];
                        t[l] = n, a[n] = o, a.pop(), i[n] = i[s], i.pop(), r[n] = r[s], r.pop()
                    }
                }
            }
            class c6 {
                constructor(e, t, n = null, r = t.blendMode) {
                    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
                    let i = t.tracks,
                        a = i.length,
                        s = Array(a),
                        o = {
                            endingStart: tv,
                            endingEnd: tv
                        };
                    for (let l = 0; l !== a; ++l) {
                        let u = i[l].createInterpolant(null);
                        s[l] = u, u.settings = o
                    }
                    this._interpolantSettings = o, this._interpolants = s, this._propertyBindings = Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = td, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(e) {
                    return this._startTime = e, this
                }
                setLoop(e, t) {
                    return this.loop = e, this.repetitions = t, this
                }
                setEffectiveWeight(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(e) {
                    return this._scheduleFading(e, 0, 1)
                }
                fadeOut(e) {
                    return this._scheduleFading(e, 1, 0)
                }
                crossFadeFrom(e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        let r = this._clip.duration,
                            i = e._clip.duration;
                        e.warp(1, i / r, t), this.warp(r / i, 1, t)
                    }
                    return this
                }
                crossFadeTo(e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                }
                stopFading() {
                    let e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                setEffectiveTimeScale(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                }
                syncWith(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                }
                halt(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                }
                warp(e, t, n) {
                    let r = this._mixer,
                        i = r.time,
                        a = this.timeScale,
                        s = this._timeScaleInterpolant;
                    null === s && (s = r._lendControlInterpolant(), this._timeScaleInterpolant = s);
                    let o = s.parameterPositions,
                        l = s.sampleValues;
                    return o[0] = i, o[1] = i + n, l[0] = e / a, l[1] = t / a, this
                }
                stopWarping() {
                    let e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(e, t, n, r) {
                    if (!this.enabled) {
                        this._updateWeight(e);
                        return
                    }
                    let i = this._startTime;
                    if (null !== i) {
                        let a = (e - i) * n;
                        a < 0 || 0 === n ? t = 0 : (this._startTime = null, t = n * a)
                    }
                    t *= this._updateTimeScale(e);
                    let s = this._updateTime(t),
                        o = this._updateWeight(e);
                    if (o > 0) {
                        let l = this._interpolants,
                            u = this._propertyBindings;
                        if (this.blendMode === tb)
                            for (let c = 0, h = l.length; c !== h; ++c) l[c].evaluate(s), u[c].accumulateAdditive(o);
                        else
                            for (let d = 0, f = l.length; d !== f; ++d) l[d].evaluate(s), u[d].accumulate(r, o)
                    }
                }
                _updateWeight(e) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        let n = this._weightInterpolant;
                        if (null !== n) {
                            let r = n.evaluate(e)[0];
                            t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(e) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        let n = this._timeScaleInterpolant;
                        if (null !== n) {
                            let r = n.evaluate(e)[0];
                            t *= r, e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(e) {
                    let t = this._clip.duration,
                        n = this.loop,
                        r = this.time + e,
                        i = this._loopCount,
                        a = n === tf;
                    if (0 === e) return -1 === i ? r : a && (1 & i) == 1 ? t - r : r;
                    if (n === th) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        s: {
                            if (r >= t) r = t;
                            else if (r < 0) r = 0;
                            else {
                                this.time = r;
                                break s
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = r,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= t || r < 0) {
                            let s = Math.floor(r / t);
                            r -= t * s, i += Math.abs(s);
                            let o = this.repetitions - i;
                            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === o) {
                                    let l = e < 0;
                                    this._setEndings(l, !l, a)
                                } else this._setEndings(!1, !1, a);
                                this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: s
                                })
                            }
                        } else this.time = r;
                        if (a && (1 & i) == 1) return t - r
                    }
                    return r
                }
                _setEndings(e, t, n) {
                    let r = this._interpolantSettings;
                    n ? (r.endingStart = t_, r.endingEnd = t_) : (e ? r.endingStart = this.zeroSlopeAtStart ? t_ : tv : r.endingStart = ty, t ? r.endingEnd = this.zeroSlopeAtEnd ? t_ : tv : r.endingEnd = ty)
                }
                _scheduleFading(e, t, n) {
                    let r = this._mixer,
                        i = r.time,
                        a = this._weightInterpolant;
                    null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
                    let s = a.parameterPositions,
                        o = a.sampleValues;
                    return s[0] = i, o[0] = t, s[1] = i + e, o[1] = n, this
                }
            }
            let c8 = new Float32Array(1);
            class c7 extends t7 {
                constructor(e) {
                    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(e, t) {
                    let n = e._localRoot || this._root,
                        r = e._clip.tracks,
                        i = r.length,
                        a = e._propertyBindings,
                        s = e._interpolants,
                        o = n.uuid,
                        l = this._bindingsByRootAndName,
                        u = l[o];
                    void 0 === u && (u = {}, l[o] = u);
                    for (let c = 0; c !== i; ++c) {
                        let h = r[c],
                            d = h.name,
                            f = u[d];
                        if (void 0 !== f) ++f.referenceCount, a[c] = f;
                        else {
                            if (void 0 !== (f = a[c])) {
                                null === f._cacheIndex && (++f.referenceCount, this._addInactiveBinding(f, o, d));
                                continue
                            }
                            let p = t && t._propertyBindings[c].binding.parsedPath;
                            f = new cX(c4.create(n, d, p), h.ValueTypeName, h.getValueSize()), ++f.referenceCount, this._addInactiveBinding(f, o, d), a[c] = f
                        }
                        s[c].resultBuffer = f.buffer
                    }
                }
                _activateAction(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            let t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        let i = e._propertyBindings;
                        for (let a = 0, s = i.length; a !== s; ++a) {
                            let o = i[a];
                            0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                }
                _deactivateAction(e) {
                    if (this._isActiveAction(e)) {
                        let t = e._propertyBindings;
                        for (let n = 0, r = t.length; n !== r; ++n) {
                            let i = t[n];
                            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                        }
                        this._takeBackAction(e)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    let e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(e) {
                    let t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                }
                _addInactiveAction(e, t, n) {
                    let r = this._actions,
                        i = this._actionsByClip,
                        a = i[t];
                    if (void 0 === a) a = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, i[t] = a;
                    else {
                        let s = a.knownActions;
                        e._byClipCacheIndex = s.length, s.push(e)
                    }
                    e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e
                }
                _removeInactiveAction(e) {
                    let t = this._actions,
                        n = t[t.length - 1],
                        r = e._cacheIndex;
                    n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                    let i = e._clip.uuid,
                        a = this._actionsByClip,
                        s = a[i],
                        o = s.knownActions,
                        l = o[o.length - 1],
                        u = e._byClipCacheIndex;
                    l._byClipCacheIndex = u, o[u] = l, o.pop(), e._byClipCacheIndex = null;
                    let c = s.actionByRoot,
                        h = (e._localRoot || this._root).uuid;
                    delete c[h], 0 === o.length && delete a[i], this._removeInactiveBindingsForAction(e)
                }
                _removeInactiveBindingsForAction(e) {
                    let t = e._propertyBindings;
                    for (let n = 0, r = t.length; n !== r; ++n) {
                        let i = t[n];
                        0 == --i.referenceCount && this._removeInactiveBinding(i)
                    }
                }
                _lendAction(e) {
                    let t = this._actions,
                        n = e._cacheIndex,
                        r = this._nActiveActions++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _takeBackAction(e) {
                    let t = this._actions,
                        n = e._cacheIndex,
                        r = --this._nActiveActions,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _addInactiveBinding(e, t, n) {
                    let r = this._bindingsByRootAndName,
                        i = this._bindings,
                        a = r[t];
                    void 0 === a && (a = {}, r[t] = a), a[n] = e, e._cacheIndex = i.length, i.push(e)
                }
                _removeInactiveBinding(e) {
                    let t = this._bindings,
                        n = e.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        a = this._bindingsByRootAndName,
                        s = a[r],
                        o = t[t.length - 1],
                        l = e._cacheIndex;
                    o._cacheIndex = l, t[l] = o, t.pop(), delete s[i], 0 === Object.keys(s).length && delete a[r]
                }
                _lendBinding(e) {
                    let t = this._bindings,
                        n = e._cacheIndex,
                        r = this._nActiveBindings++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _takeBackBinding(e) {
                    let t = this._bindings,
                        n = e._cacheIndex,
                        r = --this._nActiveBindings,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _lendControlInterpolant() {
                    let e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && ((n = new uF(new Float32Array(2), new Float32Array(2), 1, c8)).__cacheIndex = t, e[t] = n), n
                }
                _takeBackControlInterpolant(e) {
                    let t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = t[r];
                    e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
                }
                clipAction(e, t, n) {
                    let r = t || this._root,
                        i = r.uuid,
                        a = "string" == typeof e ? uX.findByName(r, e) : e,
                        s = null !== a ? a.uuid : e,
                        o = this._actionsByClip[s],
                        l = null;
                    if (void 0 === n && (n = null !== a ? a.blendMode : tx), void 0 !== o) {
                        let u = o.actionByRoot[i];
                        if (void 0 !== u && u.blendMode === n) return u;
                        l = o.knownActions[0], null === a && (a = l._clip)
                    }
                    if (null === a) return null;
                    let c = new c6(this, a, t, n);
                    return this._bindAction(c, l), this._addInactiveAction(c, s, i), c
                }
                existingAction(e, t) {
                    let n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? uX.findByName(n, e) : e,
                        a = i ? i.uuid : e,
                        s = this._actionsByClip[a];
                    return void 0 !== s && s.actionByRoot[r] || null
                }
                stopAllAction() {
                    let e = this._actions,
                        t = this._nActiveActions;
                    for (let n = t - 1; n >= 0; --n) e[n].stop();
                    return this
                }
                update(e) {
                    e *= this.timeScale;
                    let t = this._actions,
                        n = this._nActiveActions,
                        r = this.time += e,
                        i = Math.sign(e),
                        a = this._accuIndex ^= 1;
                    for (let s = 0; s !== n; ++s) {
                        let o = t[s];
                        o._update(r, e, i, a)
                    }
                    let l = this._bindings,
                        u = this._nActiveBindings;
                    for (let c = 0; c !== u; ++c) l[c].apply(a);
                    return this
                }
                setTime(e) {
                    this.time = 0;
                    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                    return this.update(e)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(e) {
                    let t = this._actions,
                        n = e.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        let a = i.knownActions;
                        for (let s = 0, o = a.length; s !== o; ++s) {
                            let l = a[s];
                            this._deactivateAction(l);
                            let u = l._cacheIndex,
                                c = t[t.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, c._cacheIndex = u, t[u] = c, t.pop(), this._removeInactiveBindingsForAction(l)
                        }
                        delete r[n]
                    }
                }
                uncacheRoot(e) {
                    let t = e.uuid,
                        n = this._actionsByClip;
                    for (let r in n) {
                        let i = n[r].actionByRoot,
                            a = i[t];
                        void 0 !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
                    }
                    let s = this._bindingsByRootAndName,
                        o = s[t];
                    if (void 0 !== o)
                        for (let l in o) {
                            let u = o[l];
                            u.restoreOriginalState(), this._removeInactiveBinding(u)
                        }
                }
                uncacheAction(e, t) {
                    let n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }
            class c9 {
                constructor(e) {
                    this.value = e
                }
                clone() {
                    return new c9(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }
            let he = 0;
            class ht extends t7 {
                constructor(e) {
                    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
                        value: he++
                    }), this.name = "", this.usage = t$, this.uniforms = [], this.__offsetNeedsUpdate = [], this.count = void 0 !== e ? e : 1
                }
                add(e) {
                    return this.uniforms.push(e), this
                }
                remove(e) {
                    this.count > 0 && e && this.__offsetNeedsUpdate.push([e.__offset, e.__data.slice().fill(0)]);
                    let t = this.uniforms.indexOf(e);
                    return -1 !== t && this.uniforms.splice(t, 1), this
                }
                setName(e) {
                    return this.name = e, this
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                dispose() {
                    return this.dispatchEvent({
                        type: "dispose"
                    }), this
                }
                copy(e) {
                    this.name = e.name, this.usage = e.usage;
                    let t = e.uniforms;
                    this.uniforms.length = 0;
                    for (let n = 0, r = t.length; n < r; n++) this.uniforms.push(t[n].clone());
                    return this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class hn extends ot {
                constructor(e, t, n = 1) {
                    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                clone(e) {
                    let t = super.clone(e);
                    return t.meshPerAttribute = this.meshPerAttribute, t
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
                }
            }
            class hr {
                constructor(e, t, n, r, i) {
                    this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setBuffer(e) {
                    return this.buffer = e, this
                }
                setType(e, t) {
                    return this.type = e, this.elementSize = t, this
                }
                setItemSize(e) {
                    return this.itemSize = e, this
                }
                setCount(e) {
                    return this.count = e, this
                }
            }
            class hi {
                constructor(e, t, n = 0, r = 1 / 0) {
                    this.ray = new rh(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new rS, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                }
                intersectObject(e, t = !0, n = []) {
                    return hs(e, this, n, t), n.sort(ha), n
                }
                intersectObjects(e, t = !0, n = []) {
                    for (let r = 0, i = e.length; r < i; r++) hs(e[r], this, n, t);
                    return n.sort(ha), n
                }
            }

            function ha(e, t) {
                return e.distance - t.distance
            }

            function hs(e, t, n, r) {
                if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) {
                    let i = e.children;
                    for (let a = 0, s = i.length; a < s; a++) hs(i[a], t, n, !0)
                }
            }
            class ho {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
                makeSafe() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(ni(t / this.radius, -1, 1))), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class hl {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let hu = new np;
            class hc {
                constructor(e = new np(Infinity, Infinity), t = new np(-1 / 0, -1 / 0)) {
                    this.isBox2 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    let n = hu.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x) && !(e.x > this.max.x) && !(e.y < this.min.y) && !(e.y > this.max.y)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x) && !(e.min.x > this.max.x) && !(e.max.y < this.min.y) && !(e.min.y > this.max.y)
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    let t = hu.copy(e).clamp(this.min, this.max);
                    return t.sub(e).length()
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            let hh = new nj,
                hd = new nj;
            class hf {
                constructor(e = new nj, t = new nj) {
                    this.start = e, this.end = t
                }
                set(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                }
                copy(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                }
                getCenter(e) {
                    return e.addVectors(this.start, this.end).multiplyScalar(.5)
                }
                delta(e) {
                    return e.subVectors(this.end, this.start)
                }
                distanceSq() {
                    return this.start.distanceToSquared(this.end)
                }
                distance() {
                    return this.start.distanceTo(this.end)
                }
                at(e, t) {
                    return this.delta(t).multiplyScalar(e).add(this.start)
                }
                closestPointToPointParameter(e, t) {
                    hh.subVectors(e, this.start), hd.subVectors(this.end, this.start);
                    let n = hd.dot(hd),
                        r = hd.dot(hh),
                        i = r / n;
                    return t && (i = ni(i, 0, 1)), i
                }
                closestPointToPoint(e, t, n) {
                    let r = this.closestPointToPointParameter(e, t);
                    return this.delta(n).multiplyScalar(r).add(this.start)
                }
                applyMatrix4(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                }
                equals(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let hp = new nj;
            class hm extends rF {
                constructor(e, t) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                    let n = new iu,
                        r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                    for (let i = 0, a = 1; i < 32; i++, a++) {
                        let s = i / 32 * Math.PI * 2,
                            o = a / 32 * Math.PI * 2;
                        r.push(Math.cos(s), Math.sin(s), 1, Math.cos(o), Math.sin(o), 1)
                    }
                    n.setAttribute("position", new r9(r, 3));
                    let l = new o1({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.cone = new le(n, l), this.add(this.cone), this.update()
                }
                dispose() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }
                update() {
                    this.light.updateMatrixWorld();
                    let e = this.light.distance ? this.light.distance : 1e3,
                        t = e * Math.tan(this.light.angle);
                    this.cone.scale.set(t, t, e), hp.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(hp), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }
            let hg = new nj,
                hv = new rd,
                h_ = new rd;
            class hy extends le {
                constructor(e) {
                    let t = function e(t) {
                            let n = [];
                            !0 === t.isBone && n.push(t);
                            for (let r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                            return n
                        }(e),
                        n = new iu,
                        r = [],
                        i = [],
                        a = new nR(0, 0, 1),
                        s = new nR(0, 1, 0);
                    for (let o = 0; o < t.length; o++) {
                        let l = t[o];
                        l.parent && l.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(s.r, s.g, s.b))
                    }
                    n.setAttribute("position", new r9(r, 3)), n.setAttribute("color", new r9(i, 3));
                    let u = new o1({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    });
                    super(n, u), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(e) {
                    let t = this.bones,
                        n = this.geometry,
                        r = n.getAttribute("position");
                    h_.copy(this.root.matrixWorld).invert();
                    for (let i = 0, a = 0; i < t.length; i++) {
                        let s = t[i];
                        s.parent && s.parent.isBone && (hv.multiplyMatrices(h_, s.matrixWorld), hg.setFromMatrixPosition(hv), r.setXYZ(a, hg.x, hg.y, hg.z), hv.multiplyMatrices(h_, s.parent.matrixWorld), hg.setFromMatrixPosition(hv), r.setXYZ(a + 1, hg.x, hg.y, hg.z), a += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class hx extends iC {
                constructor(e, t, n) {
                    let r = new uc(t, 4, 2),
                        i = new rJ({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        });
                    super(r, i), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
                update() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }
            }
            let hb = new nj,
                hw = new nR,
                hS = new nR;
            class hM extends rF {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                    let r = new uo(t);
                    r.rotateY(.5 * Math.PI), this.material = new rJ({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    }), void 0 === this.color && (this.material.vertexColors = !0);
                    let i = r.getAttribute("position"),
                        a = new Float32Array(3 * i.count);
                    r.setAttribute("color", new r0(a, 3)), this.add(new iC(r, this.material)), this.update()
                }
                dispose() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
                update() {
                    let e = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        let t = e.geometry.getAttribute("color");
                        hw.copy(this.light.color), hS.copy(this.light.groundColor);
                        for (let n = 0, r = t.count; n < r; n++) {
                            let i = n < r / 2 ? hw : hS;
                            t.setXYZ(n, i.r, i.g, i.b)
                        }
                        t.needsUpdate = !0
                    }
                    e.lookAt(hb.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }
            class hT extends le {
                constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
                    n = new nR(n), r = new nR(r);
                    let i = t / 2,
                        a = e / t,
                        s = e / 2,
                        o = [],
                        l = [];
                    for (let u = 0, c = 0, h = -s; u <= t; u++, h += a) {
                        o.push(-s, 0, h, s, 0, h), o.push(h, 0, -s, h, 0, s);
                        let d = u === i ? n : r;
                        d.toArray(l, c), c += 3, d.toArray(l, c), c += 3, d.toArray(l, c), c += 3, d.toArray(l, c), c += 3
                    }
                    let f = new iu;
                    f.setAttribute("position", new r9(o, 3)), f.setAttribute("color", new r9(l, 3));
                    let p = new o1({
                        vertexColors: !0,
                        toneMapped: !1
                    });
                    super(f, p), this.type = "GridHelper"
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class hA extends le {
                constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, a = 8947848) {
                    i = new nR(i), a = new nR(a);
                    let s = [],
                        o = [];
                    if (t > 1)
                        for (let l = 0; l < t; l++) {
                            let u = l / t * (2 * Math.PI),
                                c = Math.sin(u) * e,
                                h = Math.cos(u) * e;
                            s.push(0, 0, 0), s.push(c, 0, h);
                            let d = 1 & l ? i : a;
                            o.push(d.r, d.g, d.b), o.push(d.r, d.g, d.b)
                        }
                    for (let f = 0; f < n; f++) {
                        let p = 1 & f ? i : a,
                            m = e - e / n * f;
                        for (let g = 0; g < r; g++) {
                            let v = g / r * (2 * Math.PI),
                                _ = Math.sin(v) * m,
                                y = Math.cos(v) * m;
                            s.push(_, 0, y), o.push(p.r, p.g, p.b), _ = Math.sin(v = (g + 1) / r * (2 * Math.PI)) * m, y = Math.cos(v) * m, s.push(_, 0, y), o.push(p.r, p.g, p.b)
                        }
                    }
                    let x = new iu;
                    x.setAttribute("position", new r9(s, 3)), x.setAttribute("color", new r9(o, 3));
                    let b = new o1({
                        vertexColors: !0,
                        toneMapped: !1
                    });
                    super(x, b), this.type = "PolarGridHelper"
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            let hE = new nj,
                hC = new nj,
                hI = new nj;
            class hP extends rF {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                    let r = new iu;
                    r.setAttribute("position", new r9([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                    let i = new o1({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.lightPlane = new o8(r, i), this.add(this.lightPlane), (r = new iu).setAttribute("position", new r9([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new o8(r, i), this.add(this.targetLine), this.update()
                }
                dispose() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }
                update() {
                    hE.setFromMatrixPosition(this.light.matrixWorld), hC.setFromMatrixPosition(this.light.target.matrixWorld), hI.subVectors(hC, hE), this.lightPlane.lookAt(hC), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(hC), this.targetLine.scale.z = hI.length()
                }
            }
            let hR = new nj,
                hL = new iO;
            class hD extends le {
                constructor(e) {
                    let t = new iu,
                        n = new o1({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        }),
                        r = [],
                        i = [],
                        a = {};

                    function s(e, t) {
                        o(e), o(t)
                    }

                    function o(e) {
                        r.push(0, 0, 0), i.push(0, 0, 0), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1)
                    }
                    s("n1", "n2"), s("n2", "n4"), s("n4", "n3"), s("n3", "n1"), s("f1", "f2"), s("f2", "f4"), s("f4", "f3"), s("f3", "f1"), s("n1", "f1"), s("n2", "f2"), s("n3", "f3"), s("n4", "f4"), s("p", "n1"), s("p", "n2"), s("p", "n3"), s("p", "n4"), s("u1", "u2"), s("u2", "u3"), s("u3", "u1"), s("c", "t"), s("p", "c"), s("cn1", "cn2"), s("cn3", "cn4"), s("cf1", "cf2"), s("cf3", "cf4"), t.setAttribute("position", new r9(r, 3)), t.setAttribute("color", new r9(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
                    let l = new nR(16755200),
                        u = new nR(16711680),
                        c = new nR(43775),
                        h = new nR(16777215),
                        d = new nR(3355443);
                    this.setColors(l, u, c, h, d)
                }
                setColors(e, t, n, r, i) {
                    let a = this.geometry,
                        s = a.getAttribute("color");
                    s.setXYZ(0, e.r, e.g, e.b), s.setXYZ(1, e.r, e.g, e.b), s.setXYZ(2, e.r, e.g, e.b), s.setXYZ(3, e.r, e.g, e.b), s.setXYZ(4, e.r, e.g, e.b), s.setXYZ(5, e.r, e.g, e.b), s.setXYZ(6, e.r, e.g, e.b), s.setXYZ(7, e.r, e.g, e.b), s.setXYZ(8, e.r, e.g, e.b), s.setXYZ(9, e.r, e.g, e.b), s.setXYZ(10, e.r, e.g, e.b), s.setXYZ(11, e.r, e.g, e.b), s.setXYZ(12, e.r, e.g, e.b), s.setXYZ(13, e.r, e.g, e.b), s.setXYZ(14, e.r, e.g, e.b), s.setXYZ(15, e.r, e.g, e.b), s.setXYZ(16, e.r, e.g, e.b), s.setXYZ(17, e.r, e.g, e.b), s.setXYZ(18, e.r, e.g, e.b), s.setXYZ(19, e.r, e.g, e.b), s.setXYZ(20, e.r, e.g, e.b), s.setXYZ(21, e.r, e.g, e.b), s.setXYZ(22, e.r, e.g, e.b), s.setXYZ(23, e.r, e.g, e.b), s.setXYZ(24, t.r, t.g, t.b), s.setXYZ(25, t.r, t.g, t.b), s.setXYZ(26, t.r, t.g, t.b), s.setXYZ(27, t.r, t.g, t.b), s.setXYZ(28, t.r, t.g, t.b), s.setXYZ(29, t.r, t.g, t.b), s.setXYZ(30, t.r, t.g, t.b), s.setXYZ(31, t.r, t.g, t.b), s.setXYZ(32, n.r, n.g, n.b), s.setXYZ(33, n.r, n.g, n.b), s.setXYZ(34, n.r, n.g, n.b), s.setXYZ(35, n.r, n.g, n.b), s.setXYZ(36, n.r, n.g, n.b), s.setXYZ(37, n.r, n.g, n.b), s.setXYZ(38, r.r, r.g, r.b), s.setXYZ(39, r.r, r.g, r.b), s.setXYZ(40, i.r, i.g, i.b), s.setXYZ(41, i.r, i.g, i.b), s.setXYZ(42, i.r, i.g, i.b), s.setXYZ(43, i.r, i.g, i.b), s.setXYZ(44, i.r, i.g, i.b), s.setXYZ(45, i.r, i.g, i.b), s.setXYZ(46, i.r, i.g, i.b), s.setXYZ(47, i.r, i.g, i.b), s.setXYZ(48, i.r, i.g, i.b), s.setXYZ(49, i.r, i.g, i.b), s.needsUpdate = !0
                }
                update() {
                    let e = this.geometry,
                        t = this.pointMap;
                    hL.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), hk("c", t, e, hL, 0, 0, -1), hk("t", t, e, hL, 0, 0, 1), hk("n1", t, e, hL, -1, -1, -1), hk("n2", t, e, hL, 1, -1, -1), hk("n3", t, e, hL, -1, 1, -1), hk("n4", t, e, hL, 1, 1, -1), hk("f1", t, e, hL, -1, -1, 1), hk("f2", t, e, hL, 1, -1, 1), hk("f3", t, e, hL, -1, 1, 1), hk("f4", t, e, hL, 1, 1, 1), hk("u1", t, e, hL, .7, 1.1, -1), hk("u2", t, e, hL, -.7, 1.1, -1), hk("u3", t, e, hL, 0, 2, -1), hk("cf1", t, e, hL, -1, 0, 1), hk("cf2", t, e, hL, 1, 0, 1), hk("cf3", t, e, hL, 0, -1, 1), hk("cf4", t, e, hL, 0, 1, 1), hk("cn1", t, e, hL, -1, 0, -1), hk("cn2", t, e, hL, 1, 0, -1), hk("cn3", t, e, hL, 0, -1, -1), hk("cn4", t, e, hL, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }

            function hk(e, t, n, r, i, a, s) {
                hR.set(i, a, s).unproject(r);
                let o = t[e];
                if (void 0 !== o) {
                    let l = n.getAttribute("position");
                    for (let u = 0, c = o.length; u < c; u++) l.setXYZ(o[u], hR.x, hR.y, hR.z)
                }
            }
            let hU = new nZ;
            class hO extends le {
                constructor(e, t = 16776960) {
                    let n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        r = new Float32Array(24),
                        i = new iu;
                    i.setIndex(new r0(n, 1)), i.setAttribute("position", new r0(r, 3)), super(i, new o1({
                        color: t,
                        toneMapped: !1
                    })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                }
                update(e) {
                    if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && hU.setFromObject(this.object), hU.isEmpty()) return;
                    let t = hU.min,
                        n = hU.max,
                        r = this.geometry.attributes.position,
                        i = r.array;
                    i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
                setFromObject(e) {
                    return this.object = e, this.update(), this
                }
                copy(e, t) {
                    return super.copy(e, t), this.object = e.object, this
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class hF extends le {
                constructor(e, t = 16776960) {
                    let n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        r = new iu;
                    r.setIndex(new r0(n, 1)), r.setAttribute("position", new r9([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new o1({
                        color: t,
                        toneMapped: !1
                    })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                }
                updateMatrixWorld(e) {
                    let t = this.box;
                    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class hN extends o8 {
                constructor(e, t = 1, n = 16776960) {
                    let r = new iu;
                    r.setAttribute("position", new r9([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new o1({
                        color: n,
                        toneMapped: !1
                    })), this.type = "PlaneHelper", this.plane = e, this.size = t;
                    let i = new iu;
                    i.setAttribute("position", new r9([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i.computeBoundingSphere(), this.add(new iC(i, new rJ({
                        color: n,
                        opacity: .2,
                        transparent: !0,
                        depthWrite: !1,
                        toneMapped: !1
                    })))
                }
                updateMatrixWorld(e) {
                    this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
            }
            let hB = new nj;
            class hz extends rF {
                constructor(e = new nj(0, 0, 1), t = new nj(0, 0, 0), n = 1, r = 16776960, i = .2 * n, a = .2 * i) {
                    super(), this.type = "ArrowHelper", void 0 === s && ((s = new iu).setAttribute("position", new r9([0, 0, 0, 0, 1, 0], 3)), (o = new lB(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new o8(s, new o1({
                        color: r,
                        toneMapped: !1
                    })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new iC(o, new rJ({
                        color: r,
                        toneMapped: !1
                    })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, a)
                }
                setDirection(e) {
                    if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
                    else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                    else {
                        hB.set(e.z, 0, -e.x).normalize();
                        let t = Math.acos(e.y);
                        this.quaternion.setFromAxisAngle(hB, t)
                    }
                }
                setLength(e, t = .2 * e, n = .2 * t) {
                    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
                }
                setColor(e) {
                    this.line.material.color.set(e), this.cone.material.color.set(e)
                }
                copy(e) {
                    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
                }
                dispose() {
                    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
                }
            }
            class hG extends le {
                constructor(e = 1) {
                    let t = new iu;
                    t.setAttribute("position", new r9([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], 3)), t.setAttribute("color", new r9([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                    let n = new o1({
                        vertexColors: !0,
                        toneMapped: !1
                    });
                    super(t, n), this.type = "AxesHelper"
                }
                setColors(e, t, n) {
                    let r = new nR,
                        i = this.geometry.attributes.color.array;
                    return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class hV {
                constructor() {
                    this.type = "ShapePath", this.color = new nR, this.subPaths = [], this.currentPath = null
                }
                moveTo(e, t) {
                    return this.currentPath = new lU, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
                }
                lineTo(e, t) {
                    return this.currentPath.lineTo(e, t), this
                }
                quadraticCurveTo(e, t, n, r) {
                    return this.currentPath.quadraticCurveTo(e, t, n, r), this
                }
                bezierCurveTo(e, t, n, r, i, a) {
                    return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this
                }
                splineThru(e) {
                    return this.currentPath.splineThru(e), this
                }
                toShapes(e) {
                    let t, n, r, i, a;
                    let s = ut.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    let l = [];
                    if (1 === o.length) return n = o[0], (r = new lZ).curves = n.curves, l.push(r), l;
                    let u = !s(o[0].getPoints());
                    u = e ? !u : u;
                    let c = [],
                        h = [],
                        d = [],
                        f = 0;
                    h[0] = void 0, d[f] = [];
                    for (let p = 0, m = o.length; p < m; p++) t = s(i = (n = o[p]).getPoints()), (t = e ? !t : t) ? (!u && h[f] && f++, h[f] = {
                        s: new lZ,
                        p: i
                    }, h[f].s.curves = n.curves, u && f++, d[f] = []) : d[f].push({
                        h: n,
                        p: i[0]
                    });
                    if (!h[0]) return function(e) {
                        let t = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            let i = e[n],
                                a = new lZ;
                            a.curves = i.curves, t.push(a)
                        }
                        return t
                    }(o);
                    if (h.length > 1) {
                        let g = !1,
                            v = 0;
                        for (let _ = 0, y = h.length; _ < y; _++) c[_] = [];
                        for (let x = 0, b = h.length; x < b; x++) {
                            let w = d[x];
                            for (let S = 0; S < w.length; S++) {
                                let M = w[S],
                                    T = !0;
                                for (let A = 0; A < h.length; A++)(function(e, t) {
                                    let n = t.length,
                                        r = !1;
                                    for (let i = n - 1, a = 0; a < n; i = a++) {
                                        let s = t[i],
                                            o = t[a],
                                            l = o.x - s.x,
                                            u = o.y - s.y;
                                        if (Math.abs(u) > Number.EPSILON) {
                                            if (u < 0 && (s = t[a], l = -l, o = t[i], u = -u), e.y < s.y || e.y > o.y) continue;
                                            if (e.y === s.y) {
                                                if (e.x === s.x) return !0
                                            } else {
                                                let c = u * (e.x - s.x) - l * (e.y - s.y);
                                                if (0 === c) return !0;
                                                if (c < 0) continue;
                                                r = !r
                                            }
                                        } else {
                                            if (e.y !== s.y) continue;
                                            if (o.x <= e.x && e.x <= s.x || s.x <= e.x && e.x <= o.x) return !0
                                        }
                                    }
                                    return r
                                })(M.p, h[A].p) && (x !== A && v++, T ? (T = !1, c[A].push(M)) : g = !0);
                                T && c[x].push(M)
                            }
                        }
                        v > 0 && !1 === g && (d = c)
                    }
                    for (let E = 0, C = h.length; E < C; E++) {
                        r = h[E].s, l.push(r), a = d[E];
                        for (let I = 0, P = a.length; I < P; I++) r.holes.push(a[I].h)
                    }
                    return l
                }
            }
            let hW = function() {
                let e = new ArrayBuffer(4),
                    t = new Float32Array(e),
                    n = new Uint32Array(e),
                    r = new Uint32Array(512),
                    i = new Uint32Array(512);
                for (let a = 0; a < 256; ++a) {
                    let s = a - 127;
                    s < -27 ? (r[a] = 0, r[256 | a] = 32768, i[a] = 24, i[256 | a] = 24) : s < -14 ? (r[a] = 1024 >> -s - 14, r[256 | a] = 1024 >> -s - 14 | 32768, i[a] = -s - 1, i[256 | a] = -s - 1) : s <= 15 ? (r[a] = s + 15 << 10, r[256 | a] = s + 15 << 10 | 32768, i[a] = 13, i[256 | a] = 13) : s < 128 ? (r[a] = 31744, r[256 | a] = 64512, i[a] = 24, i[256 | a] = 24) : (r[a] = 31744, r[256 | a] = 64512, i[a] = 13, i[256 | a] = 13)
                }
                let o = new Uint32Array(2048),
                    l = new Uint32Array(64),
                    u = new Uint32Array(64);
                for (let c = 1; c < 1024; ++c) {
                    let h = c << 13,
                        d = 0;
                    for (;
                        (8388608 & h) == 0;) h <<= 1, d -= 8388608;
                    h &= -8388609, d += 947912704, o[c] = h | d
                }
                for (let f = 1024; f < 2048; ++f) o[f] = 939524096 + (f - 1024 << 13);
                for (let p = 1; p < 31; ++p) l[p] = p << 23;
                l[31] = 1199570944, l[32] = 2147483648;
                for (let m = 33; m < 63; ++m) l[m] = 2147483648 + (m - 32 << 23);
                l[63] = 3347054592;
                for (let g = 1; g < 64; ++g) 32 !== g && (u[g] = 1024);
                return {
                    floatView: t,
                    uint32View: n,
                    baseTable: r,
                    shiftTable: i,
                    mantissaTable: o,
                    exponentTable: l,
                    offsetTable: u
                }
            }();
            var hH = Object.freeze({
                __proto__: null,
                toHalfFloat: function(e) {
                    Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = ni(e, -65504, 65504), hW.floatView[0] = e;
                    let t = hW.uint32View[0],
                        n = t >> 23 & 511;
                    return hW.baseTable[n] + ((8388607 & t) >> hW.shiftTable[n])
                },
                fromHalfFloat: function(e) {
                    let t = e >> 10;
                    return hW.uint32View[0] = hW.mantissaTable[hW.offsetTable[t] + (1023 & e)] + hW.exponentTable[t], hW.floatView[0]
                }
            });

            function hj() {
                console.error("THREE.ImmediateRenderObject has been removed.")
            }
            class hq extends nN {
                constructor(e, t, n) {
                    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, n), this.samples = 4
                }
            }
            class hX extends nB {
                constructor(e, t, n, r) {
                    console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, n, r)
                }
            }
            class hZ extends nG {
                constructor(e, t, n, r) {
                    console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, n, r)
                }
            }
            class hY extends iP {
                constructor(e, t, n, r, i, a) {
                    console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, n, r, i, a)
                }
            }
            class h$ extends lF {
                constructor(e, t, n, r) {
                    console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, n, r)
                }
            }
            class hJ extends lN {
                constructor(e, t, n, r) {
                    console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, n, r)
                }
            }
            class hK extends lz {
                constructor(e, t, n, r, i, a, s) {
                    console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, n, r, i, a, s)
                }
            }
            class hQ extends lB {
                constructor(e, t, n, r, i, a, s, o) {
                    console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, n, r, i, a, s, o)
                }
            }
            class h0 extends lV {
                constructor(e, t) {
                    console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t)
                }
            }
            class h1 extends ui {
                constructor(e, t) {
                    console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t)
                }
            }
            class h2 extends us {
                constructor(e, t) {
                    console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t)
                }
            }
            class h3 extends lO {
                constructor(e, t, n, r) {
                    console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, n, r)
                }
            }
            class h4 extends uo {
                constructor(e, t) {
                    console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t)
                }
            }
            class h5 extends i$ {
                constructor(e, t, n, r) {
                    console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, n, r)
                }
            }
            class h6 extends lG {
                constructor(e, t, n, r) {
                    console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, n, r)
                }
            }
            class h8 extends ul {
                constructor(e, t, n, r, i, a) {
                    console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, n, r, i, a)
                }
            }
            class h7 extends uu {
                constructor(e, t) {
                    console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t)
                }
            }
            class h9 extends uc {
                constructor(e, t, n, r, i, a, s) {
                    console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, n, r, i, a, s)
                }
            }
            class de extends uh {
                constructor(e, t) {
                    console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t)
                }
            }
            class dt extends ud {
                constructor(e, t, n, r, i) {
                    console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, n, r, i)
                }
            }
            class dn extends uf {
                constructor(e, t, n, r, i, a) {
                    console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, n, r, i, a)
                }
            }
            class dr extends up {
                constructor(e, t, n, r, i) {
                    console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, n, r, i)
                }
            }
            "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = l)
        }
    },
    function(e) {
        var t = function(t) {
            return e(e.s = t)
        };
        e.O(0, [774, 179], function() {
            return t(3837), t(880)
        }), _N_E = e.O()
    }
]);